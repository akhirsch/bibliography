\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[letterpaper, margin=1in, bottom=1in]{geometry}
\usepackage[authoryear,sort,square]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bbold}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{latex-pl-syntax/pl-syntax}
\usepackage{xspace}
\usepackage{suffix}
\usepackage{turnstile}
\usepackage{multicol}

\usepackage[hidelinks]{hyperref}

% Notes
\newcommand{\uncertain}[1]{{\color{red} #1}\xspace}
\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\newcommenter{\akh}{purple}{AKH}
\newcommenter{\as}{red}{AS}

% AMSTHM Setup
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}
\newtheorem{inv}{Invariant}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

%% Macros

% Context Projection
\newcommand\proj[2]{\ensuremath{\left.#1\right|_{#2}}}

% Endpoint Projection
\newcommand\epp[2]{\ensuremath{\llbracket#1\rrbracket_{#2}}}

\newcommand\step[1]{\ensuremath{\xRightarrow{{#1}}_{\raisebox{3pt}{\footnotesize{c}}}}}

\newcommand\app[2]{\ensuremath{#1 \; #2}}
\newcommand\send[3]{\ensuremath{#1 \overset{#2}{\rightsquigarrow} #3}}
\newcommand\ifthen[3]{\ensuremath{\text{if}\; #1 \;\text{then}\; #2 \;\text{else}\; #3}}
\newcommand\letin[3]{\ensuremath{\text{let}\; #1 \;:=\; #2 \;\text{in}\; #3}}


\begin{document}
\section{Syntax}
\begin{syntax}
	\categoryFromSet[Location Values]{L}{\mathcal{L}}
	\category[Synchronization Labels]{d}
	\alternative{\text{Left}}
	\alternative{\text{Right}}
	\\
	\abstractCategory[Local Kinds]{\kappa_e}
	\category[Choreographic Kinds]{\kappa}
	\alternative{*}
	\alternative{*_\ell}
	\alternative{\kappa_e}
	\\
	\abstractCategory[Local Types]{t_e}
	
	\category[Locations]{\ell}
	\alternative{X}
	\alternative{L}
	
	\category[Locally Bound Types]{t}
	\alternative{X}
	\alternative{t_e}
	
	\category[Choreographic Types]{\tau}
	\alternative{X}
	\alternative{t @ \ell}
	\alternative{\tau_1 \rightarrow \tau_2}
	\alternative{\forall X : \kappa.\tau}
	
	\category[Types]{T}
	\alternative{\ell}
	\alternative{t}
	\alternative{\tau}
	\\
	\abstractCategory[Local Expressions]{e}
	
	\category[Choreographies]{C}
	\alternative{x}
	\alternative{\ell.e}
	\alternative{\lambda x : \tau.C}
	\alternative{\mu x : \tau.C}
	\alternative{\app{C_1}{C_2}}\\
	\alternative{\send{C}{\ell_1}{\ell_2}}
	\alternative{\send{\ell_1[d]}{}{\ell_2};C}\\
	\alternative{\ell.\ifthen{C}{C_1}{C_2}}\\
	\alternative{\Lambda X : \kappa.C}
	\alternative{\app{C}{T}}\\
	\alternative{\letin{\ell.x : t}{C_1}{C_2}}\\
	\alternative{\letin{\ell.X : \kappa_e}{C_1}{C_2}}
\end{syntax}


\section{Type System}
\paragraph{Contexts}
\begin{syntax}
	\category[Choreographic Kinding Context]{\Sigma}
	\alternative{\cdot}
	\alternative{\Sigma, X : \kappa}

	\category[Choreographic Typing Context]{\Gamma}
	\alternative{\cdot}
	\alternative{\Gamma, x : \tau}
	
	\category[Locally Bound Typing Context]{\Delta}
	\alternative{\cdot}
	\alternative{\Delta, \ell.x : t}
	\\
	\category[Local Kinding Context]{\Sigma_e}
	\alternative{\cdot}
	\alternative{\Sigma_e, X : \kappa_e}
	
	\category[Local Typing Context]{\Delta_e}
	\alternative{\cdot}
	\alternative{\Delta_e, x : t}
\end{syntax}

\paragraph{Context Projection}
Projects a choreographic kinding context $\Sigma$ to a local kinding context $\proj{\Sigma}{e}$, and a locally bound typing context $\Delta$ to a local typing context $\proj{\Delta}{\ell}$ at a possibly variable location $\ell$. Note that because choreographic kinding contexts $\Sigma$ bind types globally, the projection does not depend on the chosen location and just preserves types of a local kind $\kappa_e$ from the context.
\begin{align*}
	\proj{\cdot}{e} &= \cdot \\
	\proj{(\Sigma, X : *)}{e} &= \proj{\Sigma}{e}\\
	\proj{(\Sigma, X : *_\ell)}{e} &= \proj{\Sigma}{e}\\
	\proj{(\Sigma, X : \kappa_e)}{e} &= \proj{\Sigma}{e}, X : \kappa_e\\
	\proj{\cdot}{\ell} &= \cdot \\
	\proj{(\Delta, \ell.x : t)}{\ell} &=
	\begin{cases} 
		\proj{\Delta}{\ell}, x : t & \ell' = \ell \\
		\proj{\Delta}{\ell} & \ell' \neq \ell \\
	\end{cases}
\end{align*}

\paragraph{Judgments}
\begin{align*}
	\Sigma &\vdash \Gamma \tag{Choreographic Typing Context Well-Formedness}\\
	\Sigma &\vdash \Delta \tag{Locally Bound Typing Context Well-Formedness}\\
	\Sigma &\vdash T : \kappa \tag{Type Kinding Judgment}\\
	\Sigma; \Gamma; \Delta &\vdash C : \tau \tag{Choreography Typing Judgment}\\
	\Sigma_e &\vdash_e t : \kappa_e \tag{Local Type Kinding Judgment}\\
	\Sigma_e;\Delta_e &\vdash_e e : t \tag{Local Expression Typing Judgment}
\end{align*}

\paragraph{Context Well-Formedness Rules}\;\\
\begin{mathparpagebreakable}
   \infer[EmpTy]{}
  {\Sigma \vdash \cdot} \and

  \infer[AddTy]{\Sigma \vdash \tau : * \\
	\Sigma \vdash \Gamma}
  {\Sigma \vdash (\Gamma, x : \tau)} \and
	
  \infer[EmpLocalTy]{}
	{\Sigma \vdash \cdot} \and
	
  \infer[AddLocalTy]{\Sigma \vdash \ell : *_\ell \\
  	\Sigma \vdash t : *_e \\
    \Sigma \vdash \Delta}
  {\Sigma \vdash (\Delta, \ell.x : t)}
\end{mathparpagebreakable}

\paragraph{Kinding Rules}\;
\begin{mathparpagebreakable}
	\infer[VarTy]{X : \kappa \in \Sigma}
	{\Sigma \vdash X : \kappa} \and
	
	\infer[LocValTy]{}
	{\Sigma \vdash L : *_\ell} \and
	
	\infer[LocalTy]{\proj{\Sigma}{e} \vdash_e t : \kappa_e}
	{\Sigma \vdash t : \kappa_e}

	\infer[AtTy]{\Sigma \vdash \ell : *_\ell \\
	\Sigma \vdash t : *_e}
	{\Sigma \vdash t @ \ell : *}

	\infer[ArrowTy]{\Sigma \vdash \tau_1 : *\\
	  \Sigma \vdash \tau_2 : *}
	{\Sigma \vdash \tau_1 \rightarrow \tau_2 : *}
	
	\infer[ForAllTy]{(\Sigma, X : \kappa) \vdash \tau : *}
	{\Sigma \vdash \forall X : \kappa.\tau : *}
\end{mathparpagebreakable}

\paragraph{Choreography Typing Rules}\;
\begin{mathparpagebreakable}
  \infer[Var]{\Sigma \vdash \Gamma \\
  	\Sigma \vdash \Delta \\
    x : \tau \in \Gamma}
  {\Sigma;\Gamma;\Delta \vdash x : \tau} \and

  \infer[Local]{\Sigma \vdash \Gamma \\
  	\Sigma \vdash \Delta \\
  	\Sigma \vdash \ell : *_\ell\\
  	\proj{\Sigma}{e};\proj{\Delta}{\ell} \vdash_e e : t}
  {\Sigma;\Gamma;\Delta \vdash \ell.e \vdash t @ \ell} \and

  \infer[Send]{\Sigma;\Gamma;\Delta \vdash C : t @ \ell_1 \\
	\Sigma \vdash \ell_2 : *_\ell}
  {\Sigma;\Gamma;\Delta \vdash \send{C}{\ell_1}{\ell_2} : t @ \ell_2} \and

  \infer[Sync]{\Sigma \vdash \ell_1 : *_\ell \\
    \Sigma \vdash \ell_2 : *_\ell\\
    \Sigma;\Gamma;\Delta \vdash C : \tau}
	{\Sigma;\Gamma;\Delta \vdash \send{\ell_1[d]}{}{\ell_2}; C : \tau} \and

  \infer[If]{\Sigma;\Gamma;\Delta \vdash C_1 : \text{bool} @ \ell \\
    \Sigma;\Gamma;\Delta \vdash C_1 : \tau \\
    \Sigma;\Gamma;\Delta \vdash C_2 : \tau}
  {\Sigma;\Gamma;\Delta \vdash \ell.\ifthen{C}{C_1}{C_2}} \and

  \infer[Fun]{\Sigma;(\Gamma, x : \tau_1);\Delta \vdash C : \tau_2}
  {\Sigma;\Gamma;\Delta \vdash \lambda x : \tau_1.C : \tau_1 \rightarrow \tau_2} \and

  \infer[Rec]{\Sigma;(\Gamma, x : \tau);\Delta \vdash C : \tau}
  {\Sigma;\Gamma;\Delta \vdash \mu x : \tau.C : \tau} \and

  \infer[App]{\Sigma;\Gamma;\Delta \vdash C_1 : \tau_1 \rightarrow \tau_2 \\
    \Sigma;\Gamma;\Delta \vdash C_2 : \tau_1}
  {\Sigma;\Gamma;\Delta \vdash \app{C_1}{C_2} : \tau_2} \and

  \infer[AbsTy]{(\Sigma, X : \kappa);\Gamma;\Delta \vdash C : \tau}
  {\Sigma;\Gamma;\Delta \vdash \Lambda X : \kappa.C : \forall X : \kappa.\tau} \and

  \infer[AppTy]{\Sigma;\Gamma;\Delta \vdash C : \forall X : \kappa.\tau \\
    \Sigma \vdash T : \kappa}
  {\Sigma;\Gamma;\Delta \vdash \app{C}{T} : \tau[X \mapsto T]} \and

  \infer[LocalLet]{\Sigma;\Gamma;\Delta \vdash C_1 : t_1 @ \ell \\
	\Sigma;\Gamma;(\Delta, x : \ell.t_1) \vdash C_2 : \tau_2}
  {\Sigma;\Gamma;\Delta \vdash \letin{\ell.x : t_1}{C_1}{C_2}} \and

  \infer[LocalLetTy]{\Sigma;\Gamma;\Delta \vdash C_1 : \kappa_e @ \ell \\
  	\Sigma;\Gamma;\Delta \vdash \tau : *\\
    (\Sigma,X : \kappa_e);\Gamma;\Delta \vdash C_2 : \tau}
  {\Sigma;\Gamma;\Delta \vdash \letin{\ell.X : \kappa_e}{C_1}{C_2} : \tau}
\end{mathparpagebreakable}

\section{Operational Semantics}
\paragraph{Traces}\;
\begin{syntax}
	\category[Trace Elements]{T}
	\alternative{\bullet}\\
	\alternative{L}\\
	\alternative{L_1[d] \rightsquigarrow L_2}\\
	\alternative{L_1[v] \rightsquigarrow L_2}\\
	\alternative{L_1[L_2] \rightsquigarrow L_2}\\
	\alternative{L_1[t] \rightsquigarrow L_2}
\end{syntax}

\paragraph{Trace Semantics} Deterministic, small-step trace semantics $C_1 \step{T} C_2$ where $C_1, C_2$ are \emph{closed} choreographies, and $T$ is a trace element.

\begin{mathparpagebreakable}
  \infer[Done]{e_1 \Rightarrow_e e_2}
  {L.e_1 \step{L} L.e_2} \and

  \infer[Send]{C_1 \step{T} C_2}
  {C_1 \overset{L_1}{\rightsquigarrow} L_2 \step{T} C_2 \overset{L_1}{\rightsquigarrow} L_2} \and

  \infer[SendV]{\text{Value}(v)}
  {L_1.v \overset{L_1}{\rightsquigarrow} L_2 \step{L_1[v] \rightsquigarrow L_2} L_2.v} \and

  \infer[If]{C \step{T} C'}
  {L.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2 \step{T} L.\text{if}\; C' \;\text{then}\; C_1 \;\text{else}\; C_2} \and

  \infer[IfT]{}
  {L.\text{if}\; L.\text{true} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{L} C_1} \and

  \infer[IfF]{}
  {L.\text{if}\; L.\text{false} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{L} C_2} \and

  \infer[DefLocal]{C_1 \step{T} C_1'}
  {\text{let}\; L.x := C_1 \;\text{in}\; C_2 \step{T} \text{let}\; L.x := C_1' \;\text{in}\; C_2} \and

  \infer[DefLocalV]{\text{Value}(v)}
  {\text{let}\; L.x := L.v \;\text{in}\; C \step{\bullet} C[x \mapsto v]} \and

  \infer[AppFun]{C_1 \step{T} C_1'}
  {C_1 \; C_2 \step{T} C_1' \; C_2} \and

  \infer[AppArg]{\text{Value}(V_1)\\
  	C_2 \step{T} C_2'}
  {V_1 \; C_2 \step{T} V_1 \; C_2'} \and

  \infer[App]{\text{Value}(V)}
  {(\lambda \alpha.C) \; V \step{\bullet} C[\alpha \mapsto V]} \and
  
  \infer[Fix]{}
  {\mu \alpha.C \step{\bullet} C[\alpha \mapsto \mu \alpha.C]} \and

  \infer[Sync]{}
  {L_1[d] \rightsquigarrow L_2; C \step{L_1[d] \rightsquigarrow L_2} C} \and

  \infer[LocApp]{}
  {(\Lambda X.C) \; L \step{\bullet} C[X \mapsto L]} \and

  \infer[TellLet]{C_1 \step{T} C_1'}
  {L.\text{tell}\; \rho_1\; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2 \step{T} L.\text{tell}\; \rho_1\; \text{let}\; X := C_1' \in \rho_2 \;\text{in}\; C_2}

  \infer[TellLetV]{}
  {L_1.\text{tell}\; \rho_1\; \text{let}\; X := L_1.L_2 \in \rho_2 \;\text{in}\; C \step{L_1[L_2] \rightsquigarrow \rho_1 \cup \rho_2} C[X \mapsto L_2]}
\end{mathparpagebreakable}

\section{Endpoint Projection}
\paragraph{Control Language}
\begin{syntax}
    \category[Control Expression]{E}
    \alternative{\alpha}
    \alternative{()}
	\alternative{E_1 ; E_2}
	\alternative{E_1\;E_2}\\
    \alternative{\lambda \alpha.E}
    \alternative{\mu \alpha.E}\\
	\alternative{\Lambda X.E}
    \alternative{E\;\ell}\\
    \alternative{\text{ret}(e)}
    \alternative{\text{let}\; \text{ret}(x) := E_1 \;\text{in}\; E_2}\\
    \alternative{\text{send}\; E \;\text{to}\; \ell}
    \alternative{\text{receive from}\;  \ell}\\
    \alternative{\text{if}\; E \;\text{then}\; E_1 \;\text{else}\; E_2}\\
    \alternative{\text{choose}\; d \;\text{for}\;  \ell ; E}\\
    \alternative{\text{allow}\; \ell \;\text{choice}\; (d \Rightarrow E)^*}\\
    \alternative{\text{send tell}\; \rho \;\text{let}\; X := E_1 \;\text{in}\; E_2}\\
    \alternative{\text{receive}\; X \;\text{from}\; \ell \;\text{in}\; E}\\
	\alternative{\text{AmI}\; \ell \;\text{then}\; E_1 \;\text{else}\; E_2}

    \category[Systems]{\Pi}
    \alternative{L_1 \triangleright E_1 \;\|\; \ldots \;\|\; L_n \triangleright E_n}
\end{syntax}

\paragraph{Endpoint Projection}\;
\begin{mathparpagebreakable}
\begin{aligned}[t]
	\epp{\alpha}{L} &= \alpha\\
	\epp{\ell.e}{L} &=
		\begin{cases}
			\text{ret}(e) & L = \ell \\
			() & L \neq \ell
		\end{cases}\\
	\epp{C \overset{\ell_1}{\rightsquigarrow} \ell_2}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{send}\; \epp{C}{L} \;\text{to}\; \ell_2 & L = \ell_1 \neq \ell_2 \\
			\text{receive from}\;\ell_1 & L = \ell_2 \neq \ell_1\\
			() & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\ell.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2}{L} &= 
		\begin{cases}
			\text{if}\; \epp{C}{L} \;\text{then}\; \epp{C_1}{L} \;\text{else}\; \epp{C_2}{L} & L = \ell \\
			\epp{C_1}{L} \sqcup \epp{C_2}{L} & L \neq \ell
		\end{cases}\\
	\epp{\ell_1[d] \rightsquigarrow \ell_2; C}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{choose}\; d \;\text{for}\; \ell_2; \epp{C}{L} & L = \ell_1 \neq \ell_2 \\
			\text{allow}\; \ell_1 \;\text{choice}\; (d \Rightarrow \epp{C}{L}) & L = \ell_2 \neq \ell_1\\
			\epp{C}{L} & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\text{let}\; \ell.x := C_1 \;\text{in}\; C_2}{L} &= 
		\begin{cases}
			\text{let}\; \text{ret}(x) := \epp{C_1}{L} \;\text{in}\; \epp{C_2}{L} & L = \ell \\
			\epp{C_1}{L} ; \epp{C_2}{L} & L \neq \ell
		\end{cases}\\
	\epp{\lambda \alpha.C}{L} &= \lambda \alpha.\epp{C}{L}\\
	\epp{\mu \alpha.C}{L} &= \mu \alpha.\epp{C}{L}\\
	\epp{C_1\;C_2}{L} &= \epp{C_1}{L}\;\epp{C_2}{L}\\
	\epp{\Lambda X.C}{L} &= \Lambda X.\text{AmI}\; X \;\text{then}\; \epp{C[X \mapsto L]}{L} \;\text{else}\; \epp{C}{L}\\
	\epp{C\;\ell}{L} &= \epp{C}{L}\;\ell\\
	\epp{\ell.\text{tell}\; \rho_1 \; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2}{L} &= 
		\begin{cases}
			\text{send tell}\; (\rho_1 \cup \rho_2) \setminus \{\ell\} \;\text{let}\; X := \epp{C_1}{L} \;\text{in}\\ \text{AmI}\; X \;\text{then}\; \epp{C_2[X \mapsto L]}{L} \;\text{else}\; \epp{C_2}{L} & L = \ell\\
			\epp{C_1}{L} ; \text{receive}\; X \;\text{from}\; \ell \;\text{in}\;\\
			\text{AmI}\; X \;\text{then}\; \epp{C_2[X \mapsto L]}{L} \;\text{else}\; \epp{C_2}{L} & L \neq \ell, L \in \rho_1 \cup \rho_2\\
			\epp{C_1}{L} & L \neq \ell, L \notin \rho_1 \cup \rho_2
		\end{cases}
\end{aligned}
\end{mathparpagebreakable}


\section{Meeting Notes}
\paragraph{3/7/2024}
\subparagraph{Misc}
\begin{itemize}
	\item Local values don't seem to have an elimination form with current system
	\item Don't need to track blocking sets in reduction rules; can compute from redices
\end{itemize}

\subparagraph{Tell-do Concerns}
\begin{itemize}
	\item How do we know who to send the tell-do to, as it's using a local value?
	\item We need to statically compute an over-approximation of the set of possible recipients
	\item Idea: Have the local language compute the over-approximation, and have its soundness be an assumption for the deadlock freedom guarantees.
	\[
	\text{tell}\; x := C_1 \;\text{do}[S]\; C_2
	\]
	\item $S$ is a \emph{set} of locations that the message will be sent to
	\item Could just send to everyone, but this uses a closed-world assumption
	\item Weird example suggested by Ethan: Choreography where Alice continually discovers and adds new known locations, and at each point she randomly selects a person from this set to delegate something to. At each point the set is finite, but it will increase infinitely, and the size depends at which step you're at.
	\item Need to use implicit sends rather than explicit sends (might need to do alias analysis on the value of the local location otherwise!)
\end{itemize}

\paragraph{3/14/2024}
\subparagraph{Out-of-Order Execution}
With send operations in the form $C_1 \overset{\ell_1}{\rightsquigarrow} \ell_2$ it becomes difficult to tell when you can do out-of-order execution as you need to examine $C_1$; it could block more than just $\ell_1$. Moreover, you need to allow for reduction within the scope of a function/lambda abstraction in order to do so, as this is required to use the output of a send operation. You can \emph{probably} solve this problem through a meta-function, but the old syntax works fine and is just as general, so I will use it.

Solution: Revert send operations to the form $\ell_1.e \rightsquigarrow \ell_2.\alpha; C$. Now we can easily tell that $C$ can execute out-of-order when $\ell_1$ and $\ell_2$ are blocked.

Other solution: Use an in-order trace semantics for choreographies; function application comes easily. Then to deal with correctness use an equivalence relation on the traces allowing for re-ordering.

\subparagraph{Delegation}
For the tell-do binding, won't you need to send the chosen location to more than just the possible set of locations it can be anyways? For instance:
\begin{align*}
	&\text{tell}\; X \in \{W_1,W_2\} := D.e_1 \;\text{do}\\
	&X.e_2 \rightsquigarrow \alpha @ \text{Alice};\\
	&\text{let}\; \text{Alice}.x := \alpha \;\text{in}\\
	&\text{Alice}.e_3
\end{align*}
Alice needs to know which X was chosen as she needs to receive from them, even though she is not among $\{D,W_1,W_2\}$. Thus we need to know the set of all processes who may be involved.

OK, then just try and compute the involved processes statically! Problem: Higher order functions. Who is involved in the process $\lambda \alpha : \tau_1 \rightarrow \tau_2.C$? Well, because $\alpha$ is another choreography, it depends on who is involved in $\alpha$. Do what Alice or Bob does and annotate choreographic functions with a set of processes and allow for abstraction over them: $\text{IP}(\lambda \alpha : \tau_1 \rightarrow_\rho \tau_2.C) = \rho \cup \text{IP}(C)$. This complicates the type system but seems necessary if we want to allow for this form of delegation.
Solution:
\begin{align*}
	&\text{tell}_{\{\text{Alice}\}}\; X \in \{W_1,W_2\} := D.e_1 \;\text{do}\\
	&X.e_2 \rightsquigarrow \alpha @ \text{Alice};\\
	&\text{let}\; \text{Alice}.x := \alpha \;\text{in}\\
	&\text{Alice}.e_3
\end{align*}
Send $X$ to $\{Alice, W_1, W_2\}$. If someone tries to use $X$ inside the body and we didn't sent it to them, the endpoint projection will fail.

\paragraph{3/26/2024}
\subparagraph{Local Substitution}
Local substitution has to be defined to avoid capture of locations. For instance:
\begin{align*}
&(\Lambda \ell. \;\text{let}\; \ell.x = \ell.2 \;\text{in}\\
&\;\text{let}\; L.x = L.3 \;\text{in}\\
&\;\text{let}\; \ell.y = L.x \rightsquigarrow \ell \;\text{in}\\
&\;\ell.(x + y))\; L
\end{align*}
When you substitute $L$ in for $\ell$ naively, you capture $\ell.x$ in the final expression and rebind it to $L.x$, and end up computing $L.6$ instead of $L.5$.
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-master: t
%%% End: