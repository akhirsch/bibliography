\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[letterpaper, margin=1in, bottom=1in]{geometry}
\usepackage[authoryear,sort,square]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bbold}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{latex-pl-syntax/pl-syntax}
\usepackage{xspace}
\usepackage{suffix}
\usepackage{turnstile}
\usepackage{multicol}

\usepackage[hidelinks]{hyperref}

% Notes
\newcommand{\uncertain}[1]{{\color{red} #1}\xspace}
\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\newcommenter{\akh}{purple}{AKH}
\newcommenter{\as}{red}{AS}

% AMSTHM Setup
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}
\newtheorem{inv}{Invariant}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

%% Macros

% Context Projection
\newcommand\proj[2]{\ensuremath{\left.#1\right|_{#2}}}

% Endpoint Projection
\newcommand\epp[2]{\ensuremath{\llbracket#1\rrbracket_{#2}}}

\newcommand\step[2]{\ensuremath{\xRightarrow{{#1} \hfill{} {#2}}_{\raisebox{3pt}{\footnotesize{c}}}}}

\bibliographystyle{plainnat}

\begin{document}

\section{Meeting Notes}
\paragraph{Misc}
\begin{itemize}
	\item Local values don't seem to have an elimination form with current system
	\item Don't need to track blocking sets in reduction rules; can compute from redices
\end{itemize}

\paragraph{Tell-do Concerns}
\begin{itemize}
	\item How do we know who to send the tell-do to, as it's using a local value?
	\item We need to statically compute an over-approximation of the set of possible recipients
	\item Idea: Have the local language compute the over-approximation, and have its soundness be an assumption for the deadlock freedom guarantees.
	\[
	\text{tell}\; x := C_1 \;\text{do}[S]\; C_2
	\]
	\item $S$ is a \emph{set} of locations that the message will be sent to
	\item Could just send to everyone, but this uses a closed-world assumption
	\item Weird example suggested by Ethan: Choreography where Alice continually discovers and adds new known locations, and at each point she randomly selects a person from this set to delegate something to. At each point the set is finite, but it will increase infinitely, and the size depends at which step you're at.
	\item Need to use implicit sends rather than explicit sends (might need to do alias analysis on the value of the local location otherwise!)
\end{itemize}

\section{Syntax}
\begin{syntax}
	\categoryFromSet[Conrete Locations]{L}{\mathcal{L}}
	\abstractCategory[Location Variables]{X, Y, Z}
		
	\category[Locations]{\ell}
	\alternative{L}
	\alternative{X}
	\\
	\abstractCategory[Local Expressions]{e}
		
	\abstractCategory[Local Variables]{x, y, z}
	
	\\
	\abstractCategory[Choreography Variables]{\alpha, \beta, \phi}
	
	\category[Synchronization Labels]{d}
	\alternative{\mathbb{L}}
	\alternative{\mathbb{R}}

	
	\category[Choreographies]{C}
	\alternative{\alpha}
	\alternative{\ell.e}
	\alternative{\ell_1.e \rightsquigarrow \alpha @ \ell_2; C_2}\\
	\alternative{\text{if}\; \ell.e \;\text{then}\; C_1 \;\text{else}\; C_2}\\
	\alternative{\ell_1[d] \rightsquigarrow \ell_2; C}\\
	\alternative{\text{let}\; \ell.x := C_1 \;\text{in}\; C_2}\\
	\alternative{\text{fun}\; \phi(\alpha) := C}
	\alternative{C_1\;C_2}\\
	\alternative{\Lambda X.C}
	\alternative{C\;\ell}\\
	\alternative{\ell.\text{tell}\; X \in \{\ell_1,\ldots,\ell_n\} := C_1 \;\text{do}\; C_2}
\end{syntax}


\section{Type System}
\paragraph{Syntax of Types}
\begin{syntax}
	\abstractCategory[Local Types]{t}

	\category[Choreography Types]{\tau}
	\alternative{t @ \ell}
	\alternative{\tau_1 \rightarrow \tau_2}
	\alternative{\forall X.\tau}
	
	\category[Location Contexts]{\Theta}
	\alternative{\cdot}
	\alternative{\Theta, X : \text{Loc}}
	
	\category[Local-Let Contexts]{\Delta}
	\alternative{\cdot}
	\alternative{\Delta, \ell.x : t}
	
	\category[Choreography Contexts]{\Gamma}
	\alternative{\cdot}
	\alternative{\Gamma, \alpha : \tau}
\end{syntax}

\paragraph{Context Projection}
Projects a local-let context $\Delta$ to a local context at a (possibly variable) location $\ell$.
\begin{align*}
	\proj{\cdot}{\ell} &= \cdot \\
	\proj{\Delta, \ell.x : t}{\ell} &=
		\begin{cases} 
      		\proj{\Delta}{\ell}, x : t & \ell' = \ell \\
      		\proj{\Delta}{\ell} & \ell' \neq \ell \\
   		\end{cases}
\end{align*}

\paragraph{Typing Relations}
\begin{align*}
	\Theta &\vdash \Delta \tag{Local-Let Context Well-Formedness}\\
	\Theta &\vdash \Gamma \tag{Choreography Context Well-Formedness}\\
	\Theta &\vdash \ell \tag{Location Well-Formedness}\\
	\Theta &\vdash \tau \tag{Choreography Type Well-Formedness}\\
	\Theta;\Gamma;\Delta &\vdash \tau \tag{Choreography Typing Relation}
\end{align*}

\paragraph{Context, Type, and Location Well-Formedness Rules}
\begin{mathpar}
  \infer[EmpCtx]{}
  {\Theta \vdash \cdot} \and

  \infer[AddCtxLet]{\Theta \vdash \Delta \\
    \Theta \vdash \ell \;\text{Loc}}
  {\Theta \vdash \Gamma, \ell.x : t} \and

  \infer[AddCtxChor]{\Theta \vdash \Gamma \\
    \Theta \vdash \tau \;\text{Ty}}
  {\Theta \vdash \Gamma, \alpha : \tau} \and

  \infer[Loc]{\ell \in \mathcal{L} \cup \Theta}
  {\Theta \vdash \ell \;\text{Loc}} \and

  \infer[AtTy]{\Theta \vdash \ell \;\text{Loc}}
  {\Theta \vdash t @ \ell \;\text{Ty}} \and

  \infer[FunTy]{\Theta \vdash \tau_1  \;\text{Ty}\\
    \Theta \vdash \tau_2 \;\text{Ty}}
  {\Theta \vdash \tau_1 \rightarrow \tau_2 \;\text{Ty}} \and

  \infer[AllTy]{\Theta, X \;\text{Loc} \vdash \tau \;\text{Ty}}
  {\Theta \vdash \forall X.\tau  \;\text{Ty}} \and
\end{mathpar}

\paragraph{Choreography Typing Rules}
\begin{mathpar}
  \infer[Var]{\Theta \vdash \Gamma \\
  	\Theta \vdash \Delta \\
    x : \tau \in \Gamma}
  {\Theta;\Gamma;\Delta \vdash x : \tau} \and

  \infer[Done]{\Theta \vdash \Gamma \\
  	\Theta \vdash \Delta \\
    \Theta \vdash \ell \;\text{Loc} \\
    \proj{\Delta}{\ell} \vdash e : t}
  {\Theta;\Gamma;\Delta \vdash \ell.e \vdash t @ \ell} \and

  \infer[Send]{\Theta \vdash \ell_1, \ell_2 \;\text{Loc} \\
    \proj{\Delta}{\ell_1} \vdash e : t_1 \\
    \Theta;\Gamma;(\Delta, \alpha : t_1 @ \ell_2) \vdash C : \tau_2}
  {\Theta;\Gamma;\Delta \vdash \ell_1.e \rightsquigarrow \alpha @ \ell_2;C : \tau_2} \and

  \infer[If]{\proj{\Delta}{\ell} \vdash e : \text{bool} \\
    \Theta;\Gamma;\Delta \vdash C_1 : \tau \\
    \Theta;\Gamma;\Delta \vdash C_2 : \tau}
  {\Gamma \vdash \text{if}\; \ell.e \;\text{then}\; C_1 \;\text{else}\; C_2 : \tau} \and

  \infer[Sync]{\Gamma \vdash \ell_1, \ell_2 \;\text{Loc} \\
    \Theta;\Gamma;\Delta \vdash C : \tau}
  {\Theta;\Gamma;\Delta \vdash \ell_1[d] \rightsquigarrow \ell_2; C : \tau} \and

  \infer[LocalLet]{\Theta;\Gamma;\Delta \vdash C_1 : t_1 @ \ell \\
    \Theta;(\Gamma, x : \ell.t_1);\Delta \vdash C : \tau_2}
  {\Gamma \vdash \text{let}\; \ell.x := C_1 \;\text{in}\; C_2 : \tau_2} \and

  \infer[Fun]{\Theta;\Gamma;(\Delta, \phi : \tau_1 \rightarrow \tau_2, \alpha : \tau_1) \vdash C : \tau_2}
  {\Theta;\Gamma;\Delta  \vdash \text{fun}\; \phi(\alpha) := C : \tau_1 \rightarrow \tau_2} \and

  \infer[App]{\Theta;\Gamma;\Delta \vdash C_1 : \tau_1 \rightarrow \tau_2 \\
    \Theta;\Gamma;\Delta \vdash C_2 : \tau_1}
  {\Theta;\Gamma;\Delta  \vdash C_1\;C_2 : \tau_2} \and

  \infer[LocAbs]{(\Theta, X : \;\text{Loc});\Gamma;\Delta \vdash C : \tau}
  {\Theta;\Gamma;\Delta  \vdash \Lambda X.C : \forall X.\tau} \and

  \infer[LocApp]{\Theta \vdash \ell \;\text{Loc} \\
    \Theta;\Gamma;\Delta  \vdash C : \forall X.\tau}
  {\Theta;\Gamma;\Delta  \vdash C\;\ell : \tau[X \mapsto \ell]} \and

  \infer[TellDo]{\Theta;\Gamma;\Delta  \vdash C_1 : \text{Loc} @ \ell \\
    \Theta \vdash \tau \;\text{Ty} \\
    \Theta \vdash \ell_1,\ldots,\ell_n \;\text{Loc} \\
    (\Theta, X : \;\text{Loc});\Gamma;\Delta \vdash C_2 : \tau}
  {\Gamma \vdash \ell.\text{tell}\; X \in \{\ell_1,\ldots,\ell_n\} := C_1 \;\text{do}\; C_2 : \tau}
\end{mathpar}

\section{Operational Semantics}

\as{Only using redices without block sets presents some challenges at a first glance, so I'm sticking with block sets for now.}

\as{Letting sends be a singular operation actually makes allowing for out-of-order execution very difficult. To do so we essentially need to allow for reductions under a lambda abstraction/let binding, which introduces multiple problems.}

\paragraph{Redices}
\begin{syntax}
	\category[Redices]{R}
	\alternative{L.(e_1 \Rightarrow e_2)}
	\alternative{\text{if}\;L.(e_1 \Rightarrow e_2)}
	\alternative{\text{if}\;L.\text{true}}
	\alternative{\text{if}\;L.\text{false}}\\
	\alternative{L_1.(e_1 \Rightarrow e_2) \rightsquigarrow L_2}
	\alternative{L_1.(v\;\text{value}) \rightsquigarrow L_2}
	\alternative{L_1[d] \rightsquigarrow L_2}\\
	\alternative{\text{let}\;L.x := (v \;\text{value})}\\
	\alternative{\text{Arg}(R)}
	\alternative{\text{Fun}(R)}
	\alternative{\text{Fun}}
	\alternative{\text{Loc}}\\
	\alternative{L.\text{tell}\; X \in \{L_1,\ldots,L_n\} := L.L_i}
\end{syntax}

\paragraph{Semantics}\;
\begin{mathparpagebreakable}
  \infer[DoneE]{e_1 \Rightarrow_e e_2 \\
    L \notin \mathcal{B}}
  {L.e_1 \step{L.(e_1 \Rightarrow e_2)}{\mathcal{B}} L.e_2} \and

  \infer[SendE]{e_1 \Rightarrow_e e_2 \\
    L_1 \notin \mathcal{B}}
  {L_1.e_1 \rightsquigarrow \alpha @ L_2;C \step{L_1.(e_1 \Rightarrow e_2) \rightsquigarrow L_2}{\mathcal{B}} L_1.e_2 \rightsquigarrow \alpha @ L_2;C} \and

  \infer[SendV]{\text{Value}(v) \\
    L_1, L_2 \notin \mathcal{B}}
  {L_1.v \rightsquigarrow \alpha @ L_2;C \step{L_1.(v\;\text{value}) \rightsquigarrow L_2}{\mathcal{B}} C[\alpha \mapsto L_2.v]} \and

  \infer[IfE]{e_1 \Rightarrow_e e_2 \\
    L \notin \mathcal{B}}
  {\text{if}\; L.e_1 \;\text{then}\; C_1 \;\text{else}\; C_2 \step{\text{if}\;L.(e_1 \Rightarrow e_2)}{\mathcal{B}} \text{if}\; L.e_2 \;\text{then}\; C_1 \;\text{else}\; C_2} \and

  \infer[IfI]{C_1 \step{R}{\mathcal{B} \cup \{L\}} C_1' \\
    C_2 \step{R}{\mathcal{B} \cup \{L\}} C_2'}
  {\text{if}\; L.e \;\text{then}\; C_1 \;\text{else}\; C_2 \step{R}{\mathcal{B}} \text{if}\; L.e \;\text{then}\; C_1' \;\text{else}\; C_2'} \and

  \infer[IfT]{L \notin \mathcal{B}}
  {\text{if}\; L.\text{true} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{\text{if}\;L.\text{true}}{\mathcal{B}} C_1} \and

  \infer[IfF]{L \notin \mathcal{B}}
  {\text{if}\; L.\text{false} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{\text{if}\;L.\text{false}}{\mathcal{B}} C_2} \and

  \infer[Sync]{L_1, L_2 \notin \mathcal{B}}
  {L_1[d] \rightsquigarrow L_2; C \step{L_1[d] \rightsquigarrow L_2}{\mathcal{B}} C} \and

  \infer[SyncI]{C_1 \step{R}{\mathcal{B} \cup \{L_1,L_2\}} C_2}
  {L_1[d] \rightsquigarrow L_2; C_1 \step{R}{\mathcal{B}} L_1[d] \rightsquigarrow L_2; C_2} \and

  \infer[DefLocal]{C_1 \step{R}{\mathcal{B}} C_1'}
  {\text{let}\; L.x := C_1 \;\text{in}\; C_2 \step{\text{Arg}(R)}{\mathcal{B}} \text{let}\; L.x := C_1' \;\text{in}\; C_2} \and

  \infer[DefLocalV]{\text{Value}(v)}
  {\text{let}\; L.x := L.v \;\text{in}\; C \step{\text{let}\; L.x := (v \;\text{Value})}{\mathcal{B}} C[x \mapsto v]} \and

  \infer[AppFun]{C_1 \step{R}{\mathcal{B}} C_1'}
  {C_1 \; C_2 \step{\text{Fun}(R)}{\mathcal{B}} C_1' \; C_2} \and

  \infer[AppArg]{C_2 \step{R}{\mathcal{B}} C_2'}
  {C_1 \; C_2 \step{\text{Arg}(R)}{\mathcal{B}} C_1 \; C_2'} \and

  \infer[App]{\text{Value}(V)}
  {(\text{fun}\; \phi(\alpha) := C) \; V \step{\text{Fun}}{\emptyset} C[\phi \mapsto \text{fun}\; \phi(\alpha) := C, \alpha \mapsto V]} \and

  \infer[LocApp]{}
  {(\Lambda X.C) \; L \step{\text{Loc}}{\emptyset} C[X \mapsto L]} \and

  \infer[TellDo]{C_1 \step{R}{\mathcal{B}} C_1'}
  {L.\text{tell}\; X \in \{L_1,\ldots,L_n\} := C_1 \;\text{do}\; C_2 \step{\text{Arg}(R)}{\mathcal{B}} L.\text{tell}\; X \in \{L_1,\ldots,L_n\} := C_1' \;\text{do}\; C_2}

  \infer[TellDoV]{}
  {L.\text{tell}\; X \in \{L_1,\ldots,L_n\} := L.L_i \;\text{do}\; C \step{L.\text{tell}\; X \in \{L_1,\ldots,L_n\} := L.L_i}{\emptyset} C[X \mapsto L_i]}
\end{mathparpagebreakable}

\section{Endpoint Projection}
\paragraph{Control Language}
\begin{syntax}
    \category[Control Expression]{E}
    \alternative{x}
    \alternative{\text{fun}\;F(x) := E}
    \alternative{E_1\;E_2}\\
    \alternative{()}
    \alternative{\text{ret}(e)}
    \alternative{\text{let}\;x := E_1 \;\text{in}\; E_2}\\
    \alternative{\text{send}\; E \;\text{to}\; L}
    \alternative{\text{receive from}\; L}\\
    \alternative{\text{if}\; E \;\text{then}\; E_1 \;\text{else}\; E_2}
    \alternative{\text{choose}\; d \;\text{for}\; L ; E}\\
    \alternative{\text{allow}\; L \;\text{choice}\; (d \Rightarrow E)^*}\\
    \alternative{\text{send tell}\; x := E_1 \;\text{do}\; E_2}\\
    \alternative{\text{receive do}\; \lambda x.E \;\text{from}\; L}

    \category[Systems]{\Pi}
    \alternative{L_1 \triangleright E_1 \;\|\; \ldots \;\|\; L_n \triangleright E_n}
\end{syntax}

\paragraph{Endpoint Projection}
\as{Control language must include both ground and variable locations}
\as{Do we need type-guided projection like Alice \& Bob? Probably}
\as{How to project tell-do? Probably need to use AmI}
\as{Why does aligned hate me :(}
\begin{mathparpagebreakable}
\begin{aligned}[t]
	\epp{x}{L} &= ? \\
	\epp{\ell.e}{L} &= ? \\
	\epp{C \overset{\ell_1}{\rightsquigarrow} \ell_2}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{send}\; \epp{C}{L} \;\text{to}\; \ell_2 & L = \ell_1 \neq \ell_2 \\
			\text{receive from}\; \ell_1 & L = \ell_2 \neq \ell_1 \\
			() & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\ell.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2}{L} &=
		\begin{cases}
			\text{if}\; \epp{C}{L} \;\text{then}\; \epp{C_1}{L} \;\text{else}\; \epp{C_2}{L} & L = \ell \\
			\epp{C_1}{L} \sqcup \epp{C_2}{L} & L \neq \ell
		\end{cases}\\
	\epp{\ell_1[d] \rightsquigarrow \ell_2; C}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{choose}\; d \;\text{for}\; \ell_2 ; \epp{C}{L} & L = \ell_1 \neq \ell_2 \\
			\text{allow}\; \ell_1 \;\text{choice}\; (\mathbb{L} \Rightarrow \epp{C}{L}) & L = \ell_2 \neq \ell_1, d = \mathbb{L} \\
			\text{allow}\; \ell_1 \;\text{choice}\; (\mathbb{R} \Rightarrow \epp{C}{L}) & L = \ell_2 \neq \ell_1, d = \mathbb{R} \\
			\epp{C}{L} & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\text{let}\; x := C_1 \;\text{in}\; C_2}{L} &= \text{let}\; x := \epp{C_1}{L} \;\text{in}\; \epp{C_1}{L}\\
	\epp{\text{fun}\; F(x) := C}{L} &= \text{fun}\; F(x) := \epp{C}{L}\\
	\epp{\ell.\text{tell}\; x := C_1 \;\text{do}\; C_2}{L} &=
		\begin{cases}
			\text{send tell}\; x := \epp{C_1}{L} \;\text{do}\; \epp{C_2}{L} & L = \ell \\
			\text{receive do}\; \lambda x.\epp{C_2}{L} \;\text{from}\; \ell & L \neq \ell
		\end{cases}\\
\end{aligned}
\end{mathparpagebreakable}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-master: t
%%% End: