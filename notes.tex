\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[letterpaper, margin=1in, bottom=1in]{geometry}
\usepackage[authoryear,sort,square]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bbold}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{latex-pl-syntax/pl-syntax}
\usepackage{xspace}
\usepackage{suffix}
\usepackage{turnstile}
\usepackage{multicol}

\usepackage[hidelinks]{hyperref}

% Notes
\newcommand{\uncertain}[1]{{\color{red} #1}\xspace}
\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\newcommenter{\akh}{purple}{AKH}
\newcommenter{\as}{red}{AS}

% AMSTHM Setup
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}
\newtheorem{inv}{Invariant}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

%% Macros

% Context Projection
\newcommand\proj[2]{\ensuremath{\left.#1\right|_{#2}}}

% Endpoint Projection
\newcommand\epp[2]{\ensuremath{\llbracket#1\rrbracket_{#2}}}

% Semantics
\newcommand\step[1]{\ensuremath{\xRightarrow{{#1}}_{\raisebox{3pt}{\footnotesize{c}}}}}

% Syntax
\newcommand\app[2]{\ensuremath{#1 \; #2}}
\newcommand\send[3]{\ensuremath{#1 \overset{#2}{\rightsquigarrow} #3}}
\newcommand\ifthen[3]{\ensuremath{\text{if}\; #1 \;\text{then}\; #2 \;\text{else}\; #3}}
\newcommand\letin[3]{\ensuremath{\text{let}\; #1 \;:=\; #2 \;\text{in}\; #3}}
\newcommand\letinsend[4]{\ensuremath{\text{let}\; #1 \;:=\; #2 \rightsquigarrow #3 \;\text{in}\; #4}}


\begin{document}
\section{Syntax}
\begin{syntax}
	\categoryFromSet[Location Values]{L}{\mathcal{L}}
	\category[Synchronization Labels]{d}
	\alternative{\text{Left}}
	\alternative{\text{Right}}
	\\
	\abstractCategory[Local Kinds]{\kappa_e}
	\category[Choreographic Kinds]{\kappa}
	\alternative{*}
	\alternative{*_\ell}
	\alternative{*_s}
	\alternative{\kappa_e}
	\\
	\abstractCategory[Local Types]{t_e}

	\category[Types]{T, \ell, \rho, t, \tau}
	\alternative{X}
	\alternative{L}
	\alternative{\varnothing}
	\alternative{\{\ell\}}
	\alternative{\rho_1 \cup \rho_2}
	\\
	\alternative{t_e}
	\alternative{t @ \ell}
	\alternative{\tau_1 \rightarrow \tau_2}
	\alternative{\forall X : \kappa.\tau}
	\\
	\abstractCategory[Local Expressions]{e}
	
	\category[Choreographies]{C}
	\alternative{x}
	\alternative{\ell.e}
	\alternative{\lambda x : \tau.C}
	\alternative{\mu x : \tau.C}
	\alternative{\app{C_1}{C_2}}\\
	\alternative{\send{C}{\ell_1}{\ell_2}}
	\alternative{\send{\ell_1[d]}{}{\ell_2};C}\\
	\alternative{\ell.\ifthen{C}{C_1}{C_2}}\\
	\alternative{\Lambda X : \kappa.C}
	\alternative{\app{C}{T}}\\
	\alternative{\letin{\ell.x : t}{C_1}{C_2}}\\
	\alternative{\letinsend{\ell.X : \kappa_e}{C_1}{\rho}{C_2}}
\end{syntax}


\section{Type System}
\paragraph{Contexts}
\begin{syntax}
	\category[Choreographic Kinding Context]{\Sigma}
	\alternative{\cdot}
	\alternative{\Sigma, X : \kappa}

	\category[Choreographic Typing Context]{\Gamma}
	\alternative{\cdot}
	\alternative{\Gamma, x : \tau}
	
	\category[Locally Bound Typing Context]{\Delta}
	\alternative{\cdot}
	\alternative{\Delta, \ell.x : t}
	\\
	\category[Local Kinding Context]{\Sigma_e}
	\alternative{\cdot}
	\alternative{\Sigma_e, X : \kappa_e}
	
	\category[Local Typing Context]{\Delta_e}
	\alternative{\cdot}
	\alternative{\Delta_e, x : t}
\end{syntax}

\paragraph{Context Projection}
Projects a choreographic kinding context $\Sigma$ to a local kinding context $\proj{\Sigma}{e}$, and a locally bound typing context $\Delta$ to a local typing context $\proj{\Delta}{\ell}$ at a possibly variable location $\ell$. Note that because choreographic kinding contexts $\Sigma$ bind types globally, the projection does not depend on the chosen location and just preserves types of a local kind $\kappa_e$ from the context.
\begin{align*}
	\proj{\cdot}{e} &= \cdot \\
	\proj{(\Sigma, X : *)}{e} &= \proj{\Sigma}{e}\\
	\proj{(\Sigma, X : *_\ell)}{e} &= \proj{\Sigma}{e}\\
	\proj{(\Sigma, X : \kappa_e)}{e} &= \proj{\Sigma}{e}, X : \kappa_e\\
	\proj{\cdot}{\ell} &= \cdot \\
	\proj{(\Delta, \ell.x : t)}{\ell} &=
	\begin{cases} 
		\proj{\Delta}{\ell}, x : t & \ell' = \ell \\
		\proj{\Delta}{\ell} & \ell' \neq \ell \\
	\end{cases}
\end{align*}

\paragraph{Judgments}
\begin{align*}
	\Sigma &\vdash \Gamma \tag{Choreographic Typing Context Well-Formedness}\\
	\Sigma &\vdash \Delta \tag{Locally Bound Typing Context Well-Formedness}\\
	\Sigma &\vdash T : \kappa \tag{Type Kinding Judgment}\\
	\Sigma; \Gamma; \Delta &\vdash C : \tau \tag{Choreography Typing Judgment}\\
	\Sigma_e &\vdash_e t : \kappa_e \tag{Local Type Kinding Judgment}\\
	\Sigma_e;\Delta_e &\vdash_e e : t \tag{Local Expression Typing Judgment}
\end{align*}

\paragraph{Context Well-Formedness Rules}\;\\
\begin{mathparpagebreakable}
   \infer[EmpTy]{}
  {\Sigma \vdash \cdot} \and

  \infer[AddTy]{\Sigma \vdash \tau : * \\
	\Sigma \vdash \Gamma}
  {\Sigma \vdash (\Gamma, x : \tau)} \and
	
  \infer[EmpLocalTy]{}
	{\Sigma \vdash \cdot} \and
	
  \infer[AddLocalTy]{\Sigma \vdash \ell : *_\ell \\
  	\Sigma \vdash t : *_e \\
    \Sigma \vdash \Delta}
  {\Sigma \vdash (\Delta, \ell.x : t)}
\end{mathparpagebreakable}

\paragraph{Kinding Rules}\;
\begin{mathparpagebreakable}
	\infer[VarTy]{X : \kappa \in \Sigma}
	{\Sigma \vdash X : \kappa} \and
	
	\infer[LocValTy]{}
	{\Sigma \vdash L : *_\ell} \and
	
	\infer[LocalTy]{\proj{\Sigma}{e} \vdash_e t : \kappa_e}
	{\Sigma \vdash t : \kappa_e}

	\infer[AtTy]{\Sigma \vdash \ell : *_\ell \\
	\Sigma \vdash t : *_e}
	{\Sigma \vdash t @ \ell : *}

	\infer[ArrowTy]{\Sigma \vdash \tau_1 : *\\
	  \Sigma \vdash \tau_2 : *}
	{\Sigma \vdash \tau_1 \rightarrow \tau_2 : *}
	
	\infer[ForAllTy]{(\Sigma, X : \kappa) \vdash \tau : *}
	{\Sigma \vdash \forall X : \kappa.\tau : *}
\end{mathparpagebreakable}

\paragraph{Choreography Typing Rules}\;
\begin{mathparpagebreakable}
  \infer[Var]{\Sigma \vdash \Gamma \\
  	\Sigma \vdash \Delta \\
    x : \tau \in \Gamma}
  {\Sigma;\Gamma;\Delta \vdash x : \tau} \and

  \infer[Local]{\Sigma \vdash \Gamma \\
  	\Sigma \vdash \Delta \\
  	\Sigma \vdash \ell : *_\ell\\
  	\proj{\Sigma}{e};\proj{\Delta}{\ell} \vdash_e e : t}
  {\Sigma;\Gamma;\Delta \vdash \ell.e \vdash t @ \ell} \and

  \infer[Send]{\Sigma;\Gamma;\Delta \vdash C : t @ \ell_1 \\
	\Sigma \vdash \ell_2 : *_\ell}
  {\Sigma;\Gamma;\Delta \vdash \send{C}{\ell_1}{\ell_2} : t @ \ell_2} \and

  \infer[Sync]{\Sigma \vdash \ell_1 : *_\ell \\
    \Sigma \vdash \ell_2 : *_\ell\\
    \Sigma;\Gamma;\Delta \vdash C : \tau}
	{\Sigma;\Gamma;\Delta \vdash \send{\ell_1[d]}{}{\ell_2}; C : \tau} \and

  \infer[If]{\Sigma;\Gamma;\Delta \vdash C_1 : \text{bool} @ \ell \\
    \Sigma;\Gamma;\Delta \vdash C_1 : \tau \\
    \Sigma;\Gamma;\Delta \vdash C_2 : \tau}
  {\Sigma;\Gamma;\Delta \vdash \ell.\ifthen{C}{C_1}{C_2}} \and

  \infer[Fun]{\Sigma;(\Gamma, x : \tau_1);\Delta \vdash C : \tau_2}
  {\Sigma;\Gamma;\Delta \vdash \lambda x : \tau_1.C : \tau_1 \rightarrow \tau_2} \and

  \infer[Rec]{\Sigma;(\Gamma, x : \tau);\Delta \vdash C : \tau}
  {\Sigma;\Gamma;\Delta \vdash \mu x : \tau.C : \tau} \and

  \infer[App]{\Sigma;\Gamma;\Delta \vdash C_1 : \tau_1 \rightarrow \tau_2 \\
    \Sigma;\Gamma;\Delta \vdash C_2 : \tau_1}
  {\Sigma;\Gamma;\Delta \vdash \app{C_1}{C_2} : \tau_2} \and

  \infer[AbsTy]{(\Sigma, X : \kappa);\Gamma;\Delta \vdash C : \tau}
  {\Sigma;\Gamma;\Delta \vdash \Lambda X : \kappa.C : \forall X : \kappa.\tau} \and

  \infer[AppTy]{\Sigma;\Gamma;\Delta \vdash C : \forall X : \kappa.\tau \\
    \Sigma \vdash T : \kappa}
  {\Sigma;\Gamma;\Delta \vdash \app{C}{T} : \tau[X \mapsto T]} \and

  \infer[LocalLet]{\Sigma;\Gamma;\Delta \vdash C_1 : t_1 @ \ell \\
	\Sigma;\Gamma;(\Delta, x : \ell.t_1) \vdash C_2 : \tau_2}
  {\Sigma;\Gamma;\Delta \vdash \letin{\ell.x : t_1}{C_1}{C_2}} \and

  \infer[LocalLetTy]{\Sigma;\Gamma;\Delta \vdash C_1 : \kappa_e @ \ell \\
  	\Sigma;\Gamma;\Delta \vdash \tau : *\\
    (\Sigma,X : \kappa_e);\Gamma;\Delta \vdash C_2 : \tau}
  {\Sigma;\Gamma;\Delta \vdash \letin{\ell.X : \kappa_e}{C_1}{C_2} : \tau}
\end{mathparpagebreakable}

\section{Operational Semantics}
\paragraph{Traces}\;
\begin{syntax}
	\category[Trace Elements]{T}
	\alternative{\bullet}\\
	\alternative{L}\\
	\alternative{L_1[d] \rightsquigarrow L_2}\\
	\alternative{L_1[v] \rightsquigarrow L_2}\\
	\alternative{L_1[L_2] \rightsquigarrow L_2}\\
	\alternative{L_1[t] \rightsquigarrow L_2}
\end{syntax}

\paragraph{Trace Semantics} Deterministic, small-step trace semantics $C_1 \step{T} C_2$ where $C_1, C_2$ are \emph{closed} choreographies, and $T$ is a trace element.

\begin{mathparpagebreakable}
  \infer[Done]{e_1 \Rightarrow_e e_2}
  {L.e_1 \step{L} L.e_2} \and

  \infer[Send]{C_1 \step{T} C_2}
  {C_1 \overset{L_1}{\rightsquigarrow} L_2 \step{T} C_2 \overset{L_1}{\rightsquigarrow} L_2} \and

  \infer[SendV]{\text{Value}(v)}
  {L_1.v \overset{L_1}{\rightsquigarrow} L_2 \step{L_1[v] \rightsquigarrow L_2} L_2.v} \and

  \infer[If]{C \step{T} C'}
  {L.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2 \step{T} L.\text{if}\; C' \;\text{then}\; C_1 \;\text{else}\; C_2} \and

  \infer[IfT]{}
  {L.\text{if}\; L.\text{true} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{L} C_1} \and

  \infer[IfF]{}
  {L.\text{if}\; L.\text{false} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{L} C_2} \and

  \infer[DefLocal]{C_1 \step{T} C_1'}
  {\text{let}\; L.x := C_1 \;\text{in}\; C_2 \step{T} \text{let}\; L.x := C_1' \;\text{in}\; C_2} \and

  \infer[DefLocalV]{\text{Value}(v)}
  {\text{let}\; L.x := L.v \;\text{in}\; C \step{\bullet} C[x \mapsto v]} \and

  \infer[AppFun]{C_1 \step{T} C_1'}
  {C_1 \; C_2 \step{T} C_1' \; C_2} \and

  \infer[AppArg]{\text{Value}(V_1)\\
  	C_2 \step{T} C_2'}
  {V_1 \; C_2 \step{T} V_1 \; C_2'} \and

  \infer[App]{\text{Value}(V)}
  {(\lambda \alpha.C) \; V \step{\bullet} C[\alpha \mapsto V]} \and
  
  \infer[Fix]{}
  {\mu \alpha.C \step{\bullet} C[\alpha \mapsto \mu \alpha.C]} \and

  \infer[Sync]{}
  {L_1[d] \rightsquigarrow L_2; C \step{L_1[d] \rightsquigarrow L_2} C} \and

  \infer[LocApp]{}
  {(\Lambda X.C) \; L \step{\bullet} C[X \mapsto L]} \and

  \infer[TellLet]{C_1 \step{T} C_1'}
  {L.\text{tell}\; \rho_1\; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2 \step{T} L.\text{tell}\; \rho_1\; \text{let}\; X := C_1' \in \rho_2 \;\text{in}\; C_2}

  \infer[TellLetV]{}
  {L_1.\text{tell}\; \rho_1\; \text{let}\; X := L_1.L_2 \in \rho_2 \;\text{in}\; C \step{L_1[L_2] \rightsquigarrow \rho_1 \cup \rho_2} C[X \mapsto L_2]}
\end{mathparpagebreakable}

\section{Endpoint Projection}
\paragraph{Control Language}
\begin{syntax}
    \category[Control Expression]{E}
    \alternative{\alpha}
    \alternative{()}
	\alternative{E_1 ; E_2}
	\alternative{E_1\;E_2}\\
    \alternative{\lambda \alpha.E}
    \alternative{\mu \alpha.E}\\
	\alternative{\Lambda X.E}
    \alternative{E\;\ell}\\
    \alternative{\text{ret}(e)}
    \alternative{\text{let}\; \text{ret}(x) := E_1 \;\text{in}\; E_2}\\
    \alternative{\text{send}\; E \;\text{to}\; \ell}
    \alternative{\text{receive from}\;  \ell}\\
    \alternative{\text{if}\; E \;\text{then}\; E_1 \;\text{else}\; E_2}\\
    \alternative{\text{choose}\; d \;\text{for}\;  \ell ; E}\\
    \alternative{\text{allow}\; \ell \;\text{choice}\; (d \Rightarrow E)^*}\\
    \alternative{\text{send tell}\; \rho \;\text{let}\; X := E_1 \;\text{in}\; E_2}\\
    \alternative{\text{receive}\; X \;\text{from}\; \ell \;\text{in}\; E}\\
	\alternative{\text{AmI}\; \ell \;\text{then}\; E_1 \;\text{else}\; E_2}

    \category[Systems]{\Pi}
    \alternative{L_1 \triangleright E_1 \;\|\; \ldots \;\|\; L_n \triangleright E_n}
\end{syntax}

\paragraph{Endpoint Projection}\;
\begin{mathparpagebreakable}
\begin{aligned}[t]
	\epp{\alpha}{L} &= \alpha\\
	\epp{\ell.e}{L} &=
		\begin{cases}
			\text{ret}(e) & L = \ell \\
			() & L \neq \ell
		\end{cases}\\
	\epp{C \overset{\ell_1}{\rightsquigarrow} \ell_2}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{send}\; \epp{C}{L} \;\text{to}\; \ell_2 & L = \ell_1 \neq \ell_2 \\
			\text{receive from}\;\ell_1 & L = \ell_2 \neq \ell_1\\
			() & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\ell.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2}{L} &= 
		\begin{cases}
			\text{if}\; \epp{C}{L} \;\text{then}\; \epp{C_1}{L} \;\text{else}\; \epp{C_2}{L} & L = \ell \\
			\epp{C_1}{L} \sqcup \epp{C_2}{L} & L \neq \ell
		\end{cases}\\
	\epp{\ell_1[d] \rightsquigarrow \ell_2; C}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{choose}\; d \;\text{for}\; \ell_2; \epp{C}{L} & L = \ell_1 \neq \ell_2 \\
			\text{allow}\; \ell_1 \;\text{choice}\; (d \Rightarrow \epp{C}{L}) & L = \ell_2 \neq \ell_1\\
			\epp{C}{L} & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\text{let}\; \ell.x := C_1 \;\text{in}\; C_2}{L} &= 
		\begin{cases}
			\text{let}\; \text{ret}(x) := \epp{C_1}{L} \;\text{in}\; \epp{C_2}{L} & L = \ell \\
			\epp{C_1}{L} ; \epp{C_2}{L} & L \neq \ell
		\end{cases}\\
	\epp{\lambda \alpha.C}{L} &= \lambda \alpha.\epp{C}{L}\\
	\epp{\mu \alpha.C}{L} &= \mu \alpha.\epp{C}{L}\\
	\epp{C_1\;C_2}{L} &= \epp{C_1}{L}\;\epp{C_2}{L}\\
	\epp{\Lambda X.C}{L} &= \Lambda X.\text{AmI}\; X \;\text{then}\; \epp{C[X \mapsto L]}{L} \;\text{else}\; \epp{C}{L}\\
	\epp{C\;\ell}{L} &= \epp{C}{L}\;\ell\\
	\epp{\ell.\text{tell}\; \rho_1 \; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2}{L} &= 
		\begin{cases}
			\text{send tell}\; (\rho_1 \cup \rho_2) \setminus \{\ell\} \;\text{let}\; X := \epp{C_1}{L} \;\text{in}\\ \text{AmI}\; X \;\text{then}\; \epp{C_2[X \mapsto L]}{L} \;\text{else}\; \epp{C_2}{L} & L = \ell\\
			\epp{C_1}{L} ; \text{receive}\; X \;\text{from}\; \ell \;\text{in}\;\\
			\text{AmI}\; X \;\text{then}\; \epp{C_2[X \mapsto L]}{L} \;\text{else}\; \epp{C_2}{L} & L \neq \ell, L \in \rho_1 \cup \rho_2\\
			\epp{C_1}{L} & L \neq \ell, L \notin \rho_1 \cup \rho_2
		\end{cases}
\end{aligned}
\end{mathparpagebreakable}


\section{Meeting Notes}
\paragraph{3/7/2024}
\subparagraph{Misc}
\begin{itemize}
	\item Local values don't seem to have an elimination form with current system
	\item Don't need to track blocking sets in reduction rules; can compute from redices
\end{itemize}

\subparagraph{Tell-do Concerns}
\begin{itemize}
	\item How do we know who to send the tell-do to, as it's using a local value?
	\item We need to statically compute an over-approximation of the set of possible recipients
	\item Idea: Have the local language compute the over-approximation, and have its soundness be an assumption for the deadlock freedom guarantees.
	\[
	\text{tell}\; x := C_1 \;\text{do}[S]\; C_2
	\]
	\item $S$ is a \emph{set} of locations that the message will be sent to
	\item Could just send to everyone, but this uses a closed-world assumption
	\item Weird example suggested by Ethan: Choreography where Alice continually discovers and adds new known locations, and at each point she randomly selects a person from this set to delegate something to. At each point the set is finite, but it will increase infinitely, and the size depends at which step you're at.
	\item Need to use implicit sends rather than explicit sends (might need to do alias analysis on the value of the local location otherwise!)
\end{itemize}

\paragraph{3/14/2024}
\subparagraph{Out-of-Order Execution}
With send operations in the form $C_1 \overset{\ell_1}{\rightsquigarrow} \ell_2$ it becomes difficult to tell when you can do out-of-order execution as you need to examine $C_1$; it could block more than just $\ell_1$. Moreover, you need to allow for reduction within the scope of a function/lambda abstraction in order to do so, as this is required to use the output of a send operation. You can \emph{probably} solve this problem through a meta-function, but the old syntax works fine and is just as general, so I will use it.

Solution: Revert send operations to the form $\ell_1.e \rightsquigarrow \ell_2.\alpha; C$. Now we can easily tell that $C$ can execute out-of-order when $\ell_1$ and $\ell_2$ are blocked.

Other solution: Use an in-order trace semantics for choreographies; function application comes easily. Then to deal with correctness use an equivalence relation on the traces allowing for re-ordering.

\subparagraph{Delegation}
For the tell-do binding, won't you need to send the chosen location to more than just the possible set of locations it can be anyways? For instance:
\begin{align*}
	&\text{tell}\; X \in \{W_1,W_2\} := D.e_1 \;\text{do}\\
	&X.e_2 \rightsquigarrow \alpha @ \text{Alice};\\
	&\text{let}\; \text{Alice}.x := \alpha \;\text{in}\\
	&\text{Alice}.e_3
\end{align*}
Alice needs to know which X was chosen as she needs to receive from them, even though she is not among $\{D,W_1,W_2\}$. Thus we need to know the set of all processes who may be involved.

OK, then just try and compute the involved processes statically! Problem: Higher order functions. Who is involved in the process $\lambda \alpha : \tau_1 \rightarrow \tau_2.C$? Well, because $\alpha$ is another choreography, it depends on who is involved in $\alpha$. Do what Alice or Bob does and annotate choreographic functions with a set of processes and allow for abstraction over them: $\text{IP}(\lambda \alpha : \tau_1 \rightarrow_\rho \tau_2.C) = \rho \cup \text{IP}(C)$. This complicates the type system but seems necessary if we want to allow for this form of delegation.
Solution:
\begin{align*}
	&\text{tell}_{\{\text{Alice}\}}\; X \in \{W_1,W_2\} := D.e_1 \;\text{do}\\
	&X.e_2 \rightsquigarrow \alpha @ \text{Alice};\\
	&\text{let}\; \text{Alice}.x := \alpha \;\text{in}\\
	&\text{Alice}.e_3
\end{align*}
Send $X$ to $\{Alice, W_1, W_2\}$. If someone tries to use $X$ inside the body and we didn't sent it to them, the endpoint projection will fail.

\paragraph{3/26/2024}
\subparagraph{Local Substitution}
Local substitution has to be defined to avoid capture of locations. For instance:
\begin{align*}
&(\Lambda \ell. \;\text{let}\; \ell.x = \ell.2 \;\text{in}\\
&\;\text{let}\; L.x = L.3 \;\text{in}\\
&\;\text{let}\; \ell.y = L.x \rightsquigarrow \ell \;\text{in}\\
&\;\ell.(x + y))\; L
\end{align*}
When you substitute $L$ in for $\ell$ naively, you capture $\ell.x$ in the final expression and rebind it to $L.x$, and end up computing $L.6$ instead of $L.5$.


\paragraph{5/16/2024}
\subparagraph{Current Results}
\begin{itemize}
	\item Definition of type system and choreographies with abstraction over locations, local types, and choreographic types, and ability to send and use locations and local types
	\item Simplification and generalization of some of Pirouette's types and choreographies (e.g. sending and if-then-else constructs)
	\item Syntactic definitions like renaming and substitution and preservation of typing (non-trivial because of location substitution)
	\item Definition of in-order semantics
\end{itemize}
\subparagraph{Results Wanted Before Submission}
\begin{itemize}
	\item Endpoint projection preserves semantics
	\item Simple algebraic types
\end{itemize}
\subparagraph{Final Results}
\begin{itemize}
	\item (Co)Recursive types
	\item Track involved processes in type system
	\item Equivalence of old-style (explicit local expressions) and new-style (implicit local expressions) syntax
\end{itemize}

\subparagraph{Story/Reasoning}
\begin{itemize}
	\item Don't want to view as just "Why not do PolyChor again?"
	\item EXAMPLES! (Example with delegation via location sending. Encode examples from PolyChor paper)
	\item Send locations and local types: Unclear if it's even possible in PolyChor style
	\item System F versus System F$\omega$. We used a simpler type system for an analogous (and in some places more general) result. As well, it is(was!) an open question whether location polymorphism is possible in a choreographic language using System F. Maybe not possible in PolyChor style, but possible with Pirouette style (advantage of Pirouette style)
	\item Unclear how much expressivity is lost due to lack of "explicit" delegation. We can show at the very least with examples that we can do delegation "implicitly" by sending locations
\end{itemize}

\subparagraph{Generic Syntax Library} Idea: Define the syntax (and possibly type system) of your language, and the library gives you the "standard" metafunctions (e.g. variable renaming and substitution) along with associated proofs. I have seen three classes of generic syntax libraries:
\begin{itemize}
	\item \emph{Algebraic}: Define the type for syntax "on your own" within your ITP, and prove it satisfies some algebraic property (e.g. it is a decorated-traversable monad). The library defines the metafunctions and related proofs universally for each type satisfying the algebraic property as a function within the ITP. It may require some non-trivial proofs to show the algebraic property is satisfied.
	\item \emph{Syntactic}: Define your syntax by an algebraic signature (e.g. as in universal algebra or datatype-generic programming) within your ITP, and the library defines the type for syntax, the metafunctions, and related proofs universally for each signature as a function within the ITP. A little bit less general than the algebraic approach, but requires a lot less effort.
	\item \emph{Extensional}: Define your syntax by an algebraic signature \emph{outside} of your ITP (e.g. with a text file defining a grammar) that an executable will parse and process. The executable will (hopefully!) give you the type for syntax, the metafunctions, and related proofs in separate files that can be used by your ITP. Similar to the syntactic approach, but there is usually no guarantee that the process will succeed and the ITP files will compile even with a well-formed grammar. (autosubst)
\end{itemize}
My library takes the syntactic approach as it is time-saving over the algebraic approach, and end-to-end verified/complete unlike the extensional approach.

\subparagraph{Binding Signatures} To define a type theory/language, we need to define explicitly what a \emph{signature} means. We start with a plain universal algebra signature, and generalize to what my library uses.\\

In universal algebra, a signature is just a set of function symbols of various arities. Explicitly, the data of a signature $\Sigma$ consists of:
\begin{itemize}
	\item the function symbols $\mathcal{F} : \text{Type}$, and
	\item a function $\text{ar} : \mathcal{F} \rightarrow \mathbb{N}$ defining their arities.
\end{itemize}
The algebra/language $\text{Alg}(\Sigma,X)$ of this signature with variables from a set $X$ is the least set containing $X$ and $f(e_1,\ldots,e_n)$ for $f \in \mathcal{F}$, $\text{ar}(f) = n$, and $e_1,\ldots,e_n \in \text{Alg}(\Sigma,X)$. \\

This system is in essence unityped, so we can first generalize to allow for expressions to have a specified type. Now a signature $\Sigma$ consists of the data
\begin{itemize}
	\item $T : \text{Type}$ specifying the types,
	\item $\mathcal{F} : \text{Type}$ specifying the function symbols,
	\item $\text{ar} : \mathcal{F} \rightarrow T^*$ defining function arities, and
	\item $\text{ty} : \mathcal{F} \rightarrow T$ defining function types.
\end{itemize}
Here the arity metafunction $\text{ar}$ now specifies the type of each argument as a list of types $T^*$, and the function typing metafunction $\text{ty}$ defines the type of each function symbol. We could equivalently define a family of function symbols $\mathcal{F}_t$ for each $t : T$. The algebra/language $\text{Alg}(\Sigma,\Gamma,t)$ of a specified type $t : T$ of this signature with variables from a context $\Gamma$ which maps variables to types is the least set containing $x$ for each $x \in \Gamma_t$, and $f(e_1,\ldots,e_n)$ for $f \in \mathcal{F}$, $\text{ar}(f) = (t_1,\ldots,t_n)$, $\text{ty}(f) = t$, and $e_i \in \text{Alg}(\Sigma,\Gamma,t_i)$.\\

This scheme works great for universal algebra and model theory, but it's missing the key component needed in programming languages; variable binding. To generalize, we will allow for each function symbol to additionally specify which new variables will be bound in each sub-expression, and the type of these variables. The data of a (second-order) \emph{binding signature} $\Sigma$ consists of
\begin{itemize}
	\item the types $T : \text{Type}$,
	\item the function symbols $\mathcal{F} : \text{Type}$,
	\item the bound variable types and sub-expression types $\text{ar} : \mathcal{F} \rightarrow (T^* \times T)^*$, and
	\item the function types $\text{ty} : \mathcal{F} \rightarrow T$.
\end{itemize}
The "arity" function $\text{ar}$ now does double-duty by defining, for each sub-expression, the number and type of each variable that will be bound inside of the sub-expression as well as the expected type of that sub-expression. We could equivalently write this as multiple families of functions, but we use the given definition to avoid the use of dependent functions. The algebra $\text{Alg}(\Sigma,\Gamma,t)$ of a type $t : T$ of this signature with variables from context $\Gamma$ is the least set containing $x$ for each $x \in \Gamma_t$, and $f(e_1,\ldots,e_n)$ for $f \in \mathcal{F}$, $\text{ar}(f) = (\Gamma_1;t_1,\ldots,\Gamma_n;t_n)$, $\text{ty}(f) = t$, and $e_i \in \text{Alg}(\Sigma,\Gamma+\Gamma_i,t_i)$. Note that we have expanded the context of each sub-expression $e_i$ by adding the bound variables in context $\Gamma_i$, so the relevant variables are elements of the algebra used in the sub-expression. We can equivalently see the algebra as being isomorphic to the following grammar and typing judgments:
\begin{syntax}
	\categoryFromSet[]{f}{\mathcal{F}}
	\category[]{e}
	\alternative{x}
	\alternative{f(e_1,\ldots,e_n)}
\end{syntax}
\begin{mathparpagebreakable}
	\infer[]{x : t \in \Gamma}
	{\Gamma \vdash x : t} \and
	
	\infer[]{\text{ar}(f) = (\Gamma_1;t_1,\ldots,\Gamma_n;t_n)\\
		\text{ty}(f) = t\\
		\Gamma + \Gamma_1 \vdash e_1 : t_1\\
		\ldots\\
		\Gamma + \Gamma_n \vdash e_n : t_n}
	{\Gamma \vdash f(e_1,\ldots,e_n) : t} \and
\end{mathparpagebreakable}
That is, $\text{Alg}(\Sigma,\Gamma,t) \cong \{e \mid \Gamma \vdash e : t\}$. This just equates an inherently-typed representation with a non-inherently-typed representation.

\subparagraph{STLC + Algebraic Types} Suppose $B$ is any set of base types. The signature for STLC with product and sum types is as follows.
\begin{verbatim}
B : Type

data Ty : Type where
  Base : B -> Ty
  Arrow : Ty -> Ty -> Ty
  Prod : Ty -> Ty -> Ty
  Sum : Ty -> Ty -> Ty
  
data F : Type where
  lam : (t1 t2 : Ty) -> F
  app : (t1 t2 : Ty) -> F
  
  pair : (t1 t2 : Ty) -> F
  rec : (t1 t2 s : Ty) -> F
  
  inl : (t1 t2 : Ty) -> F
  inr : (t1 t2 : Ty) -> F
  case : (t1 t2 s : Ty) -> F
  
ty (lam t1 t2) = Arrow t1 t2
ty (app t1 t2) = t2
ty (pair t1 t2) = Prod t1 t2
ty (rec t1 t2 s) = s
ty (inl t1 t2) = Sum t1 t2
ty (inr t1 t2) = Sum t1 t2
ty (case t1 t2 s) = s

ar (lam t1 t2) = (t1 :: [] |- t2) :: []
ar (app t1 t2) =
  ([] |- Arrow t1 t2) ::
  ([] |- t1) ::
  []
ar (pair t1 t2) =
  ([] |- t1) ::
  ([] |- t2) ::
  []
ar (rec t1 t2 s) =
  ([] |- Arrow t1 (Arrow t2 s)) ::
  ([] |- Prod t1 t2) ::
  []
ar (inl t1 t2) = ([] |- t1) :: []
ar (inr t1 t2) = ([] |- t2) :: []
ar (case t1 t2 s) =
  ([] |- Arrow t1 s) ::
  ([] |- Arrow t2 s) ::
  ([] |- Sum t1 t2) ::
  []
\end{verbatim}

\subparagraph{Security Lattice - Extra Judgments} "But wait", says Ethan, "what if I need an extra condition like $\ell \sqsubseteq \tau$ in my typing judgments?". This is fine; in any reasonable ITP you can just pack it into the definition of your function symbols using an extra propositional argument.
\begin{verbatim}
Label : Type
Ty : Type
prot : Label -> Ty -> Type

data F : Type where
  bind : (t1 t2 : Ty) (L : Label) -> prot L t1 -> F
\end{verbatim}
"But wait", says Ethan, "what if I need a program counter label?". This is, unfortunately, less clean, and we have to be more creative, but it is definitely possible. Because we're not allowed to augment the context, we have to shove everything extra into the types themselves. Essentially, for every extra piece of information we want the context to have, put it into the type itself (and possibly also the associated function symbols).
\begin{verbatim}		
Label : Type
Ty : Type
Unit : Ty
Arrow : Ty -> Ty -> Label -> Ty
Says : Label -> Ty -> Ty
_<=_ : Label -> Label -> Type
prot : Label -> Ty -> Type
join : Label -> Label -> Label

TyPC : Type
TyPC = Ty x Maybe Label
-- For bound variables x:t use (t , nothing)
-- For judgments Gamma;pc |- t use inr (t , just pc)

data F : Type where
  -- Explicit conversion from bound variables C[x] = t to
  -- the judgment C;pc |- x : t
  conv : (t : T) (pc : Label) -> F
  tt : (pc : Label) -> F
  lam : (t1 t2 : T) (pc1 pc2 : Label) -> F
  app : (t1 t2 : T) (pc1 pc2 : Label) -> pc2 <= pc1 ->  F
  bind : (t1 t2 : T) (L : Label) (pc : Label) -> prot L t1 -> F

-- Note 1: We have no intro. rule for the type (t , nothing)
ty : F -> TyPC
ty (conv t pc) = (t , just pc)
ty (tt pc) = (Unit , just pc)
ty (lam t1 t2 pc1 pc2) = (Arrow t1 t2 pc1 , just pc2)
ty (app t1 t2 pc1 pc2 _) = (t2 , just pc2)
ty (bind t1 t2 L pc _) = (t2 , just pc)

-- Note 2: We only bind things of type (t , nothing)
ar : F -> List (List TyPC x TyPC)
-- By (1) and (2), the argument to conv is necessarily a variable,
-- so it acts the same as the judgment C1,x:t,C2;pc |- x : t
ar (conv t pc) = ([] |- (t , nothing)) :: []
ar (tt pc) = []
ar (lam t1 t2 pc1 pc2) = ((t1 , nothing) :: [] |- (t2 , just pc1)) :: []
ar (app t1 t2 pc1 pc2 _) =
  ([] |- (Arrow t1 t2 pc1 , just pc2)) ::
  ([] |- (t1 , just pc2)) :: []
ar (bind t1 t2 L pc _) =
  ([] |- (Says L t1 , just pc)) ::
  ((t1 , nothing) :: [] |- (t2 , just (join pc L))) :: []
\end{verbatim}

\paragraph{5/30/2024}
\subparagraph{Paper Outline}
\begin{enumerate}
	\item Introduction
	\begin{enumerate}
		\item Overview of distributed programming language goals and paradigms. Deadlocks, concurrency, session types, choreographies. History: Ad-hoc local programs $\Rightarrow$ session types $\Rightarrow$ choreographies $\Rightarrow$ higher-order choreographies $\Rightarrow$ process-polymorphic choreographies. Each step increases power, expressivity, and usability.
		\item Current choreographic languages which support out-of-order execution (Pirouette) are insufficient
		(Spend more time describing choreographies than justifying process polymorphism)
		\begin{enumerate}
			\item No process polymorphism
			\item Cannot reflect local representations
			\item No delegation ability (Don't put in introduction, means something different to session-type community that's closer to what PolyChor does)
		\end{enumerate}
		\item Current choreographic languages which support process polymorphism (PolyChor$\lambda$) are insufficient
			\begin{enumerate}
				\item No support for out-of-order execution (Why? 1. The authors didn't bother 2. It would be too difficult 3. It's mathematically impossible. We want to convince the reader that at least 1 and 2 are true. Note that a whole other paper was needed to develop out-of-order execution for PolyChor. Probably put in related works section instead)
				\item Cannot reflect local representations of processes and types back into the choreographic language (you can technically send them but you just can't use them globally)
				\item Uses System F$\omega$ which complicates type checking and could be considered a usability downside. Also the types are quite complex in general, which somewhat defeats the purpose of using choreographic types over session types.
				\item Does not support arbitrary local languages
			\end{enumerate}
		\item Start with an example, and say that current languages can't support it. Don't need to get into heavy details in the introduction. Just a short and informal explanation of why it's impossible (Don't obscure new idea with too much related work)
		\item Hook/example idea: middleman service. Two parties want to exchange items of arbitrary types (could be money or bartering) while remaining anonymous to each other. The middleman will act as an intermediary to determine if the two parties agree to the exchange, and to actually perform the exchange. The items can be arbitrary; the middleman must support arbitrary representations of items. I still cannot think of an example which effectively shows sending and reflection of types or locations.
\begin{verbatim}
doExchange
  :: (A B : Type) (LA LB D : Loc).
     A @ LA
  -> (B @ LA -> Bool @ LA)
  -> B @ LB
  -> (A @ LB -> Bool @ LB)
  -> ((L1 L2 : Loc).A @ L1 -> ())
  -> ((L1 L2 : Loc).B @ L1 -> ())
  -> ()
doExchange A B LA LB D itemA acceptB itemB acceptA transferA transferB =
  let D.a1 := acceptB (itemB --> D --> LA) --> D
      D.a2 := acceptA (itemA --> D --> LB) --> D
  in if D.(a1 && a2)
       then D[L] --> A;
            D[L] --> B;
            transferA [LA] [D] itemA;
            transferB [LB] [D] itemB;
            transferA [D] [LB] (itemA --> D);
            transferB [D] [LA] (itemB --> D)
       else D[R] --> A;
            D[R] --> B;
            ()
            
bookName :: String @ Seller
bookName = Seller."The Old Man and the Sea"

acceptPrice :: Int @ Seller -> Bool @ Seller
acceptPrice p = let Seller.x := p in Seller.(x >= 10)

offerPrice :: Int @ Buyer
offerPrice = Buyer.12

acceptBook :: String @ Buyer -> Bool @ Buyer
acceptBook b = let Buyer.x := b in Buyer.(x == "The Old Man and the Sea")

giveBook  :: (L1 L2 : Loc).String @ L1 -> ()
giveMoney :: (L1 L2 : Loc).Int @ L11   -> ()

doExchange [String] [Int] [Seller] [Buyer] [Delegate]
           bookName   acceptPrice
           offerPrice acceptBook
           giveBook   giveMoney
  :: ()
\end{verbatim}
	\item Example: Centralized thread pool (either thread pool manager or load balancer?). Client, pool manager, and worker threads. Client sends request to manager, manager looks up worker and sends name to client, client can use worker thread. Manager has a queue of threads as its state. We can say that you could theoretically add a stateful semantics, but it's difficult because of proof mechanization. (Obviously implementable but not actually implemented features won't get any complaints. We \emph{believe} it would not impact the veracity of the theorems, but we didn't add it to the core calculus)
\begin{verbatim}

\end{verbatim}
	\end{enumerate}
	\item Assumptions/Model
	\begin{enumerate}
		\item Locations, network/communication
		\item Local language
		\item Representations of types and locations in local language
	\end{enumerate}
		
	\item Language
	\begin{enumerate}
		\item Syntax
		\item Type system
		\item Operational semantics
		\item Important properties
	\end{enumerate}
		
	\item Endpoint Projection
	\begin{enumerate}
		\item Control language: Syntax and semantics
		\item Endpoint projection definition
		\item Important properties
	\end{enumerate}
	
	\item Agda Code Notes
	\begin{enumerate}
		\item \emph{Very} concise explanation of representations of language definitions, syntax, and typing
		\item Explanation of genericity over local languages
	\end{enumerate}
	
	\item Related Work
\end{enumerate}

\subparagraph{Questions/Design Decisions}
\begin{enumerate}
	\item Use Haskell-like syntax (i.e. plain text) for examples, or $\lambda$-calculus/actual \LaTeX\ style? I'm a fan of Haskell-style for readability (especially so complex macros and 2D syntax can be avoided), but this is a POPL "core-calculus" paper so $\lambda$-calculus style may be more appropriate.
	\item Having trouble thinking of examples which effectively use sending of types or locations on the network. Problem: Ad-hoc vs parametric polymorphism. When type \emph{representations} are in the local language they can be manipulated as regular values and inspected, but when they are bound at the type level they must be handled parametrically. Only way around this is full dependency.
\end{enumerate}

\subparagraph{Overall Strategy}
\begin{itemize}
	\item Not many possible reviewers who are explicitly knowledgeable about choreographies, at most just the general ideas of distributed languages \& concurrency
	\item May want to create an example to appeal to this audience: Bookseller/traditional choreography examples may not be appealing
	\item Also highlight the "pure" type theoretic advancements for this audience and a general POPL audience, e.g. using System F instead of System F$\omega$
	\item Possible reviewers: Philip Wadler, Garrett Morris, Justin Hsu
\end{itemize}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-master: t
%%% End: