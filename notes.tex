\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[letterpaper, margin=1in, bottom=1in]{geometry}
\usepackage[authoryear,sort,square]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bbold}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{latex-pl-syntax/pl-syntax}
\usepackage{xspace}
\usepackage{suffix}
\usepackage{turnstile}
\usepackage{multicol}

\usepackage[hidelinks]{hyperref}

% Notes
\newcommand{\uncertain}[1]{{\color{red} #1}\xspace}
\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\newcommenter{\akh}{purple}{AKH}

% AMSTHM Setup
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}
\newtheorem{inv}{Invariant}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

% Macros

%% Assumptions on expressions
\newcommand{\bool}{\mathbbm{2}}
\newcommand{\ett}{\textsf{true}}
\newcommand{\eff}{\textsf{false}}

%% Evaluation
\newcommand{\To}{\Rightarrow}

%% Substitution
\newcommand{\subst}[3]{#1~[#2 \mapsto #3]}

%% Equivalence
\newcommand{\cleq}{\preceq}
\newcommand{\ceq}{\equiv}

%% Choreography Language
\newcommand{\own}[2]{#1.#2}
\newcommand{\cdone}{\mathbb{0}}
\newcommand{\send}[3][]{#2\nolinebreak \mathrel{\xrightarrow{#1}}\nolinebreak #3}
\newcommand{\cif}[3]{\textsf{if}~#1 \mathrel{\textsf{then}}\nolinebreak #2 \mathrel{\textsf{else}}\nolinebreak #3}
\newcommand{\clet}[2]{\textsf{let}~#1\nolinebreak =\nolinebreak #2 \mathrel{\textsf{in}}}
\newcommand{\copen}[2]{\textsf{open}_{#1}~#2}
\newcommand{\idchan}{\textsf{id\_chan}}
\newcommand{\match}{\ensuremath{\mathsf{match}\xspace}}
\newcommand{\with}{\ensuremath{\mathsf{with}}\xspace}
\newcommand{\End}{\ensuremath{\mathsf{end}}\xspace}
\newcommand{\inl}{\ensuremath{\mathsf{inl}}\xspace}
\newcommand{\inr}{\ensuremath{\mathsf{inr}}\xspace}

\newcommand{\matchsum}[5]{%
  \begin{array}{l}%
    \match~#1~\with\\%
    |~\inl(#2) \mathrel{\Rightarrow} #3\\%
    |~\inr(#4) \mathrel{\Rightarrow} #5\\%
    \End%
  \end{array}%
}
\WithSuffix\newcommand\matchsum*[5]{\match~#1~\with\quad|\, \inl(#2)\mathrel{\Rightarrow}#3\quad|\, \inr(#4) \mathrel{\Rightarrow} #5 \quad\End}
\newcommand{\matchpair}[4]{%
  \begin{array}{l}%
    \match~#1~\with\\%
    |~(#2,~#3) \mathrel{\Rightarrow} #4\\%
    \End%
  \end{array}%
}
\WithSuffix\newcommand\matchpair*[4]{\match~#1~\with\quad|\, (#2,#3)\mathrel{\Rightarrow} #4 \quad\End}


\newcommand{\eppctxt}[2]{\llparenthesis #1 \rrparenthesis_{#2}}

%% IR

   

%% Type Judgments
\newcommand{\proves}{\vdash}
%\newcommand{\proves}[1][]{\sststile{}{#1}}

%% BL_S Commands
\newcommand{\says}{\ensuremath{\mathrel{\textsf{says}}}}
\newcommand{\claims}{\ensuremath{\mathrel{\textsf{claims}}}}

%% Translations
\newcommand{\transb}[1]{\left\llbracket #1 \right\rrbracket}

\newcommand{\prep}[4]{\mathsf{prepare}_{#1 \xrightarrow{#2} #3}\left(#4\right)}

\bibliographystyle{plainnat}

\begin{document}


\section{Overview}
\label{sec:overview}

Modal logic has been used in the security world for reasoning about distributed systems--in the form of authorization logic--for a long time.
Other work, such as the work on ML5~\citep{MurphyCH07}, has used modal logic as the basis of type systems for distributed programs.

These two threads of research take very different views of how modal logic models distributed programming.
Authorization logic~\citep{HirschACAT20-TR,HirschC13,GenoveseGR12,SchneiderWS11,GenoveseGGP11,GargP10,GargA08,Garg08,Abadi08,GargP06,Abadi03} uses multi-modal logic, so that each principal is represented as a modality, traditionally written "p says."
Since each principal is a reasoner, a propositions-as-types point-of-view regards each principal as a center of computation, such as a thread, processor, or computer in a distributed system.
ML5~\citep{MurphyCH07} and related works~\citep{JiaW04,AhmedJW03}, in contrast, use a hybrid logic form of S5, a standard modal logic.
This allows them to model each center of computation as a world in a Kripke semantics for S5, and to model communication via a monotonicity condition on worlds.

While these threads of research differ significantly in their logical form, they have a similar view of distributed programming.
In both, we reason about distributed programs from outside of the system and direct communication between participants.
This creates a programming style similar to that used for describing distributed protocols e.g., in the cryptography literature.
This in contrast to process calculi like $\pi$-calculus, CCS, and join calculus, which write programs as parallel compositions of code for each participant.

In the world of calculi for distributed programming, choreographies~\citep{Cruz-FilipeM17,Cruz-FilipeMP18,CarboneMS14,Montesi13,ZongyanXCH07,CarboneM13} take this same top-down view of distributed programming.
Choreographies not only allow a programmer to write programs in a top-down manner, but then give the ability to \emph{project} process calculus code for each participant.
This is referred to as \emph{endpoint projection}.
This process calculus code is guaranteed by construction to be deadlock free.

Choreographies are designed to lift some \emph{expressions}---which are purely local and which return values---to a process by describing how processes share and use values calculated from those expressions.
This tells us something about the limits of deadlock-freedom: if expressions can get stuck, then so can choreographies that use those expressions.
Previous works on choreographies either provide an explicit, terminating, expression language~\citep{Cruz-FilipeM17,CarboneMS14,ZongyanXCH07}; assume that expressions terminate~\citep{Cruz-FilipeMP18}; or provide no guarantee of progress~\citep{CarboneM13}.

Usually, progress is guaranteed by a type system.
While type systems for choreographies have been studied before~\citep{CarboneM13,CarboneMS14}, these use \emph{session types}, which constrain a process to ensure that it follows the correct pattern of communication.
\akh{I'm pretty sure there's more type systems for choreographies papers.}
While this has been used by \citet{CarboneM13}, 

\section{A Multimodal Type System for Choreographies}
\label{sec:mult-type-syst-chor}

\subsection{Expressions}
\label{sec:expressions-mmc}

I assume we have an expression language with a typing system.
We assume that typing judgments for that language have the form $\Gamma \proves e : \tau$.

\subsection{Choreographies}
\label{sec:choreographies-mmc}

\paragraph{Syntax}
\begin{syntax}
  \abstractCategory[Choreography Variables]{X,Y,Z,\ldots}
  \abstractCategory[Thread Names]{p,q,r,\ldots}
  \category[Choreographies]{C}
    \alternative{p.e}
    \alternative{X}
    \alternative{\send{p.e}{q.x};~C}
    \alternative{\cif{p.e}{C_1}{C_2}}
    \alternative{\clet{X}{C_1}{C_2}}
\end{syntax}
  
\paragraph{Context Projection}
\noindent\begin{align*}
  \eppctxt{\cdot}{p} &= \cdot\\
  \eppctxt{x : p.\tau, \Gamma}{p} &= x : \tau, \eppctxt{\Gamma}{p}\\
  \eppctxt{x : q.\tau, \Gamma}{p} &= \eppctxt{\Gamma}{p}~\textrm{(where $p \neq q$)}
\end{align*}

\paragraph{Type System}
\noindent\begin{mathpar}
  \infer{\eppctxt{\Gamma}{p} \proves e : \tau }{\Gamma; \Delta \proves p.e : p.\tau}\and
  \infer{ }{\Gamma; \Delta, X : p.\tau \proves X : p.\tau} \and
  \infer{\eppctxt{\Gamma}{p} \proves e : \tau\\ \Gamma, x : q.\tau; \Delta \proves C : r.\sigma}{\Gamma; \Delta \proves \send{p.e}{q.x}; C : r.\sigma}\and
  \infer{\eppctxt{\Gamma}{p} \proves e : \bool\\ \Gamma; \Delta \proves C_1 : q.\tau\\ \Gamma; \Delta \proves C_2 : q.\tau}{\Gamma; \Delta \proves \cif{p.e}{C_1}{C_2} : q.\tau} \and
  \infer{\Gamma; \Delta, X : p.\tau \proves C_1 : p.\tau \\ \Gamma; \Delta, X : p.\tau \proves C_2 : q.\sigma}{\Gamma; \Delta \proves \clet{X}{C_1}{C_2} : q.\sigma}
\end{mathpar}

\paragraph{Substitution}

\noindent Substitution on expressions is given.

\begin{align*}
  \subst{p.e}{X}{C} &= p.e \\
  \subst{X}{X}{C} &= X \\
  \subst{Y}{X}{C} &= Y~\text{(assuming that $X \neq Y$)} \\
  \subst{(\send{\own{p}{e}}{\own{q}{x}};~C_1)}{X}{C_2} &= \send{\own{p}{e}}{\own{q}{x}};~(\subst{C_1}{X}{C_2}) \\
  \subst{(\cif{\own{p}{e}}{C_1}{C_2})}{X}{C_3} &= \cif{\own{p}{e}}{(\subst{C_1}{X}{C_3})}{(\subst{C_2}{X}{C_3})}\\
  \subst{(\clet{X}{C_1}{C_2})}{X}{C_3} &= \clet{X}{C_1}{C_2}\\
  \subst{(\clet{X}{C_1}{C_2})}{Y}{C_3} &= \clet{X}{(\subst{C_1}{Y}{C_3})}{(\subst{C_2}{Y}{C_3})}
\end{align*}

\begin{align*}
  \subst{p.e_1}{\own{p}{x}}{e_2} &= p.(\subst{e_1}{x}{e_2})\\
  \subst{p.e_1}{\own{q}{x}}{e_2} &= p.e_1~\textrm{(where $p \neq q$)}\\
  \subst{X}{\own{p}{x}}{e} &= X\\
  \subst{(\send{\own{p}{e_1}}{\own{p}{x}}; C)}{\own{p}{x}}{e_2} &= \send{\own{p}{(\subst{e_1}{x}{e_2})}}{\own{q}{x}}; C\\
  \subst{(\send{\own{p}{e_1}}{\own{q}{x}}; C)}{\own{p}{y}}{e_2} &= \send{\own{p}{(\subst{e_1}{y}{e_2})}}{\own{q}{x}}; (\subst{C}{\own{p}{y}}{e_2})\\
  \subst{(\send{\own{p}{e_1}}{\own{q}{x}}; C)}{\own{q}{x}}{e_2} &= \send{\own{p}{e_1}}{\own{q}{x}}; C\\
  \subst{(\send{\own{p}{e_1}}{\own{q}{x}}; C)}{\own{r}{y}}{e_2} &= \send{\own{p}{e_1}}{\own{q}{x}}; (\subst{C}{\own{r}{y}}{e_2})\\
  \subst{(\cif{\own{p}{e_1}}{C_1}{C_2})}{\own{p}{x}}{e_2} &= \cif{\own{p}{(\subst{e_1}{x}{e_2})}}{(\subst{C_1}{\own{p}{x}}{e_2})}{(\subst{C_2}{\own{p}{x}}{e_2})}\\
  \subst{(\cif{\own{p}{e_1}}{C_1}{C_2})}{\own{q}{x}}{e_2} &= \cif{\own{p}{e_1}}{(\subst{C_1}{\own{q}{x}}{e_2})}{(\subst{C_2}{\own{q}{x}}{e_2})}
\end{align*}

\paragraph{Equivalence}
\noindent\begin{mathpar}
  \infer{ }{C \ceq C} \and \infer{C_1 \ceq C_2}{C_2 \ceq C_1} \and \infer{C_1 \ceq C_2 \\ C_2 \ceq C_3}{C_1 \ceq C_3} \\
  \infer{C_1 \ceq C_2}{\send{\own{p}{e}}{\own{q}{x}}; C_1 \ceq \send{\own{p}{e}}{\own{q}{x}}; C_2} \and
  \infer{C_{11} \ceq C_{21}\\ C_{12} \ceq C_{22}}{\cif{\own{p}{e_1}}{C_{11}}{C_{12}} \ceq \cif{\own{p}{e_1}}{C_{21}}{C_{22}}} \and
  \infer{C_{11} \ceq C_{21}\\ C_{12} \ceq C_{22}}{\clet{X}{C_{11}}{C_{12}} \ceq \clet{X}{C_{21}}{C_{22}}} \\
  \infer{p \neq r\\ q \neq r\\ p \neq s\\ q \neq s}{\send{\own{p}{e_1}}{\own{q}{x}}; \send{\own{r}{e_2}}{\own{s}{y}}; C \ceq \send{\own{r}{e_2}}{\own{s}{y}}; \send{\own{p}{e_1}}{\own{q}{x}}; C} \and
  \infer{p \neq q\\ p \neq r}{\cif{\own{p}{e_1}}{\send{\own{q}{e_2}}{\own{r}{x}}; C_1}{\send{\own{q}{e_2}}{\own{r}{x}}; C_2} \ceq \send{\own{q}{e_2}}{\own{r}{x}}; \cif{\own{p}{e_1}}{C_1}{C_2}} \and
  \infer{p \neq q }{\cif{\own{p}{e_1}}{(\cif{\own{q}{e_2}}{C_1}{C_2})}{\cif{(\own{q}{e_2}}{C_3}{C_4})} \ceq \cif{\own{q}{e_2}}{(\cif{\own{p}{e_1}}{C_1}{C_3})}{(\cif{\own{p}{e_2}}{C_2}{C_4})}} \and
\end{mathpar}

\begin{thm}[Equivalence Preserves Typing]
  \label{thm:equiv-pres-types}
  If $\Gamma \proves C_1 : p.\tau$ and $C_1 \ceq C_2$, then $\Gamma \proves C_2 : p.\tau$
\end{thm}
\begin{proof}
  Proven in Coq.
\end{proof}

\begin{thm}[Equivalence is Stable under Substitution]
  \label{thm:equiv-stable-subst}
  If $C_1 \ceq C_2$, then $\subst{C_1}{\own{p}{x}}{e} \ceq \subst{C_2}{\own{p}{x}}{e}$ and $\subst{C_1}{X}{C} \ceq \subst{C_2}{X}{C}$.
\end{thm}
\begin{proof}
  Proven in Coq.
\end{proof}

\paragraph{Operational Semantics}


\subparagraph{Standard Presentation}
\noindent\begin{mathpar}
  \infer{e_1 \To e_2}{p.e_1 \To p.e_2} \and
  \infer{e_1 \To e_2}{\send{\own{p}{e_1}}{\own{q}{x}};~C \To \send{\own{p}{e_2}}{\own{q}{x}};~C} \and
  \infer{}{\send{\own{p}{v}}{\own{q}{x}}; C \Rightarrow \subst{C}{\own{q}{x}}{v}} \and
  \infer{e_1 \Rightarrow e_2}{\cif{\own{p}{e_1}}{C_2}{C_3} \To \cif{\own{p}{e_2}}{C_2}{C_3}} \and
  \infer{}{\cif{\own{p}{\ett}}{C_1}{C_2} \To C_1} \and
  \infer{}{\cif{\own{p}{\eff}}{C_1}{C_2} \To C_1} \and
  \infer{}{\clet{X}{C_1}{C_2} \To \subst{C_2}{X}{\clet{X}{C_1}{C_1}}} \and
  \infer{C_1 \ceq C_1'\\ C_1' \To C_2'\\ C_2' \ceq C_2}{C_1 \To C_2}
\end{mathpar}

This is the standard presentation.
However, it turns out to be very difficult to work with, because the equivalence breaks induction.
We might hope to make the last rule admissible, getting around this.
However, the last rule allows you to ``reach under'' the current top-level construct to allow steps from other threads to be interleaved.

\subparagraph{Presentation with Better Induction Principle}
In order to get around this, we present the operational semantics differently.
There are two difficulties here: only allowing operations from other threads, and ensuring that threads that are implicitly blocked from an if statement do not compute.
To see what goes wrong, consider the following two (non) reductions:
\noindent\begin{mathpar}
  \infer{e_2 \To e_3}{\send{\own{p}{e_1}}{\own{q}{x}}; \send{\own{p}{e_2}}{\own{r}{y}}; C \To \send{\own{p}{e_1}}{\own{q}{x}}; \send{\own{p}{e_3}}{\own{r}{y}}} \and
  \infer{e_2 \To e_4}{\cif{\own{p}{e_1}}{\send{\own{q}{e_2}}{\own{r}{x}}; C_1}{\send{\own{q}{e_3}}{\own{s}{y}}; C_2} \To \cif{\own{p}{e_1}}{\send{\own{q}{e_4}}{\own{r}{x}}; C_1}{\send{\own{q}{e_3}}{\own{s}{y}}; C_2}}
\end{mathpar}
In the first, $p$ is a single thread which does work on $e_2$, even though that thread is currently working on sending $e_1$ to $q$.
In the second, $q$ cannot know which of the two messages it is going to send, and so it should not be able to do work on either side.
(Intuitively, it is waiting for a message from $p$ to know which action to take.
We make that intuition explicit in the translation to $\pi$-calculus.)

To take care of the first problem, we annotate the operational semantics with a set of principals~$B$ which are currently blocked (and therefore cannot take action).
However, this is not enough in the second case, since $q$ is implicitly blocked by a decision.
In order to take care of this, we also annotate the operational semantics with a \emph{redex}, ensuring that we operate on the same expression, in the same place, on the same thread in both sides of the match statement.
This, combined with the set of blocked principals, is enough to ensure that implicitly-blocked threads do not progress.

This leads to the following operational semantics:

\begin{syntax}
  \category[Redeces]{R}
    \alternative{\text{Done}\, p\, e_1\, e_2}
    \alternative{\text{SendE}\, p\, e_1\, e_2\,q}
    \alternative{\text{SendV}\, p\, v\,q}
    \alternative{\text{IfE}\, p\, e_1\, e_2}
    \alternative{\text{IfTT}\, p}
    \alternative{\text{IfFF}\, p}
    \alternative{\text{Def}}
\end{syntax}

\noindent\begin{mathpar}
  \infer{e_1 \To e_2} {p.e_1 \xRightarrow{\text{Done}\,p\,e_1\,e_2,~\varnothing} p.e_2} \and
  \infer{p \notin B\\ q \notin B\\ e_1 \To e_2}{\send{\own{p}{e_1}}{\own{q}{x}}; C \xRightarrow{\text{SendE}\,p\,e_1\,e_2\,q,~B} \send{\own{p}{e_2}}{\own{q}{x}}; C} \and
  \infer{p \notin B\\\ q \notin B}{\send{\own{p}{v}}{\own{q}{x}}; C \xRightarrow{\text{SendV}\,p\,v\,q,~B} \subst{C}{\own{q}{x}}{v}} \and
  \infer{C_1 \xRightarrow{R,~B \cup \{p,q\}} C_2}{\send{\own{p}{e}}{\own{q}{x}}; C_1 \xRightarrow{R,~B} \send{\own{p}{e}}{\own{q}{x}}; C_2} \and
  \infer{p \notin B\\ e_1 \To e_2}{\cif{\own{p}{e_1}}{C_1}{C_2} \xRightarrow{\text{IfE}\,p\,e_1\,e_2,~B} \cif{\own{p}{e_2}}{C_1}{C_2}} \and
  \infer{p \notin B}{\cif{\own{p}{\ett}}{C_1}{C_2} \xRightarrow{\text{IfTT}\,p,~B} C_1} \and
  \infer{p \notin B}{\cif{\own{p}{\eff}}{C_1}{C_2} \xRightarrow{\text{IfFF}\,p,~B} C_2} \and
  \infer{C_1 \xRightarrow{R,~B \cup \{p\}} C_3\\ C_2 \xRightarrow{R,~B \cup \{p\}} C_4}{\cif{\own{p}{e}}{C_1}{C_2} \xRightarrow{R,~B} \cif{\own{p}{e}}{C_3}{C_4}} \and
  \infer{ }{\clet{X}{C_1}{C_2} \xRightarrow{\text{Def},~\varnothing} \subst{C_2}{X}{\clet{X}{C_1}{C_1}}}
\end{mathpar}


\begin{thm}[Simulation of Equivalence]
  \label{thm:simulation-equiv}
  If $C_1 \ceq C_2$ and $C_1 \xRightarrow{R,~B} C_1'$, then there is a $C_2'$ such that $C_2 \xRightarrow{R,~B} C_2'$ and $C_1' \ceq C_2'$.
\end{thm}
\begin{proof}
  Proven in Coq.
\end{proof}

\begin{thm}[Lifting Progress]
  \label{thm:lifting-progress}
  If $\proves e : \tau$ implies that there is some $e'$ such that $e \To e'$ for every expression $e$ and, for every value~$v$ such that $\Gamma \proves c : \bool$, $v$ is either $\ett$ or $\eff$, then for any choreography $C$, $; \proves C : p.\tau$ implies that there is some $R$ and $C'$ such that $C \xRightarrow{R,~\varnothing} C'$.
\end{thm}
\begin{proof}
  Proven in Coq.
\end{proof}

\begin{thm}[Lifting Preservation]
  \label{thm:lifting-preservation}
  If $\Gamma \proves e : \tau$ and $e \to e'$ implies $\Gamma \proves e' : \tau$, then $\Delta; \Gamma \proves C : p.\tau$ and $C \xRightarrow{R,~B} C'$ implies $\Delta; \Gamma \proves C' : p.\tau$.
\end{thm}
\begin{proof}
  Proven in Coq.
\end{proof}

\begin{thm}[Injection into Standard Presentation]
  If $C_1 \xRightarrow{R,~B} C_2$, then $C_1 \To C_2$.
\end{thm}
\begin{proof}
  Proven in Coq.
\end{proof}

\begin{thm}[Injection of Standard Presentation]
  If $C_1 \To C_2$ then there is an $R$ and $C_2'$ such that $C_2 \ceq C_2'$ and $C_1 \xRightarrow{R,~\varnothing} C_2'$.
\end{thm}
\begin{proof}
  Proven in Coq.
\end{proof}


\subsection{Endpoint Projection}

We define endpoint projection into the following calculus, based on the calculus of \citet{ScalasY19}:
\newcommand{\Send}[3]{#1\langle#2\rangle.#3}
\newcommand{\Recv}[3]{#1(#2).#3}
\newcommand{\extChoiceL}[2]{#1\langle\ell\rangle.#2}
\newcommand{\extChoiceR}[2]{#1\langle r \rangle.#2}
\newcommand{\intChoice}[3]{#1\{\ell \mapsto #2; r \mapsto #3\}}
\WithSuffix\newcommand\intChoice*[3]{#1\left\{\begin{array}{l}\ell \mapsto #2\\ r \mapsto #3\end{array}\right.}
\newcommand{\PiDef}[3]{\textsf{def}~#1 = #2 \mathrel{\textsf{in}} #3}
\newcommand{\PiITE}[3]{\textsf{if} #1 \mathrel{\textsf{then}} #2 \mathrel{\textsf{else}} #3}
\WithSuffix\newcommand\PiITE*[3]{\begin{array}{l}\textsf{if}~#1\\\textsf{then}~#2\\\textsf{else}~#3\end{array}}
\newcommand{\PiEnd}{\textsf{end}}
\newcommand{\SendT}[3]{#1\langle#2\rangle.#3}
\newcommand{\RecvT}[3]{#1(#2).#3}
\newcommand{\extChoiceT}[2]{#1\langle\ell,r\rangle.#2}
\newcommand{\intChoiceT}[3]{#1.\{\ell \mapsto #2 ; r \mapsto #3\}}
\WithSuffix\newcommand\intChoiceT*[3]{#1.\left\{\begin{array}{l}\ell \mapsto #2\\r \mapsto #3\end{array}\right.}
  
\begin{syntax}
  \category[Session Types]{S,T}
    \alternative{\PiEnd}
    \alternative{t}
    \alternative{\mu t.S}
    \alternative{\SendT{p}{\tau}{S}}
    \alternative{\RecvT{p}{\tau}{S}}
    \alternative{\extChoiceT{p}{S}}
    \alternative{\intChoiceT{p}{S}{T}}
  \category[Processes]{P,Q,\cdots}
    \alternative{0}
    \alternative{X}
    \alternative{\PiDef{X}{P}{Q}}
    \alternativeLine{\Send{p}{e}{P}}
    \alternative{\Recv{p}{x}{P}}
    \alternativeLine{\extChoiceL{p}{P}}
    \alternative{\extChoiceR{p}{P}}
    \alternative{\intChoice{p}{P}{Q}}
  \category[Programs]{\Pi,\cdots}
    \alternative{\mathop{\|}_p P_p}
\end{syntax}
We can thus view all programs as a function from process names/roles to threads of computation.
This view is required for the guarantees in \citet{ScalasY19} to apply anyway.
Note that sending expressions, receiving expressions, and if-then-else were all missing in the original paper.
Otherwise our language embeds into the calculus from the paper.
However, we are not higher-order at all: we have no abstraction, dynamic thread spawning, or channels sent along channels.
These reflect the restrictions in choreographies.

We will often write $$
\begin{array}{rcl}
  \intChoice*{p}{q}{P}{Q}&\text{for}&\intChoice{p}{q}{P}{Q},~\text{and}\\[1em]
  \intChoiceT*{p}{S}{T}&\text{for}&\intChoiceT{p}{S}{T}
\end{array}
$$

In order to deal with (equi-)recursive types, we use a notion of type equivalence.
(\citet{ScalasY19} call their equivalent of this equivalence ``subtyping.''
However, their relation is provably symmetric, so it is an equivalence.)
We treat types up-to this equivalence.
We define this equivalence \emph{co}inductively:
\begin{mathpar}
  \infer{ }{\PiEnd \equiv \PiEnd} \and
  \infer{\subst{S}{t}{\mu t.S} \equiv T}{\mu t.S \equiv T} \and
  \infer{S \equiv \subst{T}{t}{\mu t.T}}{S \equiv \mu t.T} \and
  \infer{S \equiv T}{\SendT{p}{\tau}{S} \equiv \SendT{p}{\tau}{T}} \and
  \infer{S \equiv T}{\RecvT{p}{\tau}{S} \equiv \RecvT{p}{\tau}{T}} \and
  \infer{S \equiv T}{\extChoiceT{p}{S} \equiv \extChoiceT{p}{T}} \and
  \infer{S_1 \equiv T_1\\ S_2 \equiv T_2}{\intChoiceT{p}{S_1}{S_2} \equiv \intChoiceT{p}{T_1}{T_2}}
\end{mathpar}
\begin{lem}[Type Equivalence Reflexivity]
  \label{lem:type-refl}
  For any session type~$S$, $S \equiv S$.
\end{lem}
\begin{lem}[Type Equivalence Symmetry]
  \label{lem:type-sym}
  For any session types~$S$ and $T$, $S \equiv T$ implies $T \equiv S$.
\end{lem}
\begin{lem}[Type Equivalence Transitivity]
  \label{lem:type-trans}
  For any session types~$S_1$, $S_2$, and $S_3$, $S_1 \equiv S_2$ and $S_2 \equiv S_3$ implies $S_1 \equiv S_3$.
\end{lem}

Since we view programs as mappings from roles to threads of computation, we can view a session typing context as a mapping from roles to session types.
We can then define a context stepping relation inductively as follows:
\begin{mathpar}
  \infer{\Gamma(p) = \SendT{q}{\tau}{S}\\ \Gamma(q) = \RecvT{p}{\tau}{T}}{\Gamma \to \Gamma[p \mapsto S, q \mapsto T]}\and
  \infer{\Gamma(p) = \extChoiceT{q}{S}\\ \Gamma(q) = \intChoiceT*{p}{T_1}{T_2}}
  {\Gamma \to \Gamma[p \mapsto S, q \mapsto T_1]} \and
  \infer{\Gamma(p) = \extChoiceT{q}{S}\\ \Gamma(q) = \intChoiceT*{p}{T_1}{T_2}}
  {\Gamma \to \Gamma[p \mapsto S, q \mapsto T_2]} \and
  \infer{\Gamma(p) = \mu t.S\\ \Gamma[p \mapsto \subst{S}{t}{\mu t.S}] \to \Gamma'}{\Gamma \to \Gamma'}
\end{mathpar}

We can define live contexts:
\begin{defn}[Live Context]
  A context~$\Gamma$ is \emph{live}, written $\text{live}(\Gamma)$, if all of the following are true:
  \begin{itemize}
  \item $\Gamma(p) = \SendT{q}{\tau}{S} \implies \exists \Gamma'. \Gamma \to^\ast \Gamma' \land \Gamma'(p) = S$
  \item $\Gamma(p) = \RecvT{q}{\tau}{S} \implies \exists \Gamma'. \Gamma \to^\ast \Gamma' \land \Gamma'(p) = S$
  \item $\Gamma(p) = \extChoiceT{q}{S} \implies \exists \Gamma'. \Gamma \to^\ast \Gamma' \land \Gamma'(p) = S$
  \item $\Gamma(p) = \intChoiceT{q}{S} \implies \exists \Gamma'. \Gamma \to^\ast \Gamma' \land \exists i \in \{1,2\}. \Gamma'(p) = S_i$
  \item $\Gamma(p) = \mu t.S \implies \text{live}(\Gamma[p \mapsto \subst{S}{t}{\mu t.S}])$
  \item $\Gamma \to \Gamma' \implies \text{live}(\Gamma')$
  \end{itemize}
\end{defn}
\akh{I really hate this definition.
  It bakes in a ton of things that I think should be lemmas.
  However, it is a direct translation of the multiparty session types paper's liveness critereon.}

We can define stepping of programs inductively:
\begin{mathpar}
  \infer{e \to e'\\ \Pi(p) = \Send{q}{e}{P}}{\Pi \to \Pi[p \mapsto \Send{q}{e'}{P}]}\and
  \infer{\text{value}(v)\\ \Pi(p) = \Send{q}{v}{P}\\ \Pi(q) = \Recv{p}{x}{Q}}
  {\Pi \to \Pi[p \mapsto P, q \mapsto \subst{Q}{x}{v}]}\\
  \infer{e \to e'\\ \Pi(p) = \PiITE{e}{P}{Q}}{\Pi \to \Pi[p \mapsto \PiITE{e'}{P}{Q}]}\and
  \infer{\Pi(p) = \PiITE{\textsf{true}}{P}{Q}}{\Pi \to \Pi[p \mapsto P]} \and
  \infer{\Pi(p) = \PiITE{\textsf{false}}{P}{Q}}{\Pi \to \Pi[p \mapsto Q]} \\
  \infer{\Pi(p) = \PiDef{X}{P}{Q}}{\Pi \to \Pi[p \mapsto \subst{Q}{X}{\PiDef{X}{P}{P}}]}\\
  \infer{\Pi(p) = \extChoiceL{q}{P}\\ \Pi(q) = \intChoice{p}{Q_1}{Q_2}}{\Pi \to \Pi[p \mapsto P, q \mapsto Q_1]} \and
  \infer{\Pi(p) = \extChoiceR{q}{P}\\ \Pi(q) = \intChoice{p}{Q_1}{Q_2}}{\Pi \to \Pi[p \mapsto P, q \mapsto Q_2]}
\end{mathpar}
Note that we do \emph{not} have an equivalence relation on programs.
Our view of programs as mappings lets abstracts away issues of syntax, such as the order of threads.

We can define when a context~$\Gamma$ can end a program as follows:
\begin{defn}[Ending Context]
  We say a context~$\Gamma$ is an \emph{ending context}, written $\text{end}(\Gamma)$, if for every role~$p$, $\Gamma(p) \equiv \PiEnd$.
\end{defn}

This allows us to define typing, again inductively.
We define typing as a relation $\Theta; T; \Delta \proves P$ where $\Theta$ is a set of defined names, $T$ is a session type, and $\Delta$ is an expression context.
\akh{I'm pretty sure my typing rule for definitions is broken. I have to think about what to do about that.
  I think I want to use recursive types.
  I'm a little confused about how this works in the original paper.}
\begin{mathpar}
  \infer{ }{\Theta; \PiEnd; \Delta \proves 0} \and
  \infer{\Theta(X) = t}{\Theta; t; \Delta \proves X} \and
  \infer{\Theta, X : t; \subst{S}{t}{\mu t.S}; \Delta \proves P\\ \Theta, X : t; \subst{S}{t}{\mu t.S}; \Delta \proves Q}
  {\Theta; \mu t.S; \Delta \proves \PiDef{X}{P}{Q}}\\
  \infer{\Delta \proves e : \tau\\ \Theta; S; \Delta \proves P}{\Theta; \SendT{p}{e}{S}; \Delta \proves \Send{q}{e}{P}} \and
  \infer{\Theta; S; \Delta, x : \tau \proves P}{\Theta; \RecvT{q}{\tau}{S}; \Delta \proves \Recv{q}{x}{P}}\\
  \infer{\Theta; S; \Delta \proves P\\ \Theta; T; \Delta \proves Q}{\theta; \intChoiceT{q}{S}{T}; \Delta \proves \intChoice{q}{P}{Q}} \and
  \infer{\Theta; S; \Delta \proves P}{\Theta; \extChoiceT{q}{S}; \Delta \proves \extChoiceL{q}{P}} \and
  \infer{\Theta; S; \Delta \proves P}{\Theta; \extChoiceT{q}{S}; \Delta \proves \extChoiceR{q}{P}}\\
  \infer{\Delta \proves e : \textsf{bool}\\\Theta; S; \Delta \proves P\\ \Theta; S; \Delta \proves Q}{\Theta; S; \Delta \proves \PiITE{e}{P}{Q}}
\end{mathpar}

We then say that $\Gamma \proves \Pi$ if, for every role~$p$, $\varnothing; \Gamma(p); \varnothing \proves \Pi(p)$.

This allows us to prove our two central theorems:
\begin{thm}
  If $\text{live}(\Gamma)$, $\Gamma \proves \Pi$ and $\Pi \to \Pi'$, then $\exists \Gamma'$ such that $\Gamma \to \Gamma'$ and $\Gamma' \proves \Pi'$.
\end{thm}
\begin{thm}
  If $\text{live}(\Gamma)$, $\Gamma \proves \Pi$ implies that either, for every role~$p$, $\Pi(p) = 0$ or there is a $\Pi'$ such that $\Pi \to \Pi'$.
\end{thm}

\subsection{Example Programs}
A program that sends a variable around in a triangle.
$$\send{\own{\textsf{Alice}}{n}}{\own{\textsf{Bob}}{x}};~\send{\own{\textsf{Bob}}{\textsf{enc}(x)}}{\own{\textsf{Cathy}}{y}};~\send{\own{\textsf{Cathy}}{\textsf{enc}(y)}}{\own{\textsf{Alice}}{z}}; \own{\textsf{Alice}}{z}$$

A trusted-third-part program:
$$\send{\own{A}{3}}{\own{C}{x}};~\send{\own{B}{\lambda x.\,e}}{\own{C}{f}}; \own{C}{f~x}$$

\bibliography{bibliography/akh}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% eval: (push '("\\To" . ?⇒) prettify-symbols-alist)
%%% eval: (push '("\\cleq" . ?≼) prettify-symbols-alist)
%%% eval: (push '("\\ceq" . ?≈) prettify-symbols-alist)
%%% TeX-master: t
%%% End:

