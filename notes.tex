\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[letterpaper, margin=1in, bottom=1in]{geometry}
\usepackage[authoryear,sort,square]{natbib}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{bbm}
\usepackage{bbold}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{latex-pl-syntax/pl-syntax}
\usepackage{xspace}
\usepackage{suffix}
\usepackage{turnstile}
\usepackage{multicol}

\usepackage[hidelinks]{hyperref}

% Notes
\newcommand{\uncertain}[1]{{\color{red} #1}\xspace}
\newcommand{\newcommenter}[3]{%
  \newcommand{#1}[1]{%
    \textcolor{#2}{\small\textsf{[{#3}: {##1}]}}%
  }%
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\newcommenter{\akh}{purple}{AKH}
\newcommenter{\as}{red}{AS}

% AMSTHM Setup
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\newtheorem{conj}{Conjecture}
\newtheorem{inv}{Invariant}
\theoremstyle{definition}
\newtheorem{defn}{Definition}

%% Macros

% Context Projection
\newcommand\proj[2]{\ensuremath{\left.#1\right|_{#2}}}

% Endpoint Projection
\newcommand\epp[2]{\ensuremath{\llbracket#1\rrbracket_{#2}}}

\newcommand\step[1]{\ensuremath{\xRightarrow{{#1}}_{\raisebox{3pt}{\footnotesize{c}}}}}

\bibliographystyle{plainnat}

\begin{document}
\section{Syntax}
\begin{syntax}
	\categoryFromSet[Conrete Locations]{L}{\mathcal{L}}
	\abstractCategory[Location Variables]{X, Y, Z}
		
	\category[Locations]{\ell}
	\alternative{L}
	\alternative{X}
	
	\category[Location Sets]{\rho}
	\alternative{\{\ell_1,\ldots,\ell_n\}}
	\\
	\abstractCategory[Local Expressions]{e}
		
	\abstractCategory[Local Variables]{x, y, z}
	
	\\
	\abstractCategory[Choreography Variables]{\alpha, \phi}
	
	\category[Synchronization Labels]{d}
	\alternative{\mathbb{L}}
	\alternative{\mathbb{R}}

	
	\category[Choreographies]{C}
	\alternative{\alpha}
	\alternative{\ell.e}
	\alternative{C_1\;C_2}\\
	\alternative{\lambda \alpha.C}
	\alternative{\mu \alpha.C}\\
	\alternative{C \overset{\ell_1}{\rightsquigarrow} \ell_2}\\
	\alternative{\ell.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2}\\
	\alternative{\ell_1[d] \rightsquigarrow \ell_2; C}\\
	\alternative{\text{let}\; \ell.x := C_1 \;\text{in}\; C_2}\\
	\alternative{\Lambda X.C}
	\alternative{C\;\ell}\\
	\alternative{\ell.\text{tell}\; \rho_1\; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2}
\end{syntax}


\section{Type System}
\paragraph{Syntax of Types}
\begin{syntax}
	\abstractCategory[Local Types]{t}

	\category[Choreography Types]{\tau}
	\alternative{t @ \ell}
	\alternative{\tau_1 \rightarrow \tau_2}
	\alternative{\forall X.\tau}
	
	\category[Location Contexts]{\Theta}
	\alternative{\cdot}
	\alternative{\Theta, X : \text{Loc}}
	
	\category[Local-Let Contexts]{\Delta}
	\alternative{\cdot}
	\alternative{\Delta, \ell.x : t}
	
	\category[Choreography Contexts]{\Gamma}
	\alternative{\cdot}
	\alternative{\Gamma, \alpha : \tau}
\end{syntax}

\paragraph{Context Projection}
Projects a local-let context $\Delta$ to a local context at a (possibly variable) location $\ell$.
\begin{align*}
	\proj{\cdot}{\ell} &= \cdot \\
	\proj{\Delta, \ell.x : t}{\ell} &=
		\begin{cases} 
      		\proj{\Delta}{\ell}, x : t & \ell' = \ell \\
      		\proj{\Delta}{\ell} & \ell' \neq \ell \\
   		\end{cases}
\end{align*}

\paragraph{Typing Relations}
\begin{align*}
	\Theta &\vdash \Delta \tag{Local-Let Context Well-Formedness}\\
	\Theta &\vdash \Gamma \tag{Choreography Context Well-Formedness}\\
	\Theta &\vdash \ell \;\text{Loc} \tag{Location Well-Formedness}\\
	\Theta &\vdash \rho \;\text{LocSet} \tag{Location-Set Well-Formedness}\\
	\Theta &\vdash \tau \;\text{Ty} \tag{Choreography Type Well-Formedness}\\
	\Theta;\Gamma;\Delta &\vdash C : \tau \tag{Choreography Typing Relation}
\end{align*}

\paragraph{Context, Type, and Location Well-Formedness Rules}
\begin{mathpar}
  \infer[EmpCtx]{}
  {\Theta \vdash \cdot} \and

  \infer[AddCtxLet]{\Theta \vdash \Delta \\
    \Theta \vdash \ell \;\text{Loc}}
  {\Theta \vdash (\Delta, \ell.x : t)} \and

  \infer[AddCtxChor]{\Theta \vdash \Gamma \\
    \Theta \vdash \tau \;\text{Ty}}
  {\Theta \vdash (\Gamma, \alpha : \tau)} \and

  \infer[Loc]{\ell \in \mathcal{L} \cup \Theta}
  {\Theta \vdash \ell \;\text{Loc}} \and

  \infer[LocSet]{\Theta \vdash \ell_1,\ldots,\ell_n \;\text{Loc}}
  {\Theta \vdash \{\ell_1,\ldots,\ell_n\} \;\text{LocSet}} \and


  \infer[AtTy]{\Theta \vdash \ell \;\text{Loc}}
  {\Theta \vdash t @ \ell \;\text{Ty}} \and

  \infer[FunTy]{\Theta \vdash \tau_1  \;\text{Ty}\\
    \Theta \vdash \tau_2 \;\text{Ty}}
  {\Theta \vdash \tau_1 \rightarrow \tau_2 \;\text{Ty}} \and

  \infer[AllTy]{\Theta, X \;\text{Loc} \vdash \tau \;\text{Ty}}
  {\Theta \vdash \forall X.\tau  \;\text{Ty}} \and
\end{mathpar}

\paragraph{Choreography Typing Rules}
\begin{mathpar}
  \infer[Var]{\Theta \vdash \Gamma \\
  	\Theta \vdash \Delta \\
    x : \tau \in \Gamma}
  {\Theta;\Gamma;\Delta \vdash x : \tau} \and

  \infer[Done]{\Theta \vdash \Gamma \\
  	\Theta \vdash \Delta \\
    \Theta \vdash \ell \;\text{Loc} \\
    \proj{\Delta}{\ell} \vdash e : t}
  {\Theta;\Gamma;\Delta \vdash \ell.e \vdash t @ \ell} \and

  \infer[Send]{\Theta;\Gamma;\Delta \vdash C : t @ \ell_1 \\
	\Theta \vdash \ell_2 \;\text{Loc}}
  {\Theta;\Gamma;\Delta \vdash C \overset{\ell_1}{\rightsquigarrow} \ell_2 : t @ \ell_2} \and

  \infer[If]{\Theta;\Gamma;\Delta \vdash C_1 : \text{bool} @ \ell \\
    \Theta;\Gamma;\Delta \vdash C_1 : \tau \\
    \Theta;\Gamma;\Delta \vdash C_2 : \tau}
  {\Gamma \vdash \ell.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2 : \tau} \and

  \infer[Sync]{\Gamma \vdash \ell_1, \ell_2 \;\text{Loc} \\
    \Theta;\Gamma;\Delta \vdash C : \tau}
  {\Theta;\Gamma;\Delta \vdash \ell_1[d] \rightsquigarrow \ell_2; C : \tau} \and

  \infer[LocalLet]{\Theta;\Gamma;\Delta \vdash C_1 : t_1 @ \ell \\
    \Theta;\Gamma;(\Delta, x : \ell.t_1) \vdash C : \tau_2}
  {\Gamma \vdash \text{let}\; \ell.x := C_1 \;\text{in}\; C_2 : \tau_2} \and

  \infer[Fun]{\Theta;\Gamma;(\Delta, \alpha : \tau_1) \vdash C : \tau_2}
  {\Theta;\Gamma;\Delta  \vdash \lambda \alpha.C : \tau_1 \rightarrow \tau_2} \and

  \infer[Rec]{\Theta;\Gamma;(\Delta, \alpha : \tau) \vdash C : \tau}
	{\Theta;\Gamma;\Delta  \vdash \mu \alpha.C : \tau} \and

  \infer[App]{\Theta;\Gamma;\Delta \vdash C_1 : \tau_1 \rightarrow \tau_2 \\
    \Theta;\Gamma;\Delta \vdash C_2 : \tau_1}
  {\Theta;\Gamma;\Delta  \vdash C_1\;C_2 : \tau_2} \and

  \infer[LocAbs]{(\Theta, X : \;\text{Loc});\Gamma;\Delta \vdash C : \tau}
  {\Theta;\Gamma;\Delta \vdash \Lambda X.C : \forall X.\tau} \and

  \infer[LocApp]{\Theta \vdash \ell \;\text{Loc} \\
    \Theta;\Gamma;\Delta  \vdash C : \forall X.\tau}
  {\Theta;\Gamma;\Delta \vdash C\;\ell : \tau[X \mapsto \ell]} \and

  \infer[TellLet]{\Theta;\Gamma;\Delta \vdash C_1 : \text{Loc} @ \ell \\
    \Theta \vdash \rho_1, \rho_2 \;\text{LocSet} \\
    \Theta \vdash \tau \;\text{Ty} \\
    (\Theta, X : \;\text{Loc});\Gamma;\Delta \vdash C : \tau}
  {\Theta;\Gamma;\Delta \vdash \ell.\text{tell}\; \rho_1 \;\text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2 : \tau}
\end{mathpar}

\section{Operational Semantics}
\paragraph{Traces}\;
\begin{syntax}
	\category[Trace Elements]{T}
	\alternative{\bullet}\\
	\alternative{L}\\
	\alternative{L_1[v] \rightsquigarrow L_2}\\
	\alternative{L_1[d] \rightsquigarrow L_2}\\
	\alternative{L_1[L_2] \rightsquigarrow \rho}
\end{syntax}

\paragraph{Trace Semantics}\;
Deterministic, small-step trace semantics $C_1 \step{T} C_2$ where $C_1, C_2$ are \emph{closed} choreographies, and $T$ is a trace element.

\begin{mathparpagebreakable}
  \infer[Done]{e_1 \Rightarrow_e e_2}
  {L.e_1 \step{L} L.e_2} \and

  \infer[Send]{C_1 \step{T} C_2}
  {C_1 \overset{L_1}{\rightsquigarrow} L_2 \step{T} C_2 \overset{L_1}{\rightsquigarrow} L_2} \and

  \infer[SendV]{\text{Value}(v)}
  {L_1.v \overset{L_1}{\rightsquigarrow} L_2 \step{L_1[v] \rightsquigarrow L_2} L_2.v} \and

  \infer[If]{C \step{T} C'}
  {L.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2 \step{T} L.\text{if}\; C' \;\text{then}\; C_1 \;\text{else}\; C_2} \and

  \infer[IfT]{}
  {L.\text{if}\; L.\text{true} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{L} C_1} \and

  \infer[IfF]{}
  {L.\text{if}\; L.\text{false} \;\text{then}\; C_1 \;\text{else}\; C_2 \step{L} C_2} \and

  \infer[DefLocal]{C_1 \step{T} C_1'}
  {\text{let}\; L.x := C_1 \;\text{in}\; C_2 \step{T} \text{let}\; L.x := C_1' \;\text{in}\; C_2} \and

  \infer[DefLocalV]{\text{Value}(v)}
  {\text{let}\; L.x := L.v \;\text{in}\; C \step{\bullet} C[x \mapsto v]} \and

  \infer[AppFun]{C_1 \step{T} C_1'}
  {C_1 \; C_2 \step{T} C_1' \; C_2} \and

  \infer[AppArg]{\text{Value}(V_1)\\
  	C_2 \step{T} C_2'}
  {V_1 \; C_2 \step{T} V_1 \; C_2'} \and

  \infer[App]{\text{Value}(V)}
  {(\lambda \alpha.C) \; V \step{\bullet} C[\alpha \mapsto V]} \and
  
  \infer[Fix]{}
  {\mu \alpha.C \step{\bullet} C[\alpha \mapsto \mu \alpha.C]} \and

  \infer[Sync]{}
  {L_1[d] \rightsquigarrow L_2; C \step{L_1[d] \rightsquigarrow L_2} C} \and

  \infer[LocApp]{}
  {(\Lambda X.C) \; L \step{\bullet} C[X \mapsto L]} \and

  \infer[TellLet]{C_1 \step{T} C_1'}
  {L.\text{tell}\; \rho_1\; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2 \step{T} L.\text{tell}\; \rho_1\; \text{let}\; X := C_1' \in \rho_2 \;\text{in}\; C_2}

  \infer[TellLetV]{}
  {L_1.\text{tell}\; \rho_1\; \text{let}\; X := L_1.L_2 \in \rho_2 \;\text{in}\; C \step{L_1[L_2] \rightsquigarrow \rho_1 \cup \rho_2} C[X \mapsto L_2]}
\end{mathparpagebreakable}

\section{Endpoint Projection}
\paragraph{Control Language}
\begin{syntax}
    \category[Control Expression]{E}
    \alternative{\alpha}
    \alternative{()}
	\alternative{E_1 ; E_2}
	\alternative{E_1\;E_2}\\
    \alternative{\lambda \alpha.E}
    \alternative{\mu \alpha.E}\\
	\alternative{\Lambda X.E}
    \alternative{E\;\ell}\\
    \alternative{\text{ret}(e)}
    \alternative{\text{let}\; \text{ret}(x) := E_1 \;\text{in}\; E_2}\\
    \alternative{\text{send}\; E \;\text{to}\; \ell}
    \alternative{\text{receive from}\;  \ell}\\
    \alternative{\text{if}\; E \;\text{then}\; E_1 \;\text{else}\; E_2}\\
    \alternative{\text{choose}\; d \;\text{for}\;  \ell ; E}\\
    \alternative{\text{allow}\; \ell \;\text{choice}\; (d \Rightarrow E)^*}\\
    \alternative{\text{send tell}\; \rho \;\text{let}\; X := E_1 \;\text{in}\; E_2}\\
    \alternative{\text{receive}\; X \;\text{from}\; \ell \;\text{in}\; E}\\
	\alternative{\text{AmI}\; \ell \;\text{then}\; E_1 \;\text{else}\; E_2}

    \category[Systems]{\Pi}
    \alternative{L_1 \triangleright E_1 \;\|\; \ldots \;\|\; L_n \triangleright E_n}
\end{syntax}

\paragraph{Endpoint Projection}\;

%	\alternative{\ell.\text{tell}\; \rho_1\; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2}

\begin{mathparpagebreakable}
\begin{aligned}[t]
	\epp{\alpha}{L} &= \alpha\\
	\epp{\ell.e}{L} &=
		\begin{cases}
			\text{ret}(e) & L = \ell \\
			() & L \neq \ell
		\end{cases}\\
	\epp{C \overset{\ell_1}{\rightsquigarrow} \ell_2}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{send}\; \epp{C}{L} \;\text{to}\; \ell_2 & L = \ell_1 \neq \ell_2 \\
			\text{receive from}\;\ell_1 & L = \ell_2 \neq \ell_1\\
			() & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\ell.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2}{L} &= 
		\begin{cases}
			\text{if}\; \epp{C}{L} \;\text{then}\; \epp{C_1}{L} \;\text{else}\; \epp{C_2}{L} & L = \ell \\
			\epp{C_1}{L} \sqcup \epp{C_2}{L} & L \neq \ell
		\end{cases}\\
	\epp{\ell_1[d] \rightsquigarrow \ell_2; C}{L} &=
		\begin{cases}
			\epp{C}{L} & L = \ell_1 = \ell_2 \\
			\text{choose}\; d \;\text{for}\; \ell_2; \epp{C}{L} & L = \ell_1 \neq \ell_2 \\
			\text{allow}\; \ell_1 \;\text{choice}\; (d \Rightarrow \epp{C}{L}) & L = \ell_2 \neq \ell_1\\
			\epp{C}{L} & L \neq \ell_1, \ell_2
		\end{cases}\\
	\epp{\text{let}\; \ell.x := C_1 \;\text{in}\; C_2}{L} &= 
		\begin{cases}
			\text{let}\; \text{ret}(x) := \epp{C_1}{L} \;\text{in}\; \epp{C_2}{L} & L = \ell \\
			\epp{C_1}{L} ; \epp{C_2}{L} & L \neq \ell
		\end{cases}\\
	\epp{\lambda \alpha.C}{L} &= \lambda \alpha.\epp{C}{L}\\
	\epp{\mu \alpha.C}{L} &= \mu \alpha.\epp{C}{L}\\
	\epp{C_1\;C_2}{L} &= \epp{C_1}{L}\;\epp{C_2}{L}\\
	\epp{\Lambda X.C}{L} &= \Lambda X.\text{AmI}\; X \;\text{then}\; \epp{C[X \mapsto L]}{L} \;\text{else}\; \epp{C}{L}\\
	\epp{C\;\ell}{L} &= \epp{C}{L}\;\ell\\
	\epp{\ell.\text{tell}\; \rho_1 \; \text{let}\; X := C_1 \in \rho_2 \;\text{in}\; C_2}{L} &= 
		\begin{cases}
			\text{send tell}\; (\rho_1 \cup \rho_2) \setminus \{\ell\} \;\text{let}\; X := \epp{C_1}{L} \;\text{in}\\ \text{AmI}\; X \;\text{then}\; \epp{C_2[X \mapsto L]}{L} \;\text{else}\; \epp{C_2}{L} & L = \ell\\
			\epp{C_1}{L} ; \text{receive}\; X \;\text{from}\; \ell \;\text{in}\;\\
			\text{AmI}\; X \;\text{then}\; \epp{C_2[X \mapsto L]}{L} \;\text{else}\; \epp{C_2}{L} & L \neq \ell, L \in \rho_1 \cup \rho_2\\
			\epp{C_1}{L} & L \neq \ell, L \notin \rho_1 \cup \rho_2
		\end{cases}
\end{aligned}
\end{mathparpagebreakable}


\section{Meeting Notes}
\paragraph{3/7/2024}
\subparagraph{Misc}
\begin{itemize}
	\item Local values don't seem to have an elimination form with current system
	\item Don't need to track blocking sets in reduction rules; can compute from redices
\end{itemize}

\subparagraph{Tell-do Concerns}
\begin{itemize}
	\item How do we know who to send the tell-do to, as it's using a local value?
	\item We need to statically compute an over-approximation of the set of possible recipients
	\item Idea: Have the local language compute the over-approximation, and have its soundness be an assumption for the deadlock freedom guarantees.
	\[
	\text{tell}\; x := C_1 \;\text{do}[S]\; C_2
	\]
	\item $S$ is a \emph{set} of locations that the message will be sent to
	\item Could just send to everyone, but this uses a closed-world assumption
	\item Weird example suggested by Ethan: Choreography where Alice continually discovers and adds new known locations, and at each point she randomly selects a person from this set to delegate something to. At each point the set is finite, but it will increase infinitely, and the size depends at which step you're at.
	\item Need to use implicit sends rather than explicit sends (might need to do alias analysis on the value of the local location otherwise!)
\end{itemize}

\paragraph{3/14/2024}
\subparagraph{Out-of-Order Execution}
With send operations in the form $C_1 \overset{\ell_1}{\rightsquigarrow} \ell_2$ it becomes difficult to tell when you can do out-of-order execution as you need to examine $C_1$; it could block more than just $\ell_1$. Moreover, you need to allow for reduction within the scope of a function/lambda abstraction in order to do so, as this is required to use the output of a send operation. You can \emph{probably} solve this problem through a meta-function, but the old syntax works fine and is just as general, so I will use it.

Solution: Revert send operations to the form $\ell_1.e \rightsquigarrow \ell_2.\alpha; C$. Now we can easily tell that $C$ can execute out-of-order when $\ell_1$ and $\ell_2$ are blocked.

Other solution: Use an in-order trace semantics for choreographies; function application comes easily. Then to deal with correctness use an equivalence relation on the traces allowing for re-ordering.

\subparagraph{Delegation}
For the tell-do binding, won't you need to send the chosen location to more than just the possible set of locations it can be anyways? For instance:
\begin{align*}
	&\text{tell}\; X \in \{W_1,W_2\} := D.e_1 \;\text{do}\\
	&X.e_2 \rightsquigarrow \alpha @ \text{Alice};\\
	&\text{let}\; \text{Alice}.x := \alpha \;\text{in}\\
	&\text{Alice}.e_3
\end{align*}
Alice needs to know which X was chosen as she needs to receive from them, even though she is not among $\{D,W_1,W_2\}$. Thus we need to know the set of all processes who may be involved.

OK, then just try and compute the involved processes statically! Problem: Higher order functions. Who is involved in the process $\lambda \alpha : \tau_1 \rightarrow \tau_2.C$? Well, because $\alpha$ is another choreography, it depends on who is involved in $\alpha$. Do what Alice or Bob does and annotate choreographic functions with a set of processes and allow for abstraction over them: $\text{IP}(\lambda \alpha : \tau_1 \rightarrow_\rho \tau_2.C) = \rho \cup \text{IP}(C)$. This complicates the type system but seems necessary if we want to allow for this form of delegation.
Solution:
\begin{align*}
	&\text{tell}_{\{\text{Alice}\}}\; X \in \{W_1,W_2\} := D.e_1 \;\text{do}\\
	&X.e_2 \rightsquigarrow \alpha @ \text{Alice};\\
	&\text{let}\; \text{Alice}.x := \alpha \;\text{in}\\
	&\text{Alice}.e_3
\end{align*}
Send $X$ to $\{Alice, W_1, W_2\}$. If someone tries to use $X$ inside the body and we didn't sent it to them, the endpoint projection will fail.
\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-master: t
%%% End: