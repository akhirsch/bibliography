* Thrust 1: Synthesizing Session Types (with Compositionality)
** Use upcoming OOPSLA paper
** Parallel composition in choreographies
*** Session types in choreographies
*** Alternative: something something existential types

{request : unit, m1 : int} = exists l. l will send a message of type unit and another of type int (linearly)

F = join (C : {request: unit, m1 : int}) {
  C.request -> Server._;
  Server.params -> C;
  C.m1 -> Server.x;
  Server.publish(x)
}

joinAs F Alice {request = (), m1 = \params => 3 * params.x}

** Deadlock Freedom from session types
*** Argument: compiled programs are well-session-typed, well-session-typed programs are df, qed
*** Extends to situations where we don't know/don't control all nodes
**** Including swapping out nodes we do control!
* Thrust 2: Modular Session Types (+ Synthesis)
** Hide implementation details of blobs
*** Example: swap out monolithic KVS with sharded version for scalability
*** No need to recompile other components
** Idea: Rational Expressions are session types
*** Semantics: Pomsets, CKA, Pomset Automata
*** Stitch types using Brzozowski-style operations
**** Seems sound
**** Not complete
**** Think complete is possible, needs further research
** Labeled Choice and Modularity
*** Labeled choice within a blob can cause problems
**** At least asynchronously
*** How to represent in rational expressions?
* Thrust 3: Taking Advantage of Modularity (in Choreographic Lang. Design)
** ML-Style Modules for choreographies
*** Session types for functions?
** Channels as first-class objects
*** In a data center, not everybody can talk to everyone else; need a channel
**** Embedded systems too
