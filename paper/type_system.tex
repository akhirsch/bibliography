\subsection{Kinding System}
\label{sec:kind-system}
Using the local type well-formedness judgment described in Section \ref{sec:local-types}, we can build the \emph{choreographic} kinding judgment for \langname.

The kinding judgment for our language is of the form $\chorkinded{\Gamma}{t}{\kappa}$, where $\Gamma$ is a list of type-variable ascriptions $\alpha \knd \kappa$, $t$ is a type, and $\kappa$ is a kind.
There are four kinds of types:
 \ashley{Better formatting for this? I'd like them to be more aligned somehow}
\begin{itemize}
  \item Locations $*_\ell$
  \item Sets of locations $*_s$
  \item Choreographic types $*$
  \item Local program types $*_e$
\end{itemize}

\paragraph{Locations and Location Sets}
Location names are represented by the kind $*_\ell$.
Well-formed types of this kind consist of precisely the concrete locations $L \in \Locations$, and the in-context location variables $\alpha \knd *_\ell$.
Sets of location names belong to the kind $*_s$.
In particular, this kind consists of finite sets of elements of the $*_\ell$ kind, as introduced by the empty set $\varnothing$, singleton set $\{\ell\}$, and set union $\rho_1 \cup \rho_2$ constructors.

\paragraph{Choreographic Types}
There are three choreographic types of kind $*$ used to describe \langname programs.
The located type $t_e @ \ell$ represents a local program of type $t_e$ located at $\ell$.
The choreographic function type $\tau_1 \to \tau_2$ represents possibly higher-order choreographies which take a value of type $\tau_1$ as input, and result in a value of type $\tau_2$.
The universal quantifier type $\forall \alpha \knd \kappa.\tau$ is used to represent choreographic programs which implement parametric polymorphism.
Specifically, a program which takes as input a type $t$ of kind $\kappa$ (from any of the four kinds mentioned above), and results in a value of type $\subst{\tau}{\alpha}{t}$.

These three types have the following kinding rules:
\begin{mathpar}
  \infer[TyAt]{\chorkinded{\Gamma}{t_e}{*_e} \\
    \chorkinded{\Gamma}{\ell}{*_\ell}}
    {\chorkinded{\Gamma}{t_e @ \ell}{*}} \and

  \infer[TyArrow]{\chorkinded{\Gamma}{\tau_1}{*} \\
    \chorkinded{\Gamma}{\tau_2}{*}}
    {\chorkinded{\Gamma}{\tau_1 \to \tau_2}{*}} \and

  \infer[TyAbs]{\chorkinded{\Gamma, \alpha \knd \kappa}{\tau}{*}}
    {\chorkinded{\Gamma}{\forall \alpha \knd \kappa.\tau}{*}} \and 
\end{mathpar}
\ethan{Why is the first premise \textsc{TyAt} not $\Gamma \proves t_e :: *_e$?}
\ashley{Should be, not sure why this was different than in the full type rules!}
For example, the type of a choreographic program which sends a value of type $\eta$ from $\alpha$ to $\beta$, for any possible local type $\eta$ and locations $\alpha$ and $\beta$, can be written as follows:
\begin{mathpar}
  \forall \eta \knd *_e.\forall \alpha \knd *_\ell.\forall \beta \knd *_\ell.\eta @ \alpha \to \eta @ \beta
\end{mathpar}

\paragraph{Local Types}
Types of kind $*_e$ are precisely the types included in the local language under a given type-variable context.
The local language may or may-not include the capability of binding type variables, and this decision has no explicit effect on the choreographic types.
However, local types included in our type system may use type variables which have been bound by the choreographic for-all type.
For instance, recall Example \ref{ex:st-lambda}, a simply-typed lambda calculus with no type polymorphism.
Although type variables are not bound by any type constructors of this local language, type variables can still be explicitly used, as in the following type representing a polymorphic function application at a concrete location $L$:
\begin{mathpar}
  \forall \eta_1 \knd *_e.\forall \eta_2 \knd *_e.(\eta_1 \to \eta_2) @ L \to \eta_1 @ L \to \eta_2 @ L
\end{mathpar}

\subsection{Type System}
\label{sec:type-system}
In a similar manner to the kinding system, we use the type system of the local language to build the choreographic typing system.

Typing judgments for our language are of the form $\chortyped{\Gamma}{\Delta}{\Sigma}{C}{\tau}$, where $\Gamma$ is a choreographic kinding context, $\Delta$ is a list of choreographic typing ascriptions $X \ty \tau$, $\Sigma$ is a list of local variable typing ascriptions $\ell.x \ty t_e$, $C$ is a choreography, and $\tau$ is a choreographic type.

Where the choreographic context $\Delta$ handles variables bound at the choreographic level, for instance via a lambda-abstraction $\Fun{F}{X\ty\tau}{C}$, the local context $\Sigma$ handles variables bound to a specific location via the local-let binding $\LetIn{\ell.x \ty t_e}{C_1}{C_2}$.
This allows choreographic expressions of the form $t_e @ \ell$ to be used within local computations at $\ell$, and enforces that each location can only perform local computations on data that they have access to.

\begin{figure}[h]
  \begin{syntax}
    \category[Kinds]{\kappa}
    \alternative{*}
    \alternative{*_\ell}
    \alternative{*_s}
    \alternative{*_e}
    \\
    
    \abstractCategory[Type Variables]{\alpha, \beta, \ldots}
    
    \abstractCategory[Local Types]{t_e}

    \categoryFromSet[Locations]{L}{\Locations}
    
    \category[Choreography Types]{t, \ell, \rho, \tau}
    \alternative{\alpha}
    \alternative{t_e @ \ell}
    \alternative{\tau_1 \rightarrow \tau_2}
    \alternative{\forall \alpha \knd \kappa.\tau}
    \\
    \alternative{L}
    \alternative{\varnothing}
    \alternative{\{\ell\}}
    \alternative{\rho_1 \cup \rho_2}
    % \\
    % \category[Choreography Kinding Contexts]{\Gamma}
    % \alternative{\cdot}
    % \alternative{\Gamma, \alpha \knd \kappa}
    
    % \category[Choreography Typing Contexts]{\Delta}
    % \alternative{\cdot}
    % \alternative{\Delta, X \ty \tau}
    
    % \category[Locally-Bound Typing Contexts]{\Sigma}
    % \alternative{\cdot}
    % \alternative{\Sigma, \ell.x \ty t_e}
    % \\
    % \category[Local Kinding Contexts]{\Gamma_e}
    % \alternative{\cdot}
    % \alternative{\Gamma_e, \alpha}
    
    % \category[Local Typing Contexts]{\Sigma_e}
    % \alternative{\cdot}
    % \alternative{\Sigma_e, x \ty t_e}
  \end{syntax}

  \caption{Syntax of Kinds and Types}
  \label{fig:types}
\end{figure}

\todo Figure out which typing rules to include. Further ones which could be removed as they are standard: Fun, Rec, App, Abs, AppTy
\begin{figure}
\begin{mathparpagebreakable}
  \infer[Done]{\chorkinded{\Gamma}{\ell}{*_\ell} \\
    \localtyped{\proj{\Gamma}{\Locations}}{\proj{\Sigma}{_\ell}}{e}{t_e}}
  {\chortyped{\Gamma}{\Delta}{\Sigma}{\ell.e}{t_e @ \ell}}
  \and
  \infer[Fun]{\chortyped{\Gamma}{\Delta, F \ty \tau_1 \to \tau_2, X \ty \tau_1}{\Sigma}{C}{\tau_2}}
  {\chortyped{\Gamma}{\Delta}{\Sigma}{\Fun{F}{X\ty\tau_1}{C}}{\tau_1 \to \tau_2}}
  \and
%  \infer[Rec]{\chortyped{\Gamma}{\Delta,X \ty \tau}{\Sigma}{C}{\tau}}
%  {\chortyped{\Gamma}{\Delta}{\Sigma}{\mu X \ty \tau_1.C}{\tau}}
%  \and
%  \infer[App]{\chortyped{\Gamma}{\Delta}{\Sigma}{F}{\tau_1 \to \tau_2} \\
%    \Gamma \vdash C : \tau_1}
%  {\Gamma \vdash F~C : \tau_2}
%  \and
  \infer[Send]{\chorkinded{\Gamma}{\ell_1}{*_\ell} \\
    \chorkinded{\Gamma}{\ell_2}{*_\ell} \\\\
    \chortyped{\Gamma}{\Delta}{\Sigma}{C}{t_e @ \ell_1}}
    {\chortyped{\Gamma}{\Delta}{\Sigma}{C \ChorSend[\ell_1] \ell_2}{t_e @ \ell_2}}
  \and
  \infer[Sync]{\chorkinded{\Gamma}{\ell_1}{*_\ell} \\
    \chorkinded{\Gamma}{\ell_2}{*_\ell} \\\\
    \chortyped{\Gamma}{\Delta}{\Sigma}{C}{\tau}}
    {\chortyped{\Gamma}{\Delta}{\Sigma}{\syncs{\ell_1}{d}{\ell_2} \seq C}{\tau}}
  \and
  \infer[TAbs]{
    \kappa \neq *_s \\
    \chorkinded{\Gamma, \alpha \knd \kappa}{\tau}{*} \\\\
    \chortyped{\Gamma, \alpha \knd \kappa}{\Delta}{\Sigma}{C}{\tau}}
  {\chortyped{\Gamma}{\Delta}{\Sigma}{\TFun{\alpha \knd \kappa}{C}}{\forall \alpha \knd \kappa.\tau}}

  \infer[TApp]{\chortyped{\Gamma}{\Delta}{\Sigma}{C}{\forall \alpha \knd \kappa.\tau} \\\\
    \chorkinded{\Gamma}{t}{\kappa}}
  {\chortyped{\Gamma}{\Delta}{\Sigma}{C~t}{\subst{\tau}{\alpha}{t}}}
  \and
  \infer[DefLocal]{\chortyped{\Gamma}{\Delta}{\Sigma}{C_1}{t_e @ \ell} \\
    \chortyped{\Gamma}{\Delta}{\Sigma, \ell.x \ty t_e}{C_2}{\tau}}
  {\chortyped{\Gamma}{\Delta}{\Sigma}{\LetIn{\ell.x \ty t_e}{C_1}{C_2}}{\tau}}
  \and
  \infer[TellLetLoc]{
    \chorkinded{\Gamma}{\rho}{*_s} \\
    \chorkinded{\Gamma}{\tau}{*} \\\\
    \chortyped{\Gamma}{\Delta}{\Sigma}{C_1}{\Loc @ \ell} \\
    \chortyped{\Gamma, \alpha \knd *_\ell}{\Delta}{\Sigma}{C_2}{\tau} \\
    }
  {\chortyped{\Gamma}{\Delta}{\Sigma}{\LetTellIn{\alpha \knd *_\ell}{\ell}{C_1}{\rho}{C_2}}{\tau}} \and
\end{mathparpagebreakable}

  \caption{Selected Typing Rules}
  \label{fig:selected-type-rules}
\end{figure}

Parametric polymorphism is handled in a manner identical to System F: one can introduce a type variable using the \emph{type abstraction} expression $\TFun{\alpha \knd \kappa}{C}$, where $\kappa$ can be any of the four kinds.
The bound type-variable $\alpha$ can then be used in the body of the abstraction, as in the term $\TFun{\alpha \knd *_\ell}{C \ChorSend[L] \alpha}$ which sends a value $C : t_e @ L$ to an arbitrary location $\alpha$.

The tell-let binding allows for dynamically generated location names and local types to be used in the choreographic program.
Specifically, if $C_1 \ty \Loc @ \ell$ is a location name stored at $\ell$, then the expression $\LetTellIn{\alpha \knd *_\ell}{\ell}{C_1}{\rho}{C_2}$ allows the \emph{type variable} $\alpha \knd *_\ell$ to be used in the subexpression $C_2$.
One needs to be careful in creating a typing rule for this expression; implementing it na\"ively can introduce unsoundness or a dependency of types on values into the type system.
Specifically, while the subexpression $C_2$ may use the newly bound location, its type may not depend on it, as reflected in the rule \textsc{TellLetLoc}.

\ethan{Might want to move this higher up since it's our major innovation.}
\ashley{If possible I want to work in talking about existential types for one sentence here as that's where the idea came from}

\begin{thm}[Relative Preservation]
  \label{thm:relative-pres}
  If the local type system enjoys \textsc{Preservation}, \textsc{Location Invertability}, and \textsc{Type Invertability}, then for every choreography $C_1$ such that $\chortyped{\Gamma}{\Delta}{\Sigma}{C_1}{\tau}$ and $C_1 \step{R} C_2$, we have that $\chortyped{\Gamma}{\Delta}{\Sigma}{C_2}{\tau}$.
\end{thm}

\begin{thm}[Relative Progress]
  \label{thm:relative-prog}
  If the local type system enjoys \textsc{Boolean Invertability}, \textsc{Location Invertability}, \textsc{Type Invertability}, and \textsc{Progress}, then for every choreography $C_1$ such that $\choremptyped{C_1}{\tau}$, either $C_1$ is a choreography value or there is some $R$ and $C_2$ such that $C_1 \step{R} C_2$.
\end{thm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
