% Notes
\newcommand{\newcommenter}[3]{%
  \ifdraft
    \newcommand{#1}[1]{%
      \textcolor{#2}{\small\textsf{[#3: {##1}]}}%
    }%
  \else
    \newcommand{#1}[1]{\ignorespaces}
  \fi
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\definecolor{navy}{rgb}{0, 0, 0.5}
\newcommenter{\akh}{purple}{AKH}
\newcommenter{\ethan}{darkgreen}{Ethan}
\newcommenter{\ashley}{navy}{Ashley}

\newcommand{\programfont}[1]{\ensuremath{\mathsf{#1}}\xspace}
\makeatletter
% This recursively parses a list of pairs of arguments.
% The use if `\_nil` on the end creates a termiator so that #3 grabs all of the
% rest of the arguments, not just the first one. That means that #3 may be a
% sequence of groupings that will be interpreted as separate arguments in a
% recursive call. Each call processes the first two arguments and then, if
% there are any left, inserts a comma and processes the rest.
\def\subst@inner#1#2#3\_nil{#1 \mapsto #2\ifx\relax#3\relax\else,\mkern2mu\subst@inner#3\_nil\fi}%
% The core substitution typesetting command, using matchoice.
\newcommand{\raw@subst}[3]{
  \mathchoice{#1{\left[#2\subst@inner#3\_nil\right]}}
             {#1[#2\subst@inner#3\_nil]}
             {#1[#2\subst@inner#3\_nil]}
             {#1[#2\subst@inner#3\_nil]}%
}
\newcommand{\subst}[3]{\raw@subst{#1}{}{{#2}{#3}}}
\WithSuffix\newcommand\subst*[2]{\raw@subst{#1}{}{#2}}
\newcommand{\hsubst}[4]{\raw@subst{#1}{#2|}{{#3}{#4}}}
\WithSuffix\newcommand\hsubst*[3]{\raw@subst{#1}{#2|}{#3}}
\makeatother

\makeatletter
\newcommand{\narrowfill@}[5]{%
  $\m@th\thickmuskip0mu\medmuskip\thickmuskip\thinmuskip\thickmuskip
  \relax#5#1\mkern-7mu%
  \cleaders\hbox{$#5\mkern-2mu#2\mkern-2mu$}\hfill
  \mkern-5mu %
  #4%
  \mkern-5mu %
  \cleaders\hbox{$#5\mkern-2mu#2\mkern-2mu$}\hfill
  \mkern-7mu#3$%
}
\newcommand{\nRightarrowfill@}{%
  \narrowfill@\Relbar\Relbar\Rightarrow\neq
}
\newcommand*{\xnRightarrow}[2][]{%
  \ext@arrow 0359\nRightarrowfill@{#1}{#2}%
}
\makeatother

\newcommand{\ty}{\mkern2mu{:}\mkern2mu}
\newcommand{\knd}{\mkern2mu{::}\mkern2mu}
\newcommand{\proves}{\vdash}
\newcommand{\nproves}{\nvdash}
\newcommand{\dom}{\operatorname{dom}}
\newcommand{\sendsto}{\rightsquigarrow}
\newcommand{\tpat}{\raisebox{1pt}{\footnotesize\ensuremath{@}}}

\newcommand{\defeq}{\ensuremath{\stackrel{\text{\normalfont\tiny def}}{=}}}

\newcommand{\sayam}[1]{\text{``}#1\text{''}}
\newcommand{\sayjp}[1]{\ensuremath{\lceil#1\rfloor}}
\newcommand{\sayfr}[1]{\guillemotleft\text{#1}\guillemotright}
\newcommand{\say}[1]{\sayjp{#1}}
\newcommand{\quoteto}{\ensuremath{\mathrel{\say{\mathord{\to}}}}}

\newcommand{\Locations}{\ensuremath{\mathcal{L}}}

%% Types
\newcommand{\Int}{\programfont{int}}
\newcommand{\Bool}{\programfont{bool}}
\newcommand{\Typ}{\programfont{typ}}
\newcommand{\Loc}{\programfont{loc}}
\newcommand{\Empty}{\ensuremath{\mathbf{0}}}

\newcommand{\ChorCol}[1]{{\color{RoyalBlue}#1}}
%\newcommand{\ChorCol}[1]{#1}
\newcommand{\FontChoreo}[1]{\programfont{\ChorCol{#1}}}
%% Choreography Names
\newcommand{\seq}{\mathrel{;}}
%\newcommand{\ChorSend}[1][\loc]{\mathrel{\color{ChorColor}\sendsto}}
\newcommand{\ColSend}{\mathrel{\ChorCol{\sendsto}}}
\newcommand{\ChorSend}[1][\ell]{\mathchoice%
  {\mathrel{\raisebox{0.15ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-2mu\ChorCol{\sendsto}}}
  {\mathrel{\raisebox{0.15ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-2mu\ChorCol{\sendsto}}}
  {\mathrel{\mkern3mu\raisebox{0.1ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-1mu\ChorCol{\sendsto}}}
  {\mathrel{\mkern3mu\raisebox{0.05ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-1mu\ChorCol{\sendsto}}}%
}
\newcommand{\LetN}{\FontChoreo{let}}
\newcommand{\In}{\FontChoreo{in}}
\newcommand{\IfN}{\FontChoreo{if}}
\newcommand{\ThenN}{\FontChoreo{then}}
\newcommand{\ElseN}{\FontChoreo{else}}
\newcommand{\Left}{\FontChoreo{L}}
\newcommand{\Right}{\FontChoreo{R}}
\newcommand{\FunN}{\FontChoreo{fun}}
\newcommand{\ChorDef}{\mathrel{\ChorCol{\coloneqq}}}
\newcommand{\CtrlDef}{\mathrel{\ChorCol{\coloneqq}}}
\newcommand{\TellN}{\FontChoreo{tell}}
\newcommand{\To}{\FontChoreo{to}}

\newcommand{\LetIn}[3]{\LetN~{#1} \ChorDef {#2}~\In~{#3}}
\newcommand{\ITE}[4][\loc]{\IfN_{#1}~{#2}~\ThenN~{#3}~\ElseN~{#4}}
\newcommand{\Fun}[3]{\FunN~{#1}(#2) \ChorDef {#3}}
\newcommand{\Tell}[3][\loc]{{#1}.\TellN~{#2}~\To~{#3}}
\newcommand{\LetTellIn}[5]{\LetN~ {#1} \ChorDef \Tell[#2]{#3}{#4}~\In~{#5}}
\newcommand{\CtrlFail}{()}
\newcommand{\Ret}[1]{\text{ret}({#1})}
\newcommand{\SendTo}[2]{\text{send}~{#1}~\text{to}~{#2}}
\newcommand{\RecvFrom}[1]{\text{receive from}~{#1}}
\newcommand{\ChooseFor}[3]{\text{choose}~{#1}~\text{for}~{#2};~{#3}}
\newcommand{\AllowChoice}[3]{\text{allow}~{#1}~\text{choice}~(\Left \Rightarrow {#2})~(\Right \Rightarrow {#3})}
\newcommand{\LetRecvIn}[3]{\text{receive}~{#1}~\text{from}~{#2}~\In~{#3}}
\newcommand{\LetSendIn}[4]{\text{send}~{#1}~\CtrlDef~{#2}~\text{to}~{#3}~\In~{#4}}
\newcommand{\AmI}[3]{\text{AmI}~{#1}~\text{then}~{#2}~\text{else}~{#3}}
\newcommand{\CtrlSeq}[2]{{#1}\seq{#2}}
\newcommand{\IAm}[1]{\text{IAm}~{#1}}

\newcommand{\LocalLangFont}[1]{\programfont{#1}}
\newcommand{\True}{\LocalLangFont{true}}
\newcommand{\False}{\LocalLangFont{false}}

%% Example Names
\newcommand{\LocFont}[1]{\programfont{#1}}
\newcommand{\Client}{\LocFont{C}}
\newcommand{\Worker}{\LocFont{W}}
\newcommand{\Mngr}{\LocFont{M}}
\newcommand{\RunAtWorker}{\programfont{runAtW}}
\newcommand{\WithWorker}{\programfont{withWorker}}

% AMSThm Setup
\theoremstyle{theorem}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\theoremstyle{definition}
\newtheorem{defn}{Definition}
\newtheorem{ex}{Example}

% TODO
\newcommand{\todo}{\textcolor{red}{TODO}\xspace}

% Names
\newcommand{\langnameraw}{LangName}
\newcommand{\langname}{\textcolor{red}{\textlangle\textsc{\langnameraw}\textrangle}\xspace}
\newcommand{\pirouette}{Pirouette}

% Context Projection
\newcommand\proj[2]{\ensuremath{\left.#1\right|_{#2}}}

% Endpoint Projection
\newcommand\epp[2]{\ensuremath{\llbracket#1\rrbracket_{#2}}}

% Semantics
\newcommand{\minwidthbox}[2]{\makebox[{\ifdim#1<\width\width\else#1\fi}]{#2}}
\makeatletter
\newcommand{\raw@step}[3]{\mathrel{%
  \if\relax\detokenize{#1}\relax
    \Longrightarrow
  \else
    {\xRightarrow{\minwidthbox{1em}{\ensuremath{\scriptstyle#1}}}}{}
  \fi%
  \if\relax\detokenize{#2}\relax\else^{#2}\fi%
  \if\relax\detokenize{#3}\relax\else_{#3}\fi%
}}
\newcommand{\step}[1]{\raw@step{#1}{}{c}}
\newcommand{\manystep}{\raw@step{}{*}{c}}
\newcommand{\localstep}[1][]{\raw@step{#1}{}{e}}
\newcommand{\ctrlstep}[1][]{\raw@step{#1}{}{E}}

\newcommand{\raw@nstep}[3]{\mathrel{%
  \if\relax\detokenize{#1}\relax
    {\centernot{\Longrightarrow}}{}
  \else
    {\xnRightarrow{\minwidthbox{1em}{\ensuremath{\scriptstyle#1}}}}{}
  \fi%
  \if\relax\detokenize{#2}\relax\else^{#2}\fi%
  \if\relax\detokenize{#3}\relax\else_{#3}\fi%
}}
\newcommand{\nstep}[1]{\raw@nstep{#1}{}{c}}
\newcommand{\nlocalstep}[1][]{\raw@nstep{#1}{}{e}}
\makeatother

% Syntax
\newcommand\app[2]{\ensuremath{#1 \; #2}}
\newcommand\send[3]{\ensuremath{#1 \overset{#2}{\rightsquigarrow} #3}}
\newcommand\ifthen[3]{\ensuremath{\text{if}\; #1 \;\text{then}\; #2 \;\text{else}\; #3}}
\newcommand\letin[3]{\ensuremath{\text{let}\; #1 \;\coloneq \; #2 \;\text{in}\; #3}}

% Typing & kinding judgments
\newcommand\localkinded[2]{\ensuremath{#1 ~{\proves}_{\footnotesize{e}}~ #2}}
\newcommand\localtyped[4]{\ensuremath{#1;#2 ~{\proves}_{\footnotesize{e}}~ #3 \ty #4}}
\newcommand\localempkinded[1]{\ensuremath{{\proves}_{\footnotesize{e}}~ #1}}
\newcommand\localemptyped[2]{\ensuremath{{\proves}_{\footnotesize{e}}~ #1 \ty #2}}
\newcommand\localctxwf[2]{\ensuremath{#1 ~{\proves}_{\footnotesize{e}}~ #2}}
\newcommand\ctrlapp[2]{\ensuremath{#1 \; #2}}

\newcommand\chorkinded[3]{\ensuremath{#1 ~{\proves}~ #2 \knd #3}}
\newcommand\chortyped[5]{\ensuremath{#1;#2;#3 ~{\proves}~ #4 \ty #5}}
\newcommand\chorctxwf[2]{\ensuremath{#1 ~{\proves}~ #2}}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
