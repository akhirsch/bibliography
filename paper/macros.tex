% Notes
\newcommand{\newcommenter}[3]{%
  \ifdraft
    \newcommand{#1}[1]{%
      \textcolor{#2}{\small\textsf{[#3: {##1}]}}%
    }%
  \else
    \newcommand{#1}[1]{\ignorespaces}
  \fi
}
\definecolor{darkgreen}{rgb}{0,0.7,0}
\definecolor{navy}{rgb}{0, 0, 0.5}
\newcommenter{\akh}{purple}{AKH}
\newcommenter{\ethan}{darkgreen}{Ethan}
\newcommenter{\ashley}{navy}{Ashley}

\newcommand{\programfont}[1]{\ensuremath{\mathsf{#1}}\xspace}
\makeatletter
% This recursively parses a list of pairs of arguments.
% The use if `\_nil` on the end creates a termiator so that #3 grabs all of the
% rest of the arguments, not just the first one. That means that #3 may be a
% sequence of groupings that will be interpreted as separate arguments in a
% recursive call. Each call processes the first two arguments and then, if
% there are any left, inserts a comma and processes the rest.
\def\subst@inner#1#2#3\_nil{#1 \mapsto #2\ifx\relax#3\relax\else,\mkern2mu\subst@inner#3\_nil\fi}%
% The core substitution typesetting command, using matchoice.
\newcommand{\raw@subst}[3]{
  \mathchoice{#1{\left[#2\subst@inner#3\_nil\right]}}
             {#1[#2\subst@inner#3\_nil]}
             {#1[#2\subst@inner#3\_nil]}
             {#1[#2\subst@inner#3\_nil]}%
}
\newcommand{\subst}[3]{\raw@subst{#1}{}{{#2}{#3}}}
\WithSuffix\newcommand\subst*[2]{\raw@subst{#1}{}{#2}}
\newcommand{\hsubst}[4]{\raw@subst{#1}{#2|}{{#3}{#4}}}
\WithSuffix\newcommand\hsubst*[3]{\raw@subst{#1}{#2|}{#3}}
\makeatother

\makeatletter
\newcommand{\narrowfill@}[5]{%
  $\m@th\thickmuskip0mu\medmuskip\thickmuskip\thinmuskip\thickmuskip
  \relax#5#1\mkern-7mu%
  \cleaders\hbox{$#5\mkern-2mu#2\mkern-2mu$}\hfill
  \mkern-5mu %
  #4%
  \mkern-5mu %
  \cleaders\hbox{$#5\mkern-2mu#2\mkern-2mu$}\hfill
  \mkern-7mu#3$%
}
\newcommand{\nRightarrowfill@}{%
  \narrowfill@\Relbar\Relbar\Rightarrow\neq
}
\newcommand*{\xnRightarrow}[2][]{%
  \ext@arrow 0359\nRightarrowfill@{#1}{#2}%
}
\makeatother

\newcommand{\ty}{\mkern2mu{:}\mkern2mu}
\newcommand{\knd}{\mkern2mu{::}\mkern2mu}
\newcommand{\proves}{\vdash}
\newcommand{\nproves}{\nvdash}
\newcommand{\eproves}{\proves_{\mkern-2mu e}}
\newcommand{\dom}{\operatorname{dom}}
\newcommand{\sendsto}{\rightsquigarrow}
\newcommand{\tpat}{\raisebox{1pt}{\footnotesize\ensuremath{@}}}
\newcommand{\pn}[1]{\ensuremath{\text{PN}({#1})}}
\newcommand{\spn}[1]{\ensuremath{\text{SPN}({#1})}}
\newcommand{\fv}[1]{\ensuremath{\text{FV}({#1})}}

\newcommand{\defeq}{\ensuremath{\stackrel{\text{\normalfont\tiny def}}{=}}}

\newcommand{\sayam}[1]{\text{``}#1\text{''}}
\newcommand{\sayjp}[1]{\ensuremath{\lceil#1\rfloor}}
\newcommand{\sayfr}[1]{\guillemotleft\text{#1}\guillemotright}
\newcommand{\say}[1]{\sayjp{#1}}
\newcommand{\quoteto}{\ensuremath{\mathrel{\say{\mathord{\to}}}}}

\newcommand{\Locations}{\ensuremath{\mathcal{L}}}

%% Types
\newcommand{\Int}{\programfont{int}}
\newcommand{\Bool}{\programfont{bool}}
\newcommand{\Typ}{\programfont{typ}}
\newcommand{\Loc}{\programfont{loc}}
\newcommand{\Empty}{\ensuremath{\mathbf{0}}}

\newcommand{\ChorCol}[1]{{\color{RoyalBlue}#1}}
%\newcommand{\ChorCol}[1]{#1}
\newcommand{\FontChoreo}[1]{\programfont{\ChorCol{#1}}}
%% Choreography Names
\newcommand{\seq}{\mathrel{;}}
%\newcommand{\ChorSend}[1][\loc]{\mathrel{\color{ChorColor}\sendsto}}
\newcommand{\ColSend}{\mathrel{\ChorCol{\sendsto}}}
\newcommand{\ChorSend}[1][\ell]{\mathrel{\mathchoice%
  {\raisebox{0.15ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-2mu\ChorCol{\sendsto}}
  {\raisebox{0.15ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-2mu\ChorCol{\sendsto}}
  {\mkern3mu\raisebox{0.1ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-1mu\ChorCol{\sendsto}}
  {\mkern3mu\raisebox{0.05ex}{$\scriptstyle\ChorCol{\{}#1\ChorCol{\}}$}\mkern-1mu\ChorCol{\sendsto}}%
}}
\newcommand{\syncs}[3]{{#1}\ChorCol{[}{#2}\ChorCol{]} \mathrel{\ChorCol{\sendsto}} {#3}}
\newcommand{\LetN}{\FontChoreo{let}}
\newcommand{\In}{\FontChoreo{in}}
\newcommand{\IfN}{\FontChoreo{if}}
\newcommand{\ThenN}{\FontChoreo{then}}
\newcommand{\ElseN}{\FontChoreo{else}}
\newcommand{\Left}{\FontChoreo{L}}
\newcommand{\Right}{\FontChoreo{R}}
\newcommand{\FunN}{\ChorCol{\lambda}}
\newcommand{\TFunN}{\ChorCol{\Lambda}}
\newcommand{\ChorDef}{\mathrel{\ChorCol{\coloneqq}}}
%\newcommand{\CtrlDef}{\mathrel{\ChorCol{\coloneqq}}}
\newcommand{\TellN}{\FontChoreo{tell}}
\newcommand{\To}{\FontChoreo{to}}

\newcommand{\LetIn}[3]{\LetN~{#1} \ChorDef {#2}~\In~{#3}}
\newcommand{\ITE}[4][\ell]{\IfN_{#1}~{#2}~\ThenN~{#3}~\ElseN~{#4}}
\newcommand{\Fun}[2]{\FunN{#1}\ldotp {#2}}
\newcommand{\Rec}[2]{\ChorCol{\mu}{#1}\ldotp {#2}}
\newcommand{\TFun}[2]{\TFunN{#1}\ldotp {#2}}
\newcommand{\Tell}[3][\loc]{{#1}.\TellN~{#2}~\To~{#3}}
\newcommand{\LetTellIn}[5]{\LetN~ {#1} \ChorDef \Tell[#2]{#3}{#4}~\In~{#5}}

%% Control Language
\newcommand{\CtrlCol}[1]{{\color{RedOrange}#1}}
\newcommand{\FontCtrl}[1]{\mathtt{\CtrlCol{#1}}}

\newcommand{\CtrlDef}{\mathrel{\CtrlCol{\coloneqq}}}
\newcommand{\CtrlIn}{\FontCtrl{in}}
\newcommand{\CtrlLeft}{\FontCtrl{L}}
\newcommand{\CtrlRight}{\FontCtrl{R}}

\newcommand{\CtrlLetIn}[3]{\FontCtrl{let}~{#1} \CtrlDef {#2}~\FontCtrl{in}~{#3}}
\newcommand{\CtrlITE}[3]{\FontCtrl{if}~{#1}~\FontCtrl{then}~{#2}~\FontCtrl{else}~{#3}}

\newcommand{\CtrlFail}{()}
\newcommand{\Ret}[1]{\FontCtrl{ret}({#1})}
\newcommand{\SendTo}[2]{\FontCtrl{send}~{#1}~\FontCtrl{to}~{#2}}
\newcommand{\RecvFrom}[1]{\FontCtrl{receive}~\FontCtrl{from}~{#1}}
\newcommand{\ChooseFor}[3]{\FontCtrl{choose}~{#1}~\FontCtrl{for}~{#2};~{#3}}
\newcommand{\AllowChoice}[3]{\FontCtrl{allow}~{#1}~\FontCtrl{choice} \mid \CtrlLeft \Rightarrow {#2} \mid \CtrlRight \Rightarrow {#3}}
\WithSuffix\newcommand\AllowChoice*[2]{\FontCtrl{allow}~{#1}~\FontCtrl{choice} \mid d \Rightarrow {#2}}
\newcommand{\LetRecvIn}[3]{\FontCtrl{receive}~{#1}~\FontCtrl{from}~{#2}~\CtrlIn~{#3}}
\newcommand{\LetSendIn}[4]{\FontCtrl{send}~{#1}~\CtrlDef~{#2}~\FontCtrl{to}~{#3}~\CtrlIn~{#4}}
\newcommand{\AmI}[3]{\FontCtrl{AmI}~{#1}~\FontCtrl{then}~{#2}~\FontCtrl{else}~{#3}}
\newcommand{\CtrlSeq}[2]{{#1}\seq{#2}}
\newcommand{\IAm}[1]{\text{IAm}~{#1}}

\newcommand{\LocalLangFont}[1]{\programfont{#1}}
\newcommand{\True}{\LocalLangFont{true}}
\newcommand{\False}{\LocalLangFont{false}}

%% Example Names
\newcommand{\LocFont}[1]{\programfont{#1}}
\newcommand{\Client}{\LocFont{C}}
\newcommand{\Worker}{\LocFont{W}}
\newcommand{\Mngr}{\LocFont{M}}
\newcommand{\RunAtWorker}{\programfont{runAtW}}
\newcommand{\WithWorker}{\programfont{withWorker}}

% AMSThm Setup
\theoremstyle{theorem}
\newtheorem{thm}{Theorem}
\newtheorem{lem}{Lemma}
\newtheorem{cor}{Corollary}
\theoremstyle{definition}
\newtheorem{defn}{Definition}
\newtheorem{ex}{Example}

% TODO
\newcommand{\todo}{\textcolor{red}{TODO}\xspace}

% Names
\newcommand{\langnameraw}{LangName}
\newcommand{\langname}{\textcolor{red}{\textlangle\textsc{\langnameraw}\textrangle}\xspace}
\newcommand{\pirouette}{Pirouette}

% Context Projection
\newcommand\proj[2]{\ensuremath{\left.#1\right|_{#2}}}

% Endpoint Projection
\newcommand\epp[2]{\ensuremath{\llbracket#1\rrbracket_{#2}}}

% Semantics
\newcommand{\minwidthbox}[2]{\makebox[{\ifdim#1<\width\width\else#1\fi}]{#2}}
\makeatletter
\newcommand{\raw@step}[3]{\mathrel{%
  \if\relax\detokenize{#1}\relax
    \Longrightarrow
  \else
    {\xRightarrow{\minwidthbox{1em}{\ensuremath{\scriptstyle#1}}}}{}
  \fi%
  \if\relax\detokenize{#2}\relax\else^{#2}\fi%
  \if\relax\detokenize{#3}\relax\else_{#3}\fi%
}}
\newcommand{\step}[1]{\raw@step{#1}{}{c}}
\newcommand{\manystep}{\raw@step{}{*}{c}}
\newcommand{\localstep}[1][]{\raw@step{#1}{}{e}}
\newcommand{\ctrlstep}[1][]{\raw@step{#1}{}{E[L]}}
\newcommand{\rewrite}{\Rrightarrow}

\newcommand{\raw@nstep}[3]{\mathrel{%
  \if\relax\detokenize{#1}\relax
    {\centernot{\Longrightarrow}}{}
  \else
    {\xnRightarrow{\minwidthbox{1em}{\ensuremath{\scriptstyle#1}}}}{}
  \fi%
  \if\relax\detokenize{#2}\relax\else^{#2}\fi%
  \if\relax\detokenize{#3}\relax\else_{#3}\fi%
}}
\newcommand{\nstep}[1]{\raw@nstep{#1}{}{c}}
\newcommand{\nlocalstep}[1][]{\raw@nstep{#1}{}{e}}
\makeatother

% Syntax
\newcommand\app[2]{\ensuremath{#1 ~ #2}}
\newcommand\send[3]{#1 \ChorSend[#2] #3}

% Typing & kinding judgments
\newcommand\localkinded[2]{\ensuremath{#1 \eproves #2}}
\newcommand\localtyped[4]{\ensuremath{#1;#2 \eproves #3 : #4}}
\newcommand\localempkinded[1]{\ensuremath{\eproves #1}}
\newcommand\localemptyped[2]{\ensuremath{\eproves #1 : #2}}
\newcommand\localctxwf[2]{\ensuremath{#1 \eproves #2}}
\newcommand\ctrlapp[2]{\ensuremath{#1 \; #2}}

\newcommand\chorkinded[3]{\ensuremath{#1 \proves #2 :: #3}}
\newcommand\chortyped[5]{\ensuremath{#1;#2;#3 \proves #4 : #5}}
\newcommand\choremptyped[2]{\ensuremath{\proves #1 : #2}}
\newcommand\chorctxwf[2]{\ensuremath{#1 \proves #2}}


%% Redices
\newcommand{\RDone}[3]{{#1}.({#2} \Rightarrow {#3})}
\newcommand{\RArg}[1]{\text{Arg}({#1})}
\newcommand{\RFun}[1]{\text{Fun}({#1})}
\newcommand{\RApp}{\text{App}}
\newcommand{\RSend}[2]{{#1} \ChorSend[#2]}
\newcommand{\RSendV}[3]{{#1}.{#2} \sendsto {#3}}
\newcommand{\RSync}[3]{{#1}[{#2}] \sendsto {#3}}
\newcommand{\RIf}[2]{\text{if}_{#1}~{#2}}
\newcommand{\RIfTrue}[1]{\text{if}_{#1}~\True}
\newcommand{\RIfFalse}[1]{\text{if}_{#1}~\False}
\newcommand{\RTFun}[1]{\text{TFun}({#1})}
\newcommand{\RTApp}{\text{TApp}}
\newcommand{\RLet}[2]{\LetN~{#1} \ChorDef {#2}}
\newcommand{\RTellLet}[3]{\Tell[#1]{#2}{#3}}
\newcommand{\RRec}{\text{Rec}}

\newcommand{\rloc}[1]{\text{loc}({#1})}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End: