\subsection{Control Language}
\label{sec:control-lang}
The syntax of our control language, presented in Figure~\ref{fig:control-lang-syntax}, closely mirrors the control language of Pirouette, with additions to account for the new features that we have added.
The control language is a concurrent $\lambda$-calculus where messages are values from the local language.

Identically to choreographies, control program variables are written in uppercase Latin characters ($X,Y,F,\ldots$) and local program variables written in lowercase Latin characters ($x,y,f,\ldots$).
While the control language is un-typed, it reflects types in the syntax, and includes both control program and local type variables with lowercase Greek characters ($\alpha,\beta,\ldots$).

When control programs finish execution, they can return the result of a local program via the return-expression $\Ret{e}$.
Alternatively they can yield a trivial value $\CtrlFail$ to indicate that they have no return value.
This can happen when a given location does not participate in some part of the overall choreography.

Functions and type-abstraction in the control language, written $\CtrlFun{F}{X}{E}$ and $\CtrlTFun{\alpha}{E}$, mirror the corresponding choreographic constructs.
Likewise, the control program let-expression $\CtrlLetIn{X}{E_1}{E_2}$ and sequencing operator $E_1 \CtrlSeq E_2$ are standard.
The let-expression can also be used in the form $\CtrlLetIn{\Ret{x}}{E_1}{E_2}$ to bind local program variables, mirroring the local-let expressions of choreographies.

The send $\SendTo{E}{\rho}$ and receive $\RecvFrom{\ell}$ expressions allow control programs to send a message to a set of locations $\rho$, and receive a message from the location $\ell$, respectively, and utilize the value in further computation.

There are three different branching constructs in the control language.
The if-then-else expression $\CtrlITE{E}{E_1}{E_2}$ is a standard branching construct, and allows a location to branch their control program based on the result of a local computation.

The \emph{external choice} expression $\AllowChoice{\ell}{?E_1}{?E_2}$ is a form of branching in which the executing location will receive either $\Left$ or $\Right$ from $\ell$ to indicate which branch to take.
The question-marks prepended to the expressions $?E_1$ and $?E_2$ indicate that these branches may be absent from the control program, which will be denoted by the value $\CtrlNone$.
A branch may be missing as a result of the endpoint projection process, but does not necessitate that the control program will fail to execute.
The other side of an external choice is the choose-for expression $\ChooseFor{d}{\ell}{E}$, in which the executing location informs $\ell$ to branch in the direction $d$, after which execution resumes on $E$.

%Lastly, the ``am-I-in'' expression $\AmIIn{\rho}{E_1}{E_2}$ is a form of local branching which reflects the currently executing location's knowledge of its own identity.
Specifically, when executing at a location $L$, if $L \in \rho$ then the left branch $E_1$ will be taken, and if $L \notin \rho$ then the right branch $E_2$ will be taken.
This is a generalization of the ``AmI'' expression of PolyChor$\lambda$~\citep{GraversenHM23}, and is critical in order to implement location polymorphism and the usage of dynamically generated locations.

\begin{figure}
  \begin{syntax}
    \category[Control Expression]{E}
    \alternative{X} \alternative{\CtrlFail} \alternative{\Ret{e}} \alternative{E_1 \CtrlSeq E_2} \\
    \alternative{\CtrlFun{F}{X}{E}} \alternative{E_1~E_2} \\
    \alternative{\CtrlTFun{\alpha}{E}} \alternative{E~t} \\
    \alternative{\SendTo{E}{\rho}} \alternative{\RecvFrom{\ell}} \\
    \alternative{\ChooseFor{d}{\ell}{E}} \\
    \alternative{\AllowChoice{\ell}{?E_1}{?E_2}} \\
    \alternative{\CtrlITE{E}{E_1}{E_2}} \\
    \alternative{\CtrlLetIn{X}{E_1}{E_2}}\\
    \alternative{\CtrlLetIn{\Ret{x}}{E_1}{E_2}}\\
%    \alternative{\LetSendIn{\alpha}{E_1}{\rho}{E_2}} \alternative{\LetRecvIn{\alpha}{\ell}{E}}\\
%    \alternative{\LetSendIn{\alpha \knd *_e}{E_1}{\rho}{E_2}} \alternative{\LetRecvIn{\alpha \knd *_e}{\ell}{E}}\\
    \alternative{\AmIIn{\rho}{E_1}{E_2}}

    \category[Control Expression Values]{V}
    \alternative{\CtrlFail} \alternative{\Ret{v}} \alternative{\CtrlFun{F}{X}{E}}
    \alternative{\CtrlTFun{\alpha}{E}}

    % \category[Possible Control Expression]{?E}
    % \alternative{\CtrlNone}
    % \alternative{E}

    \abstractCategory[Systems]{\Pi}
  \end{syntax}

  \caption{Control Expressions}
  \label{fig:control-lang-syntax}
\end{figure}

\paragraph{Operational Semantics}
\label{sec:control-lang-semantics}
\ethan{Fix this}
We give the control language an operational semantics via a labeled transition system $E_1 \ctrlstep[l] E_2$, where $l$ is the label, and $L$ is the location at which the control program is executing.
Specifically, we have reduction rules of the form $E_1 \ctrlstep[l] E_2$ which can be applied using structural congruence rules given by a set of evaluation contexts $\eta$.

\begin{syntax}
  \category[Labels]{l}
  \alternative{\iota} \alternative{[d] \sendsto L} \alternative{L;[d] \sendsto}  \alternative{v \sendsto \rho} \alternative{L;\rho \sendsto} 

  \category[Evaluation Contexts]{\eta}
  \alternative{\hole \CtrlSeq E} \alternative{\hole~E}\alternative{E~\hole} \alternative{\hole~t} \\
  \alternative{\SendTo{\hole}{L}} \\
  \alternative{\CtrlITE{\hole}{E_1}{E_2}} \\
  \alternative{\CtrlLetIn{\Ret{x}}{\hole}{E}} \\
  \alternative{\LetSendIn{\alpha \knd \kappa}{\hole}{\rho}{E}}
\end{syntax}

\begin{mathparpagebreakable}
    \infer[]{
      L \triangleright E_1 \ctrlstep[l] E_2
    }{L \triangleright \eta[E_1] \ctrlstep[l] \eta[E_2]}
    \and
    \infer[RetE]{e_1 \localstep e_2}
    {L \triangleright \Ret{e_1} \ctrlstep[\iota] \Ret{e_2}}
    \and
    \infer[SeqV]{\text{Value}(V)}
    {L \triangleright V \CtrlSeq E \ctrlstep[\iota] E}
    \and
    \infer[App]{
      f = \CtrlFun{F}{X}{E} \\
      \text{Value}(V)
    }{L \triangleright f~V \ctrlstep[\iotasync] \subst*{E}{{F}{f}{X}{V}}}
    \and
    \infer[SendV]{\text{Value}(v) \\
      L' \neq L}
    {L \triangleright \SendTo{\Ret{v}}{L'} \ctrlstep[v \sendsto L'] \CtrlFail}
    \and
    \infer[Recv]{\text{Value}(v) \\
      L' \neq L}
    {L \triangleright \RecvFrom{L'} \ctrlstep[L';v \sendsto] \Ret{v}}
    \and
    \infer[Choose]{L' \neq L}
    {L \triangleright \ChooseFor{d}{L'}{E} \ctrlstep[d \sendsto L'] E}
    \and
    \infer[AllowChoiceL]{L' \neq L}
    {L \triangleright \AllowChoice{L'}{E_1}{E_2} \ctrlstep[L';\Left \sendsto] E_1}
    \and
    \infer[AllowChoiceR]{L' \neq L}
    {L \triangleright \AllowChoice{L'}{E_1}{E_2} \ctrlstep[L';\Right \sendsto] E_2}
    \and
    \infer[IfT]{ }
    {L \triangleright \CtrlITE{\Ret{\True}}{E_1}{E_2} \ctrlstep[\iota] E_1}
    \and
    \infer[IfF]{ }
    {L \triangleright \CtrlITE{\Ret{\False}}{E_1}{E_2} \ctrlstep[\iota] E_2}
    \and
    \infer[AppT]{ }
    {L \triangleright (\CtrlTFun{\alpha}{E})~t \ctrlstep[\iotasync] \subst{E}{\alpha}{t}}
    \and
    \infer[LetRetV]{\text{Value}(v)}
    {L \triangleright \CtrlLetIn{\Ret{x}}{\Ret{v}}{E} \ctrlstep[\iota] \subst{E}{x}{v}}
    \and
    \infer[SendTyV]{ }
    {L \triangleright \LetSendIn{\alpha \knd \kappa}{\Ret{\say{t}}}{\rho}{E} \ctrlstep[t \sendsto \rho] \subst{E}{\alpha}{t}}
    \and
    \infer[RecvTy]{L' \neq L}
    {L \triangleright \LetRecvIn{\alpha \knd \kappa}{L'}{E} \ctrlstep[L';t \sendsto] \subst{E}{\alpha}{t}}
    \and
    \infer[AmIL]{L \in \rho}
    {L \triangleright \AmIIn{\rho}{E_1}{E_2} \ctrlstep[\iota] E_1}
    \and
    \infer[AmIR]{L \notin \rho}
    {L \triangleright \AmIIn{\rho}{E_1}{E_2} \ctrlstep[\iota] E_2}
\end{mathparpagebreakable}

\paragraph{Control Systems}
\label{sec:system-semantics}
We can compose control programs in parallel over each location as a \emph{system}.
A system, denoted as $\Pi$, is a map from each location $L \in \Locations$ to the control program $\Pi(L)$ which it is currently executing.
The \emph{system update} $\subst{\Pi}{L}{E}$ is $\Pi$ with $\Pi(L)$ replaced by $E$, and the control program at every other location unchanged:
\begin{mathpar}
  \subst{\Pi}{L}{E}(L') \defeq
    \begin{cases}
      E & L = L'\\
      \Pi(L') & L \neq L'
    \end{cases}
\end{mathpar}
Likewise the multiple system update $\subst{\Pi}{\rho}{\Pi'}$ is $\Pi$ with $\Pi(L)$ replaced by $\Pi'(L)$ for each $L \in \rho$, and other locations unchanged.
\begin{mathpar}
  \subst{\Pi}{\rho}{\Pi'}(L) \defeq
    \begin{cases}
      \Pi'(L) & L \in \rho\\
      \Pi(L) & L \notin \rho
    \end{cases}
\end{mathpar}

We can lift the control language semantics to a semantics for systems by asking that a subset of locations make a step, and that the labels used in these steps ``match''.
This system semantics is also labeled, with system labels $l_S$ shown in Figure \ref{fig:system-semantics}.
While the control program labels only show one side of a send or receive, the system labels reflect both sides, and the semantics of the system ensure that the sender and receiver agree on the content of a message.

\begin{figure}
  \begin{syntax}
    \category[System Label]{l_S}
    \alternative{\iota} \alternative{\iotasync} \alternative{L;v \sendsto \rho} \alternative{L_1;d \sendsto L_2}
  \end{syntax}
  \textbf{System Steps}
  \begin{mathpar}
    \infer[Internal]{L \triangleright \Pi(L) \ctrlstep[\iota] E}
    {\Pi \systemstep[\iota] \subst{\Pi}{L}{E}}
    \and
    \infer[Synchronized Internal]{
      \forall L \in \Locations\ldotp \Big(L \triangleright \Pi(L) \ctrlstep[\iotasync] \Pi'(L)\Big)}
    {\Pi \systemstep[\iotasync] \Pi'}
    \and
    \infer[Comm]{
      L \triangleright \Pi(L) \ctrlstep[v \sendsto \rho] \Pi'(L) \\
      \forall L' \in \rho \setminus L\ldotp \Big(L' \triangleright \Pi(L') \ctrlsteploc[L;v \sendsto]{L'} \Pi'(L')\Big) \\
      \forall L' \notin \rho \cup \{L\} \ldotp \Pi(L') = \Pi'(L')
%      \Pi(L_1) \ctrlsteploc[v \sendsto L_2]{L_1} E_1 \\
%      \Pi(L_2) \ctrlsteploc[L_1;v \sendsto]{L_2} E_2
    }{\Pi \systemstep[L;v \sendsto \rho] \Pi'}
    \and
    \infer[Choice]{L_1 \neq L_2 \\
    L_1 \triangleright \Pi(L_1) \ctrlsteploc[d \sendsto L_2]{L_1} E_1 \\
    L_2 \triangleright \Pi(L_2) \ctrlsteploc[L_1;d \sendsto]{L_2} E_2}
    {\Pi \systemstep[L_1;d \sendsto L_2] \subst*{\Pi}{{L_1}{E_1}{L_2}{E_2}}}
%    \and
%    \infer[CommTy]{\Pi(L_1) \ctrlsteploc[t \sendsto \rho]{L_1} E_1 \\
%    \forall L \in \rho \setminus L_1,~ \Pi(L) \ctrlstep[L_1;t \sendsto] \Pi'(L)}
%    {\Pi \systemstep[L_1;t \sendsto \rho] \subst*{\Pi}{{L_1}{E_1}{\rho}{\Pi'}}}
%    \and
  \end{mathpar}
  \caption{System Semantics}
  \label{fig:system-semantics}
\end{figure}

\subsection{Control Program Merging}
\label{sec:control-merge}
\todo Talk about merging operator 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
