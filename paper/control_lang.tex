\subsection{Control Language}
\label{sec:control-lang}

\todo purpose and design of control language

\todo explanation of AmI and reason it's needed

\begin{figure}
  \begin{syntax}
    \category[Control Expression]{E}
    \alternative{X} \alternative{\CtrlFail} \alternative{\Ret{e}} \alternative{E_1 \CtrlSeq E_2} \\
    \alternative{\CtrlFun{X}{E}} \alternative{E_1~E_2} \alternative{\CtrlRec{X}{E}} \\
    \alternative{\CtrlTFun{\alpha}{E}} \alternative{E~t} \\
    \alternative{\SendTo{E}{\rho}} \alternative{\RecvFrom{\ell}} \\
    \alternative{\ChooseFor{d}{\ell}{E}} \\
    \alternative{\AllowChoice{\ell}{?E_1}{?E_2}} \\
    \alternative{\CtrlITE{E}{E_1}{E_2}} \\
    \alternative{\CtrlLetIn{X}{E_1}{E_2}}\\
%    \alternative{\LetSendIn{\alpha}{E_1}{\rho}{E_2}} \alternative{\LetRecvIn{\alpha}{\ell}{E}}\\
%    \alternative{\LetSendIn{\alpha \knd *_e}{E_1}{\rho}{E_2}} \alternative{\LetRecvIn{\alpha \knd *_e}{\ell}{E}}\\
    \alternative{\AmI{\ell}{E_1}{E_2}}

    \category[Control Expression Values]{V}
    \alternative{\CtrlFail} \alternative{\Ret{v}} \alternative{\CtrlFun{X}{E}}
    \alternative{\CtrlTFun{\alpha}{E}}

    \category[Possible Control Expression]{?E}
    \alternative{\CtrlNone}
    \alternative{E}

    \abstractCategory[Systems]{\Pi}
  \end{syntax}

  \caption{Control Expressions}
  \label{fig:control-lang-syntax}
\end{figure}

\paragraph{Operational Semantics}
\label{sec:control-lang-semantics}
We give the control language an operational semantics via a labeled transition system $E_1 \ctrlstep[l] E_2$, where $l$ is the label, and $L$ is the location at which the control program is executing.
Specifically, we have reduction rules of the form $E_1 \ctrlreduce[l] E_2$ which can be applied using structural congruence rules given by a set of evaluation contexts $\eta$.

\begin{syntax}
  \category[Labels]{l}
  \alternative{\iota} \alternative{v \sendsto L} \alternative{L;v \sendsto} \alternative{d \sendsto L} \alternative{L;d \sendsto} \alternative{t \sendsto \rho} \alternative{L;t \sendsto}

  \category[Evaluation Contexts]{\eta}
  \alternative{\hole} \alternative{\eta \CtrlSeq E} \alternative{\eta~E}\alternative{E~\eta} \alternative{\eta~t} \\
  \alternative{\SendTo{\eta}{L}} \\
  \alternative{\CtrlITE{\eta}{E_1}{E_2}} \\
  \alternative{\CtrlLetIn{\Ret{x}}{\eta}{E}} \\
  \alternative{\LetSendIn{\alpha \knd \kappa}{\eta}{\rho}{E}}
\end{syntax}

\begin{mathparpagebreakable}
    \infer[]{E_1 \ctrlreduce[\iota] E_2}
    {\eta[E_1] \ctrlstep[\iota] \eta[E_2]}
    \and
    \infer[RetE]{e_1 \localstep e_2}
    {\Ret{e_1} \ctrlreduce[\iota] \Ret{e_2}}
    \and
    \infer[SeqV]{\text{Value}(V)}
    {V \CtrlSeq E \ctrlreduce[\iota] E}
    \and
    \infer[App]{\text{Value}(V)}
    {(\CtrlFun{X}{E})~V \ctrlreduce[\iotasync] \subst{E}{X}{V}}
    \and
    \infer[Rec]{~}
    {\mu X.E \ctrlreduce[\iotasync] \subst{E}{X}{\mu X.E}}
    \and
    \infer[SendV]{\text{Value}(v) \\
      L' \neq L}
    {\SendTo{\Ret{v}}{L'} \ctrlreduce[v \sendsto L'] \CtrlFail}
    \and
    \infer[Recv]{\text{Value}(v) \\
      L' \neq L}
    {\RecvFrom{L'} \ctrlreduce[L';v \sendsto] \Ret{v}}
    \and
    \infer[Choose]{L' \neq L}
    {\ChooseFor{d}{L'}{E} \ctrlreduce[d \sendsto L'] E}
    \and
    \infer[AllowChoiceL]{L' \neq L}
    {\AllowChoice{L'}{E_1}{E_2} \ctrlreduce[L';\Left \sendsto] E_1}
    \and
    \infer[AllowChoiceR]{L' \neq L}
    {\AllowChoice{L'}{E_1}{E_2} \ctrlreduce[L';\Right \sendsto] E_2}
    \and
    \infer[IfT]{~}
    {\CtrlITE{\Ret{\True}}{E_1}{E_2} \ctrlreduce[\iota] E_1}
    \and
    \infer[IfF]{~}
    {\CtrlITE{\Ret{\False}}{E_1}{E_2} \ctrlreduce[\iota] E_2}
    \and
    \infer[AppT]{~}
    {(\CtrlTFun{\alpha}{E})~t \ctrlreduce[\iotasync] \subst{E}{\alpha}{t}}
    \and
    \infer[LetRetV]{\text{Value}(v)}
    {\CtrlLetIn{\Ret{x}}{\Ret{v}}{E} \ctrlreduce[\iota] \subst{E}{x}{v}}
    \and
    \infer[SendTyV]{~}
    {\LetSendIn{\alpha \knd \kappa}{\Ret{\say{t}}}{\rho}{E} \ctrlreduce[t \sendsto \rho] \subst{E}{\alpha}{t}}
    \and
    \infer[RecvTy]{L' \neq L}
    {\LetRecvIn{\alpha \knd \kappa}{L'}{E} \ctrlreduce[L';t \sendsto] \subst{E}{\alpha}{t}}
    \and
    \infer[AmIL]{~}
    {\AmI{L}{E_1}{E_2} \ctrlreduce[\iota] E_1}
    \and
    \infer[AmIR]{L' \neq L}
    {\AmI{L'}{E_1}{E_2} \ctrlreduce[\iota] E_2} \and
\end{mathparpagebreakable}

\paragraph{Control Systems}
\label{sec:system-semantics}
We can compose control programs in parallel over each location as a \emph{system}.
In particular, a system $\Pi$ is a map from each location $\Locations$ to a control program.
For a given location $L \in \Locations$, the program that $L$ is running in the system $\Pi$ is denoted as $\Pi(L)$.
The \emph{system update} $\subst{\Pi}{L}{E}$ is $\Pi$ with $\Pi(L)$ replaced by $E$, and the control program at every other location unchanged:
\begin{mathpar}
  \subst{\Pi}{L}{E}(L') \defeq
    \begin{cases}
      E & L = L'\\
      \Pi(L') & L \neq L'
    \end{cases}
\end{mathpar}
Likewise the multiple system update $\subst{\Pi}{\rho}{\Pi'}$ is $\Pi$ with $\Pi(L)$ replaced by $\Pi'(L)$ for each $L \in \rho$, and other locations unchanged.
\begin{mathpar}
  \subst{\Pi}{\rho}{\Pi'}(L) \defeq
    \begin{cases}
      \Pi'(L) & L \in \rho\\
      \Pi(L) & L \notin \rho
    \end{cases}
\end{mathpar}

We can lift the control language semantics to a semantics for systems by asking that a subset of locations make a step, and that the labels used in these steps match.
This system semantics is also labeled, with system labels $l_S$ shown in Figure \ref{fig:system-semantics}.
While the control program labels only show one side of a send or receive, the system labels reflect both sides, and the semantics of the system ensure that the send and receive messages match.

\begin{figure}
  \begin{syntax}
    \category[System Label]{l_S}
    \alternative{\iota} \alternative{\iotasync} \alternative{L_1;v \sendsto L_2} \alternative{L_1;d \sendsto L_2} \alternative{L;t \sendsto \rho}
  \end{syntax}
  \textbf{System Steps}
  \begin{mathpar}
    \infer[Internal]{\Pi(L) \ctrlstep[\iota] E}
    {\Pi \systemstep[\iota] \subst{\Pi}{L}{E}}
    \and
    \infer[Synchronized Internal]{\forall L \in \Locations,~ \Pi(L) \ctrlstep[\iotasync] \Pi'(L)}
    {\Pi \systemstep[\iotasync] \Pi'}
    \and
    \infer[Comm]{L_1 \neq L_2 \\
    \Pi(L_1) \ctrlsteploc[v \sendsto L_2]{L_1} E_1 \\
    \Pi(L_2) \ctrlsteploc[L_1;v \sendsto]{L_2} E_2}
    {\Pi \systemstep[L_1;v \sendsto L_2] \subst*{\Pi}{{L_1}{E_1}{L_2}{E_2}}}
    \and
    \infer[Choice]{L_1 \neq L_2 \\
    \Pi(L_1) \ctrlsteploc[d \sendsto L_2]{L_1} E_1 \\
    \Pi(L_2) \ctrlsteploc[L_1;d \sendsto]{L_2} E_2}
    {\Pi \systemstep[L_1;d \sendsto L_2] \subst*{\Pi}{{L_1}{E_1}{L_2}{E_2}}}
    \and
    \infer[CommTy]{\Pi(L_1) \ctrlsteploc[t \sendsto \rho]{L_1} E_1 \\
    \forall L \in \rho \setminus L_1,~ \Pi(L) \ctrlstep[L_1;t \sendsto] \Pi'(L)}
    {\Pi \systemstep[L_1;t \sendsto \rho] \subst*{\Pi}{{L_1}{E_1}{\rho}{\Pi'}}}
    \and
  \end{mathpar}
  \caption{System Semantics}
  \label{fig:system-semantics}
\end{figure}

\subsection{Control Program Merging}
\label{sec:control-merge}
\todo Talk about merging operator 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
