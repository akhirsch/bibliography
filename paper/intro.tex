\section{Introduction}
\label{sec:introduction}

Distributed programs are an integral part of many modern software systems that allow for information to be transferred and computations to be performed between different nodes of a system.
Writing bug-free distributed programs is more difficult than in single-machine programs due to issues such as \emph{deadlock}, in which execution becomes stuck due to a mismatch in sends and receives between different nodes, and the inherent difficulty of representing computations spanning multiple locations.

\emph{Session types} solve this problem by describing and enforcing the pattern in which each individual participant will send and receive data.
However, session types can be difficult to work with as a separate program must be written for each participant, the entire system must be checked for mutual compatibility, and the participants must be fixed and statically known.

\emph{Choreographic programming} offers an alternative solution in which a single program is written to describe all interactions between nodes, and the program that each individual node will run is derived from this global program.
Such choreographic languages lead to \emph{deadlock freedom by design}, providing the programmer assurance that the system will never become stuck.
Currently, typed choreographic languages are typically functional and support higher-order types, but either do not support \emph{process polymorphism}, are not flexible enough to allow for an arbitrary language to be used for local computations, or cannot send \emph{dynamically computed process names}.
\ethan{Do any typed choreographies allow this?
  I thought the main argument was we're the only one.
  Symphony does it, but it doesn't have a type system.}
\ashley{Correct, I'm not aware of anyone else who does it while including a type system.}
This paper presents \langname, the first choreographic programming language which supports process polymorphism and dynamically generated process names over an arbitrary language of local computations.

To understand why choreographic programming is a useful paradigm,
consider a simple example in which a client \Client wishes to run a job on a dedicated worker \Worker.
The client has on their local system the code to calculate a computationally expensive function $F$, and an input $X$ on which they wish to evaluate the function.
If \Client wishes to run $F$ on a specific (statically known) worker \Worker,
it can run the following choreography where \Client sends $F$ and $X$ to \Worker, then \Worker computes $F~X$ locally, and sends the result back to \Client.
Note here, the syntax $t@\Client$ indicates a value of type $t$ located at \Client.
\begin{align*}
  \RunAtWorker & : (t \to t') @ \Client \to t@\Client \to t'@\Client \\
  \RunAtWorker &~F~X =
  \def\arraystretch{1.1}
  \begin{array}[t]{@{}l@{}}
    \LetN~\begin{array}[t]{@{}l@{}}
        \Worker.f \ChorDef F \ColSend \Worker \\
        \Worker.x \ChorDef X \ColSend \Worker \\
    \end{array} \\
    \In~\Worker.(f~x) \ColSend \Client
  \end{array}
\end{align*}
In the first line of this program, \Client first sends the function $F$ stored on its local system to \Worker via the expression $F \ColSend \Worker$.
This results in an expression with type $(t \to t') @ \Worker$, indicating that \Worker now has knowledge of this function.

The second action which occurs on the first line of the program is the \emph{local let-binding} $\LetN~\Worker.f \ChorDef F \ColSend \Worker$, in which \Worker binds the value of the function it recieved from \Worker to a \emph{local variable} $\Worker.f$, allowing it to be used in \emph{local computations}.

This construct is necessary as choreographic and local values cannot inter-mingle: choreographic values can only be used in a local expression by using a local let-binding, and local values can only be used in the choreographic program by using them at the location they belong to. For instance, if $N : \Int @ \ell$ is an integer stored at $\ell$, the choreography which represents $\ell$ locally adding 2 to $N$ is represented as the program $\LetN~\ell.n \ChorDef N ~\In~ \ell.(2 + n)$ which also has type $\Int @ \ell$.

The second line of the program similarly has \Client send the value $X$ to \Worker, who then binds it to the local variable $\Worker.x$.
The final line of the program performs two actions.
\Worker first applies $f$ to $x$ on its local system, represented by the expression $\Worker.(f~x)$.
Lastly \Worker yields the result of this computation to \Client, completing the program.
 
\ethan{I think we want to more heavily emphasize that this is not how real distributed systems work.}

We have so-far assumed that the worker location \Worker in this program is both fixed and statically-known.
What if, however, we wish for the identity of the worker location to be dynamically computed during the execution of the program?

For instance, consider a programmer who wishes to implement a thread pool.
In this process, the client \Client will ask a pool-manager \Mngr for the name of a location on which their task will run.
The manager can locally track the state of the thread pool, for instance by using a queue of idle processes, and allow clients to acquire the least-recently-used location by using a \emph{dynamically-computed} local function \programfont{acquireWorker}.
The programmer could implement the job-submission process using the following choreography:
\begin{align*}
  \WithWorker & : (\Int \to \Int) @ \Client \to \Int@\Client \to \Int@\Client \\
  \WithWorker & ~F~X =
  \def\arraystretch{1.1}
  \begin{array}[t]{@{}l@{}}
    \LetN~\begin{array}[t]{@{}l@{}}
      \Mngr.w \ChorDef \programfont{acquireWorker} \\
      W \ChorDef \Tell[\Mngr]{w}{\{\Client\} \cup \rho_w} \\
      W.f \ChorDef F \ColSend W \\
      W.x \ChorDef X \ColSend W \\
      \mathit{Res} \ChorDef W.(f~x) \ColSend \Client
    \end{array} \\
    \In~\programfont{releaseWorker}~M.w \seq \mathit{Res}
  \end{array}
\end{align*}

\ethan{This no longer matches the updated example}
\ashley{Updated}

\ashley{Explain the acquire worker function}
\ashley{Explain the second tell-let line in more detail. Emphasize this line, it's "the magic" which makes it work. Everything else in the program is seen in the first example.}
\ashley{See if we can add another ingredient to stop locations from accessing bound locations and types that they don't have access to}

On the first line of this program, the pool manager \Mngr first finds and selects an idle \textsf{worker} location $w$ from the pool $\rho_w$ of possible worker locations using the local \textsf{acquireWorker} function.
With this dynamically computed value, on the seond line \Mngr then \emph{tells} the identity of the location $w$ to the client \Client, where it is bound to the choreographic program variable $W$.
As well, all workers in the pool $\rho_w$ are notified about the identity of the chosen worker so that they know whether or not they have been selected.

As in the earlier \RunAtWorker function, the client then sends $F$ and $X$ to $W$, who then computes $F~X$ locally, and sends the result to \Client.
Finally, the manager releases the worker back into the thread pool, at which point the computation has finished.

The second line of this program, $W \ChorDef \Tell[\Mngr]{w}{\{\Client\} \cup \rho_w}$, is the main difference between this and the previous example, and is critical for the ability of \langname to be able to send and use dynamically generated location names.
This expression, called a \emph{tell-let} binding, allows for location names from the local language to be used within the subsequent choreographic program.
While it might appear that because the type of the choreography can depend on the value of the chosen location name, for instance with the type $\Int @ \Worker$, we disallow such \emph{dependent types} within our language while still allowing the value of the location to be used in the body of the program using the following typing rule.
\begin{mathpar}
  \infer[TellLetLoc]{\chortyped{\Gamma}{\Delta}{\Sigma}{C_1}{\Loc @ \ell} \\
    \chorkinded{\Gamma}{\rho}{*_s} \\
    \chorkinded{\Gamma}{\tau}{*} \\
    \chortyped{\Gamma, \alpha \knd *_\ell}{\Delta}{\Sigma}{C_2}{\tau} \\
    }
  {\chortyped{\Gamma}{\Delta}{\Sigma}{\LetTellIn{\alpha}{\ell}{C_1 \knd *_\ell}{\rho}{C_2}}{\tau}}
\end{mathpar}

\ashley{Useful to include the typing rule here?}

\paragraph{Contributions}
\begin{itemize}
	\item First choreographic programming language with dynamic location capabilities and a type system
    \ethan{We should be careful. One could argue Symphony did that, it just didn't have a type system.}
    \ashley{This could alsobe phrased semantically instead, i.e. Symphony can get stuck but we have progress}
	\item Process and type polymorphism over an arbitrary local language
	\item Out-of-order execution (with process polymorphism)
	\item System F versus System F$\omega$. We used a simpler type system for an analogous (and in some places more general) result. As well, it is(was!) an open question whether location polymorphism is possible in a choreographic language using System F. Maybe not possible in PolyChor style, but possible with Pirouette style (advantage of Pirouette style)
	\item Mechanical verification
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
