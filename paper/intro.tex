\section{Introduction}
\label{sec:introduction}

Distributed programs are an integral part of many modern software systems that allow for information to be transferred and computations to be performed between different nodes of a system.
Writing bug-free distributed programs is more difficult than in single-machine programs due to issues such as \emph{deadlock}, in which execution becomes stuck due to a mismatch in sends and receives between different nodes, and the inherent difficulty of representing computations spanning multiple locations.

\emph{Session types} solve this problem by describing and enforcing the pattern in which each individual participant will send and receive data.
However, session types can be difficult to work with as a separate program must be written for each participant, the entire system must be checked for mutual compatibility, and the participants must be fixed and statically known.

\emph{Choreographic programming} offers an alternative solution in which a single program is written to describe all interactions between nodes, and the program that each individual node will run is derived from this global program.
Such choreographic languages lead to \emph{deadlock freedom by design}, providing the programmer assurance that the system will never become stuck.
Currently, typed choreographic languages are typically functional and support higher-order types, but either do not support \emph{process polymorphism},
or are not flexible enough to allow for an arbitrary language to be used for local computations.
Moreover, the only existing typed choreography supporting process polymorphism does not allow \emph{dynamically computed process names}~\citep{aliceorbob}.
%Moreover, the only , or cannot send \emph{dynamically computed process names} in a manner which does not introduce deadlocks or stuck programs.
%\ashley{How about this wording?}
This paper presents \langname, the first typed choreographic programming language
supporting process polymorphism with dynamically computed process names.
\ethan{I think we should identify the main selling point of the paper and try not to muddy the water with other things too much.
  As I see it, ``we do typed process polymorphism with dynamic process names'' is th real winner here.
  It's definitely worth mentioning the other cool stuff we do, but I want to make sure we drive home that
  we wouldn't need anything else to be new and important.
  I tweaked the text a bit in that direction, but I probably went too far.}

To understand why choreographic programming is a useful paradigm,
consider a simple example in which a client \Client wishes to run a job on a dedicated worker \Worker.
The client has on their local system the code to calculate a computationally expensive function $F$, and an input $X$ on which they wish to evaluate the function.
If \Client wishes to run $F$ on a specific (statically known) worker \Worker,
it can run the following choreography in which \Client sends $F$ and $X$ to \Worker, then \Worker computes $F~X$ locally, and sends the result back to \Client.
\ashley{Reading this back, are the letters used too much instead of the actual full words Client/Worker here? Think it could be hard to read}
\ethan{We'll adjust in polishing passes later, but good thing to watch for.}
Note here, the syntax $t@\Client$ indicates a value of type $t$ located at \Client.
\begin{align*}
  & \RunAtWorker : (t \to t') @ \Client \to t@\Client \to t'@\Client \\
  & \RunAtWorker~F~X =
  \def\arraystretch{1.1}
  \begin{array}[t]{@{}l@{}}
    \LetN~\begin{array}[t]{@{}l@{}}
        \Worker.f \ChorDef F \ColSend \Worker \\
        \Worker.x \ChorDef X \ColSend \Worker \\
    \end{array} \\
    \In~\Worker.(f~x) \ColSend \Client
  \end{array}
\end{align*}
In the first line of this program, \Client sends the function $F$ stored on its local system to \Worker via the expression $F \ColSend \Worker$.
This results in an expression with type $(t \to t') @ \Worker$, indicating that \Worker now has knowledge of this function.

The second action which occurs on the first line of the program is the \emph{local let-binding} $\LetN~\Worker.f \ChorDef F \ColSend \Worker$, in which \Worker binds the value of the function it recieved from \Worker to a \emph{local variable} $\Worker.f$, allowing it to be used in \emph{local computations}.

This construct is necessary as choreographic and local values cannot inter-mingle: choreographic values can only be used in a local computation by using a local let-binding, and local values can only be used in the choreographic program by explicitly denoting the location that the computation will take place at.
For instance, if $N : \Int @ \ell$ is an integer stored at $\ell$, the choreography which represents $\ell$ locally adding 2 to $N$ is written as the program $\LetN~\ell.n \ChorDef N ~\In~ \ell.(2 + n)$, which also has type $\Int @ \ell$.

The second line of the program similarly has \Client send the value $X$ to \Worker, who then binds it to the local variable $\Worker.x$.
The final line of the program performs two actions.
\Worker first applies $f$ to $x$ on its local system, represented by the expression $\Worker.(f~x)$.
Lastly \Worker sends the result of this computation to \Client, completing the program.
 
\ethan{I think we want to more heavily emphasize that this is not how real distributed systems work.}
\ashley{What aspects specifically? I feel like this has been mentioned in other papers, but not in the introduction}
\ethan{Just the point that real distributed systems don't have a single static worker, they use thread pools and load balancers.}

We have so-far assumed that the worker location \Worker in this program is both fixed and statically-known.
What if, however, we wish for the identity of the worker location to be dynamically computed during the execution of the program?

For instance, consider a programmer who wishes to implement a thread pool.
In this process, the client \Client will ask a pool-manager \Mngr for the name of a location on which their task will run.
The manager can locally track the state of the thread pool, for instance by using a queue of idle processes, and allow clients to acquire the least-recently-used location by using a \emph{dynamically-computed} local function \programfont{acquireWorker}.
The programmer could implement the job-submission process using the following choreography:
\begin{align*}
  & \WithWorker : (\Int \to \Int) @ \Client \to \Int@\Client \to \Int@\Client \\
  & \WithWorker~F~X =
  \def\arraystretch{1.1}
  \begin{array}[t]{@{}l@{}}
    \LetN~\begin{array}[t]{@{}l@{}}
      \Mngr.w \ChorDef \programfont{acquireWorker} \\
      W \ChorDef \Tell[\Mngr]{w}{\{\Client\} \cup \rho_w} \\
      W.f \ChorDef F \ColSend W \\
      W.x \ChorDef X \ColSend W \\
      \mathit{Res} \ChorDef W.(f~x) \ColSend \Client
    \end{array} \\
    \In~\programfont{releaseWorker}~M.w \seq \mathit{Res}
  \end{array}
\end{align*}

\ethan{This no longer matches the updated example}
\ashley{Updated}

\ashley{Explain the second tell-let line in more detail. Emphasize this line, it's "the magic" which makes it work. Everything else in the program is seen in the first example.}

On the first line of this program, the pool manager \Mngr first finds and selects an idle \textsf{worker} location $w$ from the pool $\rho_w$ of possible worker locations using the local \textsf{acquireWorker} function.
With this dynamically computed value, on the seond line \Mngr then \emph{tells} the identity of the location $w$ to the client \Client, where it is bound to the choreographic program variable $W$.
As well, all workers in the pool $\rho_w$ are notified about the identity of the chosen worker so that they know whether or not they have been selected.

As in the earlier \RunAtWorker function, the client then sends $F$ and $X$ to $W$, who then computes $F~X$ locally, and sends the result to \Client.
Finally, the manager releases the worker back into the thread pool, at which point the computation has finished.

The second line of this program, $W \ChorDef \Tell[\Mngr]{w}{\{\Client\} \cup \rho_w}$, is the main difference between this and the previous example, and is critical for the ability of \langname to be able to send and use dynamically generated location names.
This expression, called a \emph{tell-let} binding, allows for location names from the local language to be used within the subsequent choreographic program.
Although locations can appear in the types of choreographic programs such as $\Int @ \Worker$, we disallow \emph{dependent types} within our language while still allowing the dynamic value of the location to be used in the body of the program by enforcing that the \emph{output type} of a tell-let binding does not depend on the value of the location.

\paragraph{Contributions}
\begin{itemize}
	\item We present \langname, the first typed choreographic programming language with the ability to send dynamically generated location names and types 
    \ethan{We should be careful. One could argue Symphony did that, it just didn't have a type system.}
	\item We show how process \ashley{Should I stick with "process polymorphism" or use "location polymorphism" as I'm sticking with Pirouette and calling them locations} and type polymorphism can be implemented in a manner which is generic over the choice of local language
    \ethan{Good point. We should either be very consistent, or mention early on that we use the interchangeably. I vote consistent.}
	\item We show how to define an out-of-order execution semantics for a choreographic language which includes process polymorphism
	\item We settle an open question about the strength of the type-system needed to implement process polymorphism in a choreographic language.
  In particular, previous works (Alice \& Bob) have implemented process polymorphism using a variant of System $\text{F}_\omega$, whereas \langname extends System F.
	\item The majority of our metatheory has been formalized and mechanically verified in Agda, and we present proofs for all remaining major theorems within this paper.
  The Agda implementation is discussed in Section \ref{sec:agda-dev}.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
