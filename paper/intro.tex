\section{Introduction}
\label{sec:introduction}

Distributed programs are an integral part of many modern software systems that allow for information to be transferred and computations to be performed between different nodes of a system.
Writing bug-free distributed programs is more difficult than in single-machine programs due to issues such as \emph{deadlock}, in which execution becomes stuck due to a mismatch in sends and receives between different nodes, and the inherent difficulty of representing computations spanning multiple locations.

\emph{Session types} solve this problem by describing and enforcing the pattern in which each individual participant will send and receive data.
However, session types can be difficult to work with as a separate program must be written for each participant, the entire system must be checked for mutual compatibility, and the participants must be fixed and statically known.

\emph{Choreographic programming} offers an alternative solution in which a single program is written to describe all interactions between nodes, and the program that each individual node will run is derived from this global program.
Such choreographic languages lead to \emph{deadlock freedom by design}, providing the programmer assurance that the system will never become stuck.
Currently, typed choreographic languages are typically functional and support higher-order types, but either do not support \emph{process polymorphism}, are not flexible enough to allow for an arbitrary language to be used for local computations, or cannot send \emph{dynamically computed process names}.
This paper presents \langname{}, the first choreographic programming language which supports process polymorphism and dynamically generated process names over an arbitrary language of local computations.

To understand why choreographic programming is a useful paradigm, consider a simple example in which two computational nodes, (W)orker and (C)lient communicate to compute a value.
The client has on their local system the code to calculate a computationally expensive function $f : (\textsf{Int} \rightarrow \textsf{Int}) @ \textsf{C}$, and an integer $x : \textsf{Int} @ \textsf{C}$ on which they wish to evaluate the function.
Consider the following choreographic program in which \textsf{C} sends $x$ and $f$ to \textsf{W}, who then computes $f \; x$ locally and returns the result back to \textsf{C}:
\begin{align*}
\textsf{applyAtWorker} &: (\textsf{Int} \rightarrow \textsf{Int}) @ \textsf{C} \rightarrow \textsf{Int} @ \textsf{C} \rightarrow \textsf{Int} @ \textsf{C}\\
\textsf{applyAtWorker} &= \lambda\, f \; x.\\
&\;\;\;\;\;\; \text{let}\; \textsf{W}.\textsf{fun} : \textsf{Int} \rightarrow \textsf{Int} \coloneq (f \rightsquigarrow \textsf{W})\\
&\;\;\;\;\;\;\;\;\;\;\; \textsf{W}.\textsf{inp} : \textsf{Int} \coloneq (x \rightsquigarrow \textsf{W})\\
&\;\;\;\;\;\;\;\;\;\;\; y : \textsf{Int} @ \textsf{W} \coloneq \textsf{W}.(\textsf{inp} \; \textsf{fun})\\
&\;\;\;\;\;\; \text{in}\; y \rightsquigarrow \textsf{C}
\end{align*}
This pattern of \emph{delegation} of work is common in higher-order choreographic languages, and allows for a concise representation of asynchronous computation while retaining important behavioral properties such as deadlock freedom.

In earlier choreographic languages, the worker and client locations mentioned in the above program were not treated \emph{polymorphically}.
In particular, a new program would have to be written for each possible choice of worker and client, which come from a fixed set specified ahead of time.
Similarly, there was no polymorphism for data types, which can be a hinderance for programmers who wish to create abstract computational patterns.
As well, in existing choreographic languages which do support location polymorphism, there is no way to \emph{dynamically} choose a location according to the result of a local computation; all locations used in a program must be known and determined at compile-time.
In \langname{}, we support location name and type polymorphism, and the ability to send and use dynamically computed location names and types.

To demonstrate the utility of these features, consider a programmer who wishes to implement a thread pool.
In this process, (C)lients will submit jobs to a pool (M)anager, who will track a queue of idle worker locations and execute the jobs with a selected (W)orker.

The programmer could implement the job-submission process using the following choreography:
\begin{align*}
\textsf{withWorker} &: (\forall W :: *_\ell.\,t @ C) \rightarrow t @ C\\
\textsf{withWorker} &= \lambda\, \textsf{job}.\\
&\;\;\;\;\;\; \text{let}\; \textsf{worker} : \textsf{Loc} @ M \coloneq  \textsf{acquireWorker}\\
&\;\;\;\;\;\;\;\;\;\; M.w :: *_\ell \coloneq \textsf{worker} \rightsquigarrow \rho_w \cup \{C\} \\
&\;\;\;\;\;\;\;\;\;\;\; x : t @ C \coloneq  \textsf{job}\,w\\
&\;\;\;\;\;\; \text{in}\; \textsf{releaseWorker}\,\textsf{worker};\; x
\end{align*}

In this program, the pool manager $M$ first finds and selects an idle \textsf{worker} location from the pool using the \textsf{acquireWorker} function.
The manager then sends the selected location to the client $C$, and notifies the worker that they have been selected to run the \textsf{job}.
The worker then runs the job, yielding the result $x$ directly to the client.
Finally, the manager releases the worker back into the thread pool.

Note that this program is \emph{polymorphic} with respect to the type $t$ returned by the job, the set $\rho_w$ of possible workers, and the client $C$.
As well, because the type of the \textsf{job} ($\forall W :: *_\ell.\,t @ C$) is polymorphic in the worker location, it has the freedom to communicate back and forth between the client, worker, and any other locations known to the client, rather than just running a task locally on the worker.
The program could also be made polymorphic in the pool manager location $M$ by taking the \textsf{acquireWorker} and \textsf{releaseWorker} functions as arguments, which we do not do for simplicity.

\paragraph{Contributions}
\begin{itemize}
	\item First choreographic programming language with dynamic location capabilities
	\item Process and type polymorphism over an arbitrary local language
	\item Out-of-order execution (with process polymorphism)
	\item System F versus System F$\omega$. We used a simpler type system for an analogous (and in some places more general) result. As well, it is(was!) an open question whether location polymorphism is possible in a choreographic language using System F. Maybe not possible in PolyChor style, but possible with Pirouette style (advantage of Pirouette style)
	\item Mechanical verification
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
