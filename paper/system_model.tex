\section{System Model}
\label{sec:system_model}

We first provide an overview of the assumptions we make about the structure and behavior of the systems that \langname{} programs can run on.
A system is composed of a set of logically distinct computational nodes which can run single-machine computations described by a set of local programs, and can send and receive messages with each-other over a network.

\subsection{Locations}
\label{sec:locations}

The set of \emph{location names}, or just \emph{locations}, is denoted by \Locations.
We write elements of this set as uppercase letters, typically as $L$, $L_1$, $L_2$, $W$, $M$, and so-on.
Locations are atomic and have no associated structure, simply representing the names of distinguishable physical nodes, threads, or other entities capable of running local computations and communicating with other locations.

\subsection{Communication}
\label{sec:communication}

We assume that all locations can communicate with each-other synchronously, whether over a network or otherwise.
In particular, if $L_1$ sends a message to $L_2$, then $L_1$ will not continue execution until $L_2$ has received the message.
Messages are sent instantaneously and deterministically, and must be guaranteed to arrive.

Nodes must be able to send both values from local computations, and the special \emph{synchronization messages} denoted \textsf{Left} and \textsf{Right}.
The synchronization messages are used to ensure that locations execute the correct branch of the program based on the results of previous computations at other locations, and can simply be represented as boolean values.

\subsection{Local Programs}
\label{sec:local-programs}
\ashley{This subsection is a bit long before it gets to the examples, I'm thinking of ways to break it up and make it more readable}

Each node should be able to execute \emph{local} programs in an expression-based language.
\langname is generic over the choice of local language, requiring only that it obey typical syntactic and typing rules, have a sound type system and semantics, and include the components described below.

First, we require that the language consist of a set of expressions which may include variables and expressions which bind variables.
The free-variables of an expression are denoted by $\text{FV}(e)$.

The local language must have a notion of variable substitution satisfying standard properties such as substitution of variables $\subst{x}{x}{e} = e$, substitution along the identity $\subst{e}{x}{x} = e$, and compositionality of substitutions $\subst{\subst{e}{x_1}{e_1}}{x_2}{e_2} = \subst{\subst{e}{x_2}{e_2}}{x_1}{(\subst{e_1}{x_2}{e_2})}$ for $x_1 \notin \text{FV}(e_2)$.

Types are reflected in the local language, along with type variables and binding thereof, and must satisfy identical substitutive properties.
As shown in Example \ref{ex:st-lambda}, type variables need not be used in a nontrivial manner or bound in any types or expressions, and the type system may ultimately be \emph{simply-typed}.

To implement the synchronization messages, we require that the local language have two distinguishable constants, \True and \False, which are values.
There should also be a type \Bool of booleans within the local language.
We also require that these constants be the \emph{only} well-typed values of the \Bool type, as described in Section \ref{sec:sound-type-systems}.

In order for location names to be dynamically computed and sent over the network, we require a type \Loc in the local language for representations of location names.
This type need not be \emph{complete}, in the sense that there does not need to be a value of this type which represents each concrete location $L \in \Locations$.
Similarly there must be a type \Typ for representations of local language types, which also need not be complete.
For example, the types present in the simply-typed lambda calculus could be represented as a type of binary trees with root-nodes labeled by a basic type.
We formulate the existence of the types \Loc and \Typ as strict requirements of the local language, however if they are not present we could alternatively choose to remove the relevant features from \langname and still retain the core choreographic functionality and properties.

We require the language have a predicate $\text{Val}(e)$ to determine whether an expression is a value of the language, and all values are required to be closed, with no free expression or type variables.
All values of the local language are able to be sent over the network.

\ashley{Why is the localstep being gross? Neither of the two here look correct.}
We require a small-step operational semantics on expressions defined by the relation $e_1 \localstep{} e_2$, read as $e_1$ \emph{steps-to} $e_2$.
Values are required to be \emph{fully-reduced}, so that for any value $\text{Val}(v)$, we have that $v \nlocalstep{} e$ for every $e$.

Types are disallowed from having an operational semantics.
In particular, we do not make any assumption of an operational semantics on the types of the language, and more strongly we require that the expression semantics $e_1 \localstep{} e_2$ obeys type preservation \emph{on-the-nose} without an allowance for a \emph{type-conversion} rule, as described in Section \ref{sec:sound-type-systems}.
In particular, this rules-out the usage of languages like System $F_\omega$ or a language with a dependent type system from being used as the local language.

\iftr\subsubsection{Examples}\else\paragraph{Examples}\fi
\label{sec:loc-lang-examples}

Although the requirement that types be reflected in the local language may seem restrictive, most simply-typed languages satisfy our requirements by straightforwardly reflecting their type system into the type expressions of the language, and disallowing type variables from being bound or used non-trivially.
Alternatively, types may be an active part of the language and used to express useful features, such as parametric polymorphism within System F.

\begin{ex}[Simply-Typed $\lambda$-Calculus]
  \label{ex:st-lambda}
  The simply-typed, call-by-value $\lambda$-calculus with booleans representing synchronization messages and integers representing location names satisfies our requirements under reasonable assumptions about location names.
  We trivially satisfy the requirement of having representations of local types by using the empty type \Empty, so the ability of \langname to send types across the network is essentially unused.

  Note that although type variables $\alpha$ are part of the syntax of types as required by our assumptions, they are not bound in either types or expressions of the language, making their inclusion a purely formal matter and identical to the standard treatment when no type-variables are in-context.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Empty} \alternative{t_1 \to t_2}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}
  \end{syntax}
\end{ex}

\begin{ex}[System F]
  \label{ex:system-f}
  System F with primitive types for booleans and integers again representing synchronization messages and location names, satisfies our requirements.
  In order to include representations for a non-trivial set of types, we inlcude the type \Typ which includes the quotations \say{\Int}, \say{\Bool}, and $e_1 \quoteto e_2$, representing a subset of simple-types.
  In this language, type variables are bound by the polymorphic for-all type $\forall \alpha.t$ and the type-abstraction expression $\Lambda \alpha.e$, and so may be used in a non-trivial manner.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Typ}\\
  	\alternative{t_1 \to t_2} \alternative{\forall \alpha.t}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2} \alternative{\Lambda \alpha.e} \alternative{e~t}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}\\
    \alternative{\say{\Int}} \alternative{\say{\Bool}} \alternative{e_1 \quoteto e_2}
  \end{syntax}
\end{ex}

\subsection{Local Type-System}
\label{sec:local-types}
We require a type-system for expressions of the local language, and a well-formedness judgment for local language types.
For simplicity we assume there is a single kind for types, but this assumption is not essential, and our formalization allows kinds of the local language to be from an arbitrary set.

The type well-formedness judgement is written as \localkinded{\Gamma}{t}, where the \emph{kinding context} $\Gamma$ is a list of in-scope type variables, and $t$ is a type of the local language.
The typing judgement is written as \localtyped{\Gamma}{\Sigma}{e}{t}, where $\Gamma$ is a kinding context, the \emph{typing context} $\Sigma$ is a list of ascriptions $x \ty t$ of expression variables to types, $e$ is an expression, and $t$ is a type.
The typing context well-formedness judgment $\localctxwf{\Gamma}{\Sigma}$ requires that all types in $\Sigma$ be well-formed: $\localctxwf{\Gamma}{\Sigma} \defeq \forall_{t \in \Sigma}~\localkinded{\Gamma}{t}$.

\ashley{Should I convert the \textsc{TyVar} and \textsc{Var} rules to instead be explicit about exchange, weakening, and strengthening to more suit the named-style, or are they fine as-is? I'm a fan of this style for conciseness}

\begin{figure}
	\begin{mathpar}
		\infer[TyVar]{\alpha \in \Gamma}
		{\localkinded{\Gamma}{\alpha}} \and

		\infer[TyBool]{}
		{\localkinded{\Gamma}{\Bool}} \and

		\infer[TyLoc]{}
		{\localkinded{\Gamma}{\Loc}} \and

		\infer[TyTyp]{}
		{\localkinded{\Gamma}{\Typ}} \and

		\infer[TySubst]{\localkinded{\Gamma}{t_1} \\
			\localkinded{\Gamma, \alpha}{t_2}}
		{\localkinded{\Gamma}{\subst{t_2}{\alpha}{t_1}}} \and

		\infer[Var]{\localctxwf{\Gamma}{\Sigma} \\
			x \ty t \in \Sigma}
		{\localtyped{\Gamma}{\Sigma}{x}{t}}

		\infer[True]{\localctxwf{\Gamma}{\Sigma}}
		{\localtyped{\Gamma}{\Sigma}{\True}{\Bool}}

		\infer[False]{\localctxwf{\Gamma}{\Sigma}}
		{\localtyped{\Gamma}{\Sigma}{\False}{\Bool}}

		\infer[Subst]{\localtyped{\Gamma}{\Sigma}{e_1}{t_1} \\
			\localtyped{\Gamma}{\Sigma, x \ty t_1}{e_2}{t_2}}
		{\localtyped{\Gamma}{\Sigma}{\subst{e_2}{x}{e_1}}{t_2}} \and

		\infer[TmTySubst]{\localkinded{\Gamma}{t_1} \\
			\localtyped{\Gamma, \alpha}{\Sigma}{e_2}{t_2}}
		{\localtyped{\Gamma}{\Sigma}{\subst{e_2}{\alpha}{t_1}}{\subst{t_2}{\alpha}{t_1}}}
	\end{mathpar}
  \caption[Required-Admissible Rules]{Required-Admissible Rules for Local Type and Kinding Systems}
  \label{fig:local-type-rules}
\end{figure}

\paragraph{Sound Type Systems}
\label{sec:sound-type-systems}
We additionally require the following \emph{soundness} assumptions on the local type system:
\begin{itemize}
	\item (\textsc{Preservation}) If $e_1 \localstep{} e_2$ and $\localtyped{\Gamma}{\Sigma}{e_1}{t}$, then $\localtyped{\Gamma}{\Sigma}{e_2}{t}$.

	\item (\textsc{Progress}) If $e_1$ is a closed expression and $\localemptyped{e_1}{t}$, then either $e_1$ is a value or there is an $e_2$ such that $e_1 \localstep{} e_2$.

	\item (\textsc{Boolean Invertibility}) The type \Bool is invertible for values: if $v$ is a value and $\localemptyped{v}{\Bool}$ then either $v = \True$ or $v = \False$.

	\item (\textsc{Location Name Invertibility}) The type \Loc is partially invertible for values: there is an injective partial map $\text{locLit} : \Locations \rightharpoonup \text{Expr}$ from location names to local language expressions such that if $v$ is a value and $\localemptyped{v}{\Loc}$ then there exists some $L \in \Locations$ such that $v = \text{locLit}(L)$.

	\item (\textsc{Type Representation Invertibility}) The type \Typ is partially invertible for values: there is an injective partial map $\text{tyLit} : \text{Type} \rightharpoonup \text{Expr}$ from local language types to local language expressions such that if $v$ is a value and $\localemptyped{v}{\Typ}$ then there exists some type $t$ such that $v = \text{tyLit}(t)$ and $\localempkinded{t}$.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
