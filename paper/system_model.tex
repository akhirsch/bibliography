\section{System Model}
\label{sec:system_model}

We first provide an overview of the assumptions we make about the structure and behavior of the systems that \langname{} programs can run on.
A system is composed of a set of logically distinct computational nodes which can run single-machine computations described by a set of local programs, and can send and receive messages with each-other over a network.

\subsection{Locations}
\label{sec:locations}

The set of \emph{location names}, or just \emph{locations}, is denoted by \Locations.
We write elements of this set as uppercase letters, typically as $L$, $L_1$, $L_2$, $W$, $M$, and so-on.
Locations are atomic and have no associated structure, simply representing the names of distinguishable physical nodes, threads, or other entities capable of running local computations and communicating with other locations.

\subsection{Communication}
\label{sec:communication}

We assume that all locations can communicate with each-other synchronously, whether over a network or otherwise.
In particular, if $L_1$ sends a message to $L_2$, then $L_1$ will not continue execution until $L_2$ has received the message.
Messages are sent instantaneously and deterministically, and must be guaranteed to arrive.

Nodes must be able to send both values from local computations, and the special \emph{synchronization messages} denoted \textsf{Left} and \textsf{Right}.
The synchronization messages are used to ensure that locations execute the correct branch of the program based on the results of previous computations at other locations, and can simply be represented as boolean values.

\subsection{Local Programs}
\label{sec:local-programs}

Each node should be able to execute \emph{local} programs in an expression-based language.
Our choreographic language is generic over the choice of local language, requiring only that it obey typical syntactic and typing rules, have a sound type system and semantics, and include the components described below.

\ashley{Should I convert the substitution properties to be in single-variable form? I think many people may not be familiar with the treatment of simultaneous substitution and find this confusing. It may also fit with the named-style of the paper better.}
First, we require that the language consist of variables and term constructors, and includes a notion of variable substitution satisfying the standard simultaneous substitution properties of substitution of variables $x \langle \sigma \rangle = \sigma_x$, substitution along the identity $e \langle  id \rangle = e$, and composition of simultaneous substitutions $e \langle \sigma_1 \rangle \langle \sigma_2 \rangle = e \langle \sigma_2 \circ \sigma_1 \rangle$.

Types are reflected in the local language, and we allow for type variables and type constructors that satisfy identical substitutive properties.
Type variables may also appear in terms of the language, rather than just the types, and we put the same requirements on substitution of type variables as for expression variables.
As shown in Example \ref{ex:st-lambda}, type variables need not be used in a nontrivial manner, and the type system may ultimately be \emph{simply-typed}.

To implement the synchronization messages, we require that the local language have two distinguishable constants, \True and \False, which are values.
There should also be a type \Bool of booleans within the local language.
We also require that these constants be the \emph{only} well-typed values of the \Bool type, as described in \todo.

In order for location names to be dynamically computed and sent over the network, we require a type \Loc in the local language for representations of location names.
This type need not be \emph{complete}, in the sense that there does not need to be a value of this type for each concrete location $L \in \Locations$.
Similarly there must be a type \Typ for representations of local language types, which also need not be complete.
For example, the types present in the simply-typed lambda calculus could be represented as a type of binary trees with root-nodes labeled as a basic type.
We formulate the existence of the types \Loc and \Typ as a strict requirement on the local language, however if they are not present we could alternatively choose to remove the relevant features from \langname and still retain the core choreographic functionality and properties.

We require the language have a predicate Value$(e)$ to determine whether an expression is a value of the language, and all values are required to be closed expressions with no free expression or type variables.
All values of the local language are able to be sent over the network.

\ashley{Why is the localstep being gross? Neither of the two here look correct.}
We require a small-step operational semantics on expressions defined by the relation $e_1 \localstep{} e_2$, read as $e_1$ \emph{steps-to} $e_2$.
Values are required to be \emph{fully-reduced}, so that for any value Value$(v)$, $v \nlocalstep{} e$ for every $e$.
Types are disallowed from having an operational semantics.
In particular, we do not make any assumption of an operational semantics on the types of the language, and more strongly we require that the expression semantics $e_1 \localstep{} e_2$ obeys type preservation \emph{on-the-nose} without an allowance for \emph{type-conversion}, as described in \todo.
In particular, this rules-out the usage of languages like System $F_\omega$ or a language with a dependent type system from being used as the local language.

\iftr\subsubsection{Examples}\else\paragraph{Examples}\fi
\label{sec:loc-lang-examples}

Although the requirement that types be reflected in the local language may seem restrictive, most simply-typed languages satisfy our requirements by reflecting their type system into the type expressions of the language, and disallowing type variables from being bound or used non-trivially.
Alternatively, types may be an active part of the language and used to express useful features, such as parametric polymorphism within System F.

\begin{ex}[Simply-Typed $\lambda$-Calculus]
  \label{ex:st-lambda}
  The simply-typed, call-by-value $\lambda$-calculus with booleans and integers satisfies our requirements under the reasonable assumption that location names can be represented as integers.
  We trivially satisfy the requirement of having representations of local types by using the empty type \Empty.
  Note that although type variables $\alpha$ are part of the syntax of types as required by our assumptions, they are not bound in either types or expressions of the language, making their inclusion a purely formal matter and identical to the standard treatment when no type-variables are in-context.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Empty} \alternative{t_1 \to t_2}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}
  \end{syntax}
\end{ex}

\begin{ex}[System F]
  \label{ex:system-f}
  System F with primitive types for booleans and integers, as well as a way to represent simple types denoted via the quotations \say{\Int}, \say{\Bool}, and $e_1 \quoteto e_2$, satisfies our requirements.
  Note that only a strict subset of the types of the language, namely the simple types, have a representation.
  In this language, type variables are bound by the polymorphic for-all type $\forall \alpha.t$ and the type-abstraction expression $\Lambda \alpha.e$, and so may be used in a non-trivial manner.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Typ}\\
  	\alternative{t_1 \to t_2} \alternative{\forall \alpha.t}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2} \alternative{\Lambda \alpha.e} \alternative{e~t}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}\\
    \alternative{\say{\Int}} \alternative{\say{\Bool}} \alternative{e_1 \quoteto e_2}
  \end{syntax}
\end{ex}

\subsection{Local Type-System}
\label{sec:local-types}
We require a type-system on expressions of the local language, and a well-formedness judgment on local language types.
For simplicity we assume there is a single kind of types, but this assumption is not essential, and our formalization allows kinds of the local language to be from an arbitrary set.

The type well-formedness judgement is written as \localkinded{\Gamma}{t}, where the \emph{kinding context} $\Gamma$ is a list of in-scope type variables, and $t$ is a type of the local language.
The typing judgement is written as \localtyped{\Gamma}{\Delta_e}{e}{t}, where $\Gamma$ is a kinding context, the \emph{typing context} $\Delta$ is a list of ascriptions $x \ty t$ of expression variables to types, $e$ is an expression, and $t$ is a type.
The typing context well-formedness judgment $\localctxwf{\Gamma}{\Delta}$ requires that all types in $\Delta$ be well-formed: $\localctxwf{\Gamma}{\Delta} \defeq \forall_{t \in \Delta}~\localkinded{\Gamma}{t}$.

\ashley{Should I convert the \textsc{TyVar} and \textsc{Var} rules to instead be explicit about exchange, weakening, and strengthening to more suit the named-style, or are they fine as-is?}

\begin{figure}[h]
	\begin{mathpar}
		\infer[TyVar]{\alpha \in \Gamma}
		{\localkinded{\Gamma}{\alpha}} \and

		\infer[TyBool]{}
		{\localkinded{\Gamma}{\Bool}} \and

		\infer[TyLoc]{}
		{\localkinded{\Gamma}{\Loc}} \and

		\infer[TyTyp]{}
		{\localkinded{\Gamma}{\Typ}} \and

		\infer[TySubst]{\localkinded{\Gamma}{t_1} \\
			\localkinded{\Gamma, \alpha}{t_2}}
		{\localkinded{\Gamma}{\subst{t_2}{\alpha}{t_1}}} \and

		\infer[Var]{\localctxwf{\Gamma}{\Delta} \\
			x \ty t \in \Delta}
		{\localtyped{\Gamma}{\Delta}{x}{t}}

		\infer[True]{\localctxwf{\Gamma}{\Delta}}
		{\localtyped{\Gamma}{\Delta}{\True}{\Bool}}

		\infer[False]{\localctxwf{\Gamma}{\Delta}}
		{\localtyped{\Gamma}{\Delta}{\False}{\Bool}}

		\infer[Subst]{\localtyped{\Gamma}{\Delta}{e_1}{t_1} \\
			\localtyped{\Gamma}{\Delta, x \ty t_1}{e_2}{t_2}}
		{\localtyped{\Gamma}{\Delta}{\subst{e_2}{x}{e_1}}{t_2}} \and

		\infer[TmTySubst]{\localkinded{\Gamma}{t_1} \\
			\localtyped{\Gamma, \alpha}{\Delta}{e_2}{t_2}}
		{\localtyped{\Gamma}{\Delta}{\subst{e_2}{\alpha}{t_1}}{\subst{t_2}{\alpha}{t_1}}}
	\end{mathpar}
  \caption[Required-Admissible Rules]{Required-Admissible Rules for Local Type and Kinding Systems}
  \label{fig:local-type-rules}
\end{figure}

\paragraph{Sound Type Systems}
\label{sec:sound-type-systems}
We additionally require the following \emph{soundness} assumptions on the local type system:
\begin{itemize}
	\item (\textsc{Preservation}) If $e_1 \localstep{} e_2$ and $\localtyped{\Gamma}{\Delta}{e_1}{t}$, then $\localtyped{\Gamma}{\Delta}{e_2}{t}$.

	\item (\textsc{Progress}) If $e_1$ is a closed expression and $\localemptyped{e_1}{t}$, then either $e_1$ is a value or there is an $e_2$ such that $e_1 \localstep{} e_2$.

	\item (\textsc{Boolean Invertibility}) The type \Bool is invertible for values: if $v$ is a value and $\localemptyped{v}{\Bool}$ then either $v = \True$ or $v = \False$.

	\item (\textsc{Location Name Invertibility}) The type \Loc is invertible for values: there is an injective \emph{partial} map $\text{locLit} : \Locations \rightharpoonup \text{Expr}$ from location names to local language expressions such that if $v$ is a value and $\localemptyped{v}{\Loc}$ then there exists some $L \in \Locations$ such that $v = \text{locLit}(L)$.

	\item (\textsc{Type Representation Invertibility}) The type \Typ is invertible for values: there is an injective partial map $\text{tyLit} : \text{Type} \rightharpoonup \text{Expr}$ from local language types to local language expressions such that if $v$ is a value and $\localemptyped{v}{\Typ}$ then there exists some type $t$ such that $v = \text{tyLit}(t)$ and $\localempkinded{t}$.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
