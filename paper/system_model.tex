\section{System Model}
\label{sec:system_model}

We first provide an overview of the assumptions we make about the structure and behavior of the systems that \langname{} programs can run on.
A system is composed of a set of logically distinct computational nodes which can run single-machine computations described by a set of local programs, and can send and receive messages with each-other over a network.

\subsection{Locations}
\label{sec:locations}

The set of \emph{location names}, or just \emph{locations}, is denoted by \Locations.
We write elements of this set as uppercase letters, typically as $L$, $L_1$, $L_2$, $W$, $M$, and so-on.
Locations are atomic and have no associated structure, simply representing the names of distinguishable physical nodes, threads, or other entities capable of running local computations and communicating with other locations.

\subsection{Communication}
\label{sec:communication}

We assume that all locations can communicate with each-other synchronously, whether over a network or otherwise.
In particular, if $L_1$ sends a message to $L_2$, then $L_1$ will not continue execution until $L_2$ has received the message.
Messages are sent instantaneously and deterministically, and must be guaranteed to arrive.

Nodes must be able to send both values from local computations, and the special \emph{synchronization messages} denoted \textsf{Left} and \textsf{Right}.
The synchronization messages are used to ensure that locations execute the correct branch of the program based on the results of previous computations at other locations, and can simply be represented as boolean values.

\subsection{Local Programs}
\label{sec:local-programs}
\ashley{This subsection is a bit long before it gets to the examples, I'm thinking of ways to break it up and make it more readable}
\ethan{I suspect we can cut this down a lot by assuming some (common at POPL) knowledge and editing.}

Each node should be able to execute \emph{local} programs in an expression-based language.
\langname is generic over the choice of local language, requiring only that it obey typical syntactic and typing rules, have a sound type system and semantics, and include the components described below.

First, we require that the language consist of a set of expressions which may include variables and expressions which bind variables.
The free-variables of an expression are denoted by $\fv(e)$.

The local language must have a notion of variable substitution satisfying standard properties such as substitution of variables $\subst{x}{x}{e} = e$, substitution along the identity $\subst{e}{x}{x} = e$, and compositionality of substitutions $\subst{\subst{e}{x_1}{e_1}}{x_2}{e_2} = \subst{\subst{e}{x_2}{e_2}}{x_1}{(\subst{e_1}{x_2}{e_2})}$ for $x_1 \notin \fv(e_2)$.

Types are reflected in the local language, along with type variables and binding thereof, and must satisfy identical substitutive properties.
As shown in Example \ref{ex:st-lambda}, type variables need not be used in a nontrivial manner or bound in any types or expressions, and the type system may ultimately be \emph{simply-typed}.

To implement the synchronization messages, we require that the local language have two distinguishable constants, \True and \False, which are values.
There should also be a type \Bool of booleans within the local language.
We also require that these constants be the \emph{only} well-typed values of the \Bool type, as described in Section \ref{sec:sound-type-systems}.

In order for location names to be dynamically computed and sent over the network, we require a type \Loc in the local language for representations of location names.
This type need not be \emph{complete}, in the sense that there does not need to be a value of this type which represents each concrete location $L \in \Locations$.
Similarly there must be a type \Typ for representations of local language types, which also need not be complete.
For example, the types present in the simply-typed lambda calculus could be represented as a type of binary trees with root-nodes labeled by a basic type.

We require the language have a predicate $\text{Val}(e)$ to determine whether an expression is a value of the language, and all values are required to be closed, with no free expression or type variables.
All values of the local language are able to be sent over the network, including expressions which may be functions.

\ashley{Why is the localstep being gross? Neither of the two here look correct.}
\ethan{\texttt{\textbackslash xRightarrow} does not do what you want with subscripts. I have a distressingly complicated macro to fix it (and make the arrows longer, but that we can undo) that I just added. We should use it for all of our step relations.}
We require a small-step operational semantics on expressions defined by the relation $e_1 \localstep e_2$, read as ``$e_1$ steps-to $e_2$''.
Values are required to be \emph{fully-reduced}, so that for any value $\text{Val}(v)$, we have that $v \nlocalstep e$ for every $e$.

Types are disallowed from having an operational semantics.
In particular, we do not make any assumption of an operational semantics on the types of the language, and more strongly we require that the expression semantics $e_1 \localstep e_2$ obeys type preservation \emph{on-the-nose} without an allowance for a \emph{type-conversion} rule, as described in Section \ref{sec:sound-type-systems}.
In particular, this rules-out the usage of languages like System $F_\omega$ or a language with a dependent type system from being used as the local language.

\iftr\subsubsection{Examples}\else\paragraph{Examples}\fi
\label{sec:loc-lang-examples}

Although the requirement that types be reflected in the local language may seem restrictive, most simply-typed languages satisfy our requirements by straightforwardly reflecting their type system into the type expressions of the language, and disallowing type variables from being bound or used non-trivially.
Alternatively, types may be an active part of the language and used to express useful features, such as parametric polymorphism within System F.

\begin{ex}[Simply-Typed $\lambda$-Calculus]
  \label{ex:st-lambda}
  The simply-typed, call-by-value $\lambda$-calculus with booleans representing synchronization messages and integers representing location names satisfies our requirements under reasonable assumptions about location names.
  We trivially satisfy the requirement of having representations of local types by using the empty type \Empty, so the ability of \langname to send types across the network is essentially unused.

  Note that although type variables $\alpha$ are part of the syntax of types as required by our assumptions, they are not bound in either types or expressions of this local language, and the types are not reflected in the syntax of this language.
  The effects of this are discussed in more detail in Section \ref{sec:type-system}.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Empty} \alternative{t_1 \to t_2}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2} \alternative{e_1 = e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}
  \end{syntax}
\end{ex}

\begin{ex}[System F]
  \label{ex:system-f}
  System F with primitive types for booleans and integers again representing synchronization messages and location names, satisfies our requirements.
  In order to include representations for a non-trivial set of types, we inlcude the type \Typ which includes the quotations \say{\Int}, \say{\Bool}, and $e_1 \quoteto e_2$, representing a subset of simple-types.
  In this language, type variables are bound by the polymorphic for-all type $\forall \alpha.t$ and the type-abstraction expression $\Lambda \alpha.e$, and so may be used in a non-trivial manner.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Typ}\\
  	\alternative{t_1 \to t_2} \alternative{\forall \alpha.t}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2} \alternative{\Lambda \alpha.e} \alternative{e~t}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2} \alternative{e_1 = e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}\\
    \alternative{\say{\Int}} \alternative{\say{\Bool}} \alternative{e_1 \quoteto e_2}
  \end{syntax}
\end{ex}

\subsection{Local Kinding and Type-System}
\label{sec:local-types}
We require a type-system for expressions of the local language, and a well-formedness judgment for local language types.
For simplicity we assume there is a single kind for types, but this assumption is not essential, and our formalization allows kinds of the local language to be from an arbitrary set.

The type well-formedness judgement is written as \localkinded{\Gamma_e}{t_e}, where the \emph{local kinding context} $\Gamma_e$ is a list of in-scope type variables, and $t_e$ is a type of the local language.
The typing judgement is written as \localtyped{\Gamma_e}{\Sigma_e}{e}{t_e}, where $\Gamma_e$ is a local kinding context, the \emph{local typing context} $\Sigma_e$ is a list of ascriptions $x \ty t_e$ of local expression variables to local types, $e$ is an local expression, and $t_e$ is a local type.
The typing context well-formedness judgment $\localctxwf{\Gamma_e}{\Sigma_e}$ requires that all types in $\Sigma$ be well-formed: $\localctxwf{\Gamma_e}{\Sigma_e} \defeq \forall_{t_e \in \Sigma_e}~\localkinded{\Gamma_e}{t_e}$.

The only types required of the local language are the type $\Bool$ of booleans, the type $\Loc$ for location names, and the type $\Typ$ for representations of local types.
Features present in the choreographic kinding and type systems, such as polymorphism, are not required to be present in the local kinding and type systems.

\ashley{Should I convert the \textsc{TyVar} and \textsc{Var} rules to instead be explicit about exchange, weakening, and strengthening to more suit the named-style, or are they fine as-is? I'm a fan of this style for conciseness}
\ethan{I think they're fine as-is, though how important are having rules for a rudamentary kinding system here? Can we just get rid of them?}
\ashley{Good point, I think it's fairly obvious when you say "these things need to be types", but I think TyVar and TySubst are important to show that the kinding system can be non-trivial with polymorphism in the local language}

\begin{figure}
  \begin{mathpar}
    \infer[TyVar]{\alpha \in \Gamma}
    {\localkinded{\Gamma}{\alpha}}
    \and
    \infer[TySubst]{\localkinded{\Gamma}{t_1} \\
      \localkinded{\Gamma, \alpha}{t_2}}
    {\localkinded{\Gamma}{\subst{t_2}{\alpha}{t_1}}}
    \and
    \infer[CtxWf]{\localtyped{\Gamma}{\Sigma}{e}{t}}
    {\localctxwf{\Gamma}{\Sigma}}
    \and
    \infer[TyWf]{\localtyped{\Gamma}{\Sigma}{e}{t}}
    {\localkinded{\Gamma}{t}}
    \and
    \infer[Var]{\localctxwf{\Gamma}{\Sigma} \\
      x \ty t \in \Sigma}
    {\localtyped{\Gamma}{\Sigma}{x}{t}}
    \and
    \infer[Subst]{\localtyped{\Gamma}{\Sigma}{e_1}{t_1} \\
      \localtyped{\Gamma}{\Sigma, x \ty t_1}{e_2}{t_2}}
    {\localtyped{\Gamma}{\Sigma}{\subst{e_2}{x}{e_1}}{t_2}}
    \and
    \infer[TmTySubst]{\localkinded{\Gamma}{t_1} \\
      \localtyped{\Gamma, \alpha}{\Sigma}{e_2}{t_2}}
    {\localtyped{\Gamma}{\Sigma}{\subst{e_2}{\alpha}{t_1}}{\subst{t_2}{\alpha}{t_1}}}
  \end{mathpar}
  \caption[Required Admissible Rules]{Required Admissible Rules for Local Type and Kinding Systems}
  \label{fig:local-type-rules}
\end{figure}

\label{sec:sound-type-systems}
We additionally require the following \emph{soundness} assumptions on the local type system:
\begin{itemize}
	\item (\textsc{Preservation}) If $e_1 \localstep e_2$ and $\localtyped{\Gamma}{\Sigma}{e_1}{t}$, then $\localtyped{\Gamma}{\Sigma}{e_2}{t}$.

	\item (\textsc{Progress}) If $\localemptyped{e_1}{t}$, then either $e_1$ is a value or there is an $e_2$ such that $e_1 \localstep e_2$.
    \ethan{I think saying ``$e_1$ is a closed expression'' is redundant. Doesn't $\localemptyped{e_1}{t}$ imply that?}
    \ashley{Yes, I think it's a fairly obvious assumption that you can only use variables in the context so I'm not sure it's necessary to list anywhere}

	\item (\textsc{Boolean Invertibility}) The type \Bool is invertible for values: if $v$ is a value and $\localemptyped{v}{\Bool}$ then either $v = \True$ or $v = \False$.

	\item (\textsc{Location Invertibility}) The type \Loc is invertible for values: if $v$ is a value and $\localemptyped{v}{\Loc}$ then $v \in \Locations$.
    \ethan{Can we simplify this to say something like: if $\localemptyped{v}{\Loc}$, then $v \in \Locations$?
      It's a slightly less precise version of what you have, by automatically using locLit and locLit$^{-1}$ to map between $\dom(\text{locLit})$ and closed values of type $\Loc$ implicitly as necessary.}
  \ashley{Yes, this should be more readable and is more technical than is necessary. I am not sure whether the quotes add more clarity to the type invertibility so I have both versions here for now}

	\item (\textsc{Type Invertibility}) If $\say{t}$ is a value and $\localemptyped{\say{t}}{\Typ}$ then $\localempkinded{t}$.
    \ethan{Similar question here, though if we get rid of explicit polymorphism in the local language, can we remove this entirely?.}
    \ashley{No I don't think you can remove this, it doesn't really intersect with polymorphism. It's more of just ``You gave me $\say{t}$ and I need to be able to interpret it as an actual type $t$ by evaluating the representation/quotation''}

 	\item (\textsc{Type Invertibility}) If $t$ is a value and $\localemptyped{t}{\Typ}$ then $\localempkinded{t}$.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
