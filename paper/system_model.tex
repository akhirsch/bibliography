\section{System Model}
\label{sec:system_model}
We first provide an overview of the assumptions we make about the structure and behavior of the systems that \langname{} programs can run on.
A system is composed of a set of logically distinct computational nodes which can run single-machine computations described by a set of local programs, and can send and receive messages with each other over a network.

\subsection{Locations}
\label{sec:locations}
The set of \emph{location names}, or just \emph{locations}, is denoted by \Locations.
We write elements of this set as uppercase letters, typically as $L$, $L_1$, $L_2$, $W$, $M$, and so-on.
Locations are atomic and have no associated structure, simply representing the names of distinguishable physical nodes, threads, or other entities capable of running local computations and communicating with other locations.

\subsection{Communication}
\label{sec:communication}
We assume that all locations can communicate with each other synchronously, whether over a network or otherwise.
In particular, if $L_1$ sends a message to $L_2$, then $L_1$ will not continue execution until $L_2$ has received the message.
Messages are sent instantaneously and deterministically, and must be guaranteed to arrive.

Nodes must be able to send both values from local computations, and the special \emph{synchronization messages}~\Left and~\Right.
The synchronization messages are used to ensure that locations execute the correct branch of the program based on the results of previous computations at other locations, and can simply be viewed as boolean values.

\subsection{Local Programs}
\label{sec:local-programs}
\ashley{This subsection is a bit long before it gets to the examples, I'm thinking of ways to break it up and make it more readable}
\ethan{I suspect we can cut this down a lot by assuming some (common at POPL) knowledge and editing.}
\akh{This can be compressed a lot by referencing Pirouette.}

Each node should be able to execute \emph{local} programs in an expression-based language.
\langname allows for a wide range of languages to be used for local computations, requiring only standard assumptions on their syntax, type system, and semantics.
We refer to Pirouette~\citep{HirschG22} for the basic features of local languages, and detail the requirements that are new to \langname.

% First, each location should be able to send the result of a local computation to any other location.
% Specifically, if an expression $v$ of the local language is a value, denoted $\val{v}$, then we can send $v$ in a message.
% We require that if $\val{v}$ then $v$ has no free variables; this serves to prevent terms with free-variables representing values only known by one location from being send to another.

% \akh{It's not to implement synchronization messages, it's to give semantics to if~expressions.}
% \ashley{Yes, not sure why I said that.}
% To implement the synchronization messages, we require that the local language have two distinguishable constants, $\True, \False \ty \Bool$, which are values.
% We also require that these constants be the \emph{only} well-typed values of the \Bool~type, as described in Section~\ref{sec:sound-type-systems}.

\akh{This is written very negatively. Is it really such a bad thing?}
\ashley{Updated}
In contrast to Pirouette, types may now be reflected in the local language, including via binding of local type variables.
This allows for the local language to implement polymorphism, but it is not required.

Types of the local language may not have an operational semantics, nor may they depend on values of the language.
% we require that the expression semantics $e_1 \localstep e_2$ obeys type preservation \emph{on-the-nose} without an allowance for a type-conversion rule.
This allows our type system to stay within the confines of System F and not introduce the complexity associated with System $\text{F}_{\omega}$ or a dependent type system.

In order for location names to sent as messages, we require that the local language have a type~\Loc for \emph{representations} of location names.
These representations do not need to be in any specific format.
We only require that values of the~\Loc type are able to be converted into concrete location names.
There must also be a type~\Typ for representations of a subset of local language types, and values of this type can similarly be converted into well-formed types of the local language.
We denote representations of a type or location name as $\say{t}$, with the details formalized in Section~\ref{sec:sound-type-systems}.

\iftr\subsubsection{Examples}\else\paragraph{Examples}\fi
\label{sec:loc-lang-examples}
Many simply-typed and polymorphic $\lambda$-calculi satisfy our requirements with very minor modification.
We present two canonical examples here.

\begin{ex}[Simply-Typed $\lambda$-Calculus]
  \label{ex:st-lambda}
  The simply-typed, call-by-value $\lambda$-calculus with primitive booleans and integers satisfies our requirements.
  Specifically, booleans are required in order to give a semantics to choreographic branching statements, and integers can be used to represent location names.
  We may trivially satisfy the requirement to represent types within the local language by setting \Typ to the empty type.

  \akh{Why do we need to give the entire grammar here? It's a lot of white space.}
  \ashley{Removed: Can assume knowledge}

  % \begin{syntax}
  % 	\category[Types]{t} \alternative{\Int} \alternative{\Bool} \alternative{\Empty} \alternative{t_1 \to t_2}
  %   \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2}\\
  %   \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2} \alternative{e_1 = e_2}\\
  %   \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}
  % \end{syntax}
\end{ex}

\begin{ex}[System F]
  \label{ex:system-f}
  System F with primitive booleans and integers also satisfies our requirements.
  In order to include representations for a non-trivial set of types, we define the type~\Typ to include the representations \say{\Int}, \say{\Bool}, and $e_1 \quoteto e_2$.
  Note that the representations are at the level of expressions rather than types, and that~\Typ behaves identically to the other types of the language.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Typ}\\
  	\alternative{t_1 \to t_2} \alternative{\forall \alpha.t}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2} \alternative{\Lambda \alpha.e} \alternative{e~t}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2} \alternative{e_1 = e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}\\
    \alternative{\say{\Int}} \alternative{\say{\Bool}} \alternative{e_1 \quoteto e_2}
  \end{syntax}
\end{ex}

\akh{It's not clear how $\Lambda \alpha.e$ and $\Typ$ interact.}
\ashley{I clarified this some. In this example \Typ should just be read as a sort of binary tree, rather than a type-of-types, so it doesn't interact with $\Lambda \alpha.e$ in a special way. I changed it from ``typ'' to ``tyRep'' everywhere in the paper if that makes it clearer.}

\subsection{Local Kinding and Type System}
\label{sec:local-types}
We require a type system for local language, and a well-formedness judgment for local-language types.
For simplicity we assume there is a single kind of local language types, but we could just as well allow for an arbitrary non-empty set of kinds.

The type well-formedness judgement is written as \localkinded{\Gamma}{t_e}, where the \emph{local kinding context} $\Gamma$ is a list of in-scope type variables, and $t_e$ is a type of the local language.
\emph{Local typing contexts}, denoted as $\Sigma$, are a list of ascriptions $x \ty t_e$ of local variables to local types.
The contexts well-formedness judgment \localctxwf{\Gamma}{\Sigma} should hold if and only if all types in $\Sigma$ are well-formed.
The expression typing judgement is written as \localtyped{\Gamma}{\Sigma}{e}{t_e}.
These judgments should admit the rules given in Figure~\ref{fig:local-type-rules}.

\begin{figure}
  \begin{mathpar}
    \infer[TyVar]{\alpha \in \Gamma}
    {\localkinded{\Gamma}{\alpha}}
    \and
    \infer[TySubst]{\localkinded{\Gamma}{t_1} \\
      \localkinded{\Gamma, \alpha}{t_2}}
    {\localkinded{\Gamma}{\subst{t_2}{\alpha}{t_1}}}
    \and
    \infer[CtxWf]{\localtyped{\Gamma}{\Sigma}{e}{t_e}}
    {\localctxwf{\Gamma}{\Sigma}}
    \and
    \infer[TyWf]{\localtyped{\Gamma}{\Sigma}{e}{t_e}}
    {\localkinded{\Gamma}{t_e}}
    \and
    \infer[Var]{\localctxwf{\Gamma}{\Sigma} \\
      x \ty t_e \in \Sigma}
    {\localtyped{\Gamma}{\Sigma}{x}{t_e}}
    \and
    \infer[Subst]{\localtyped{\Gamma}{\Sigma}{e_1}{t_1} \\
      \localtyped{\Gamma}{\Sigma, x \ty t_1}{e_2}{t_2}}
    {\localtyped{\Gamma}{\Sigma}{\subst{e_2}{x}{e_1}}{t_2}}
    \and
    \infer[TSubst]{\localkinded{\Gamma}{t_1} \\
      \localtyped{\Gamma, \alpha}{\Sigma}{e_2}{t_2}}
    {\localtyped{\Gamma}{\Sigma}{\subst{e_2}{\alpha}{t_1}}{\subst{t_2}{\alpha}{t_1}}}
  \end{mathpar}
  \caption[Required Admissible Rules]{Required Admissible Rules for Local Type and Kinding Systems}
  \label{fig:local-type-rules}
\end{figure}

We require the types $\Bool$ for booleans, $\Loc$ for representations of location names, and $\Typ$ for representations of local types.
There are not required to be any polymorphic types, or any other types which can bind type variables.

\label{sec:sound-type-systems}
We additionally require the following \emph{soundness} assumptions on the local type system:
\begin{itemize}
	\item (\textsc{Preservation}) If $e_1 \localstep e_2$ and $\localtyped{\Gamma}{\Sigma}{e_1}{t_e}$, then $\localtyped{\Gamma}{\Sigma}{e_2}{t}$.

	\item (\textsc{Progress}) If $\localemptyped{e_1}{t}$, then either $e_1$ is a value or there is an $e_2$ such that $e_1 \localstep e_2$.
  
	\item (\textsc{Boolean Invertibility}) The type \Bool is invertible for values: if $v$ is a value and $\localemptyped{v}{\Bool}$ then either $v = \True$ or $v = \False$.

	\item (\textsc{Location Invertibility}) If $v$ is a value and $\localemptyped{v}{\Loc}$ then $v \in \Locations$.

  \todo Decide which of these two to use. The first makes it clear that we distinguish between a type and its representation
  
	\item (\textsc{Type Invertibility}) If $\say{t}$ is a value and $\localemptyped{\say{t}}{\Typ}$ then $\localempkinded{t}$.

 	\item (\textsc{Type Invertibility}) If $t$ is a value and $\localemptyped{t}{\Typ}$ then $\localempkinded{t}$.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
