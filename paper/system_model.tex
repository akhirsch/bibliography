\section{System Model}
\label{sec:system_model}
We first provide an overview of the assumptions we make about the structure and behavior of the systems that \langname{} programs can run on.
A system is composed of a set of logically distinct computational nodes which can run single-machine computations described by a set of local programs, and can send and receive messages with each-other over a network.

\subsection{Locations}
\label{sec:locations}
The set of \emph{location names}, or just \emph{locations}, is denoted by \Locations.
We write elements of this set as uppercase letters, typically as $L$, $L_1$, $L_2$, $W$, $M$, and so-on.
Locations are atomic and have no associated structure, simply representing the names of distinguishable physical nodes, threads, or other entities capable of running local computations and communicating with other locations.

\subsection{Communication}
\label{sec:communication}
We assume that all locations can communicate with each-other synchronously, whether over a network or otherwise.
In particular, if $L_1$ sends a message to $L_2$, then $L_1$ will not continue execution until $L_2$ has received the message.
Messages are sent instantaneously and deterministically, and must be guaranteed to arrive.

Nodes must be able to send both values from local computations, and the special \emph{synchronization messages} denoted \textsf{Left} and \textsf{Right}.
The synchronization messages are used to ensure that locations execute the correct branch of the program based on the results of previous computations at other locations, and can simply be represented as boolean values.

\subsection{Local Programs}
\label{sec:local-programs}
\ashley{This subsection is a bit long before it gets to the examples, I'm thinking of ways to break it up and make it more readable}
\ethan{I suspect we can cut this down a lot by assuming some (common at POPL) knowledge and editing.}

Each node should be able to execute \emph{local} programs in an expression-based language.
\langname is generic over the choice of local language, requiring only that it obey typical syntactic and typing rules, have a sound type system and semantics, and include the components described below.

First, each location should be able to send the result of a local computation to any other location.
Specifically, if an expression $v$ of the local language is a value, denoted $\val{v}$, then we can send $v$ in a message.
We require that if $\val{v}$ then $v$ has no free variables; this serves to prevent terms with free-variables representing values only known by one location from being send to another.

To implement the synchronization messages, we require that the local language have two distinguishable constants, $\True, \False \ty \Bool$, which are values.
We also require that these constants be the \emph{only} well-typed values of the \Bool type, as described in Section \ref{sec:sound-type-systems}.

In order for location names to be dynamically computed and sent over the network, we require a type \Loc in the local language for \emph{representations} of location names.
These representations need not be in any specific format; they only must satisfy a similar property to that of the synchronization messages which allows us to convert a representation of a location into a concrete location.
This requirement can be thought of as an interface between the local and choreographic languages.
Similarly there must be a type \Typ for representations of local language types which satisfies a similar property.
We denote representations of a type or location as $\say{t}$, with the details formalized in \ref{sec:sound-type-systems}.

The local language must have an operational semantics on expressions defined by the relation $e_1 \localstep e_2$, read as ``$e_1$ steps-to $e_2$''.
Values are required to be fully-reduced, so that for any value $\val{v}$, we have that $v \nlocalstep e$ for any $e$.

Types may be reflected in the local language, including via binding of local type-variables.
This allows, for instance, typed parametric polymorphism represented by for-all types in the local language, but is not a requirement.
However, types are disallowed from having an operational semantics.
In particular, we require that the expression semantics $e_1 \localstep e_2$ obeys type preservation \emph{on-the-nose} without an allowance for a \emph{type-conversion} rule, as described in Section \ref{sec:sound-type-systems}.
This precludes System $F_\omega$ or any language with a dependent type system from being used for local computations.

\iftr\subsubsection{Examples}\else\paragraph{Examples}\fi
\label{sec:loc-lang-examples}
Many simply-typed and polymorphic $\lambda$-calculi satisfy our requirements with very minor modification.
We present two canonical examples here.

\begin{ex}[Simply-Typed $\lambda$-Calculus]
  \label{ex:st-lambda}
  The simply-typed, call-by-value $\lambda$-calculus with primitive booleans and integers satisfies our requirements.
  Specifically, boolean represent synchronization messages, and integers represent location names.
  We trivially satisfy the requirement of having representations of local types by using the empty type \Empty, as we could also do with location names, so this feature is un-used.
  \begin{syntax}
  	\category[Types]{t} \alternative{\Int} \alternative{\Bool} \alternative{\Empty} \alternative{t_1 \to t_2}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2} \alternative{e_1 = e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}
  \end{syntax}
\end{ex}

\begin{ex}[System F]
  \label{ex:system-f}
  System F with primitive booleans and integers again representing synchronization messages and location names satisfies our requirements.
  In order to include representations for a non-trivial set of types, we inlcude the type \Typ which includes the \emph{quotations} \say{\Int}, \say{\Bool}, and $e_1 \quoteto e_2$, representing a subset of simple-types.
  In this language, type variables are bound by the for-all type $\forall \alpha.t$ and the type-abstraction expression $\Lambda \alpha.e$, and so may be used in type-application expressions $e~t$.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Typ}\\
  	\alternative{t_1 \to t_2} \alternative{\forall \alpha.t}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2} \alternative{\Lambda \alpha.e} \alternative{e~t}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2} \alternative{e_1 = e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}\\
    \alternative{\say{\Int}} \alternative{\say{\Bool}} \alternative{e_1 \quoteto e_2}
  \end{syntax}
\end{ex}

\subsection{Local Kinding and Type-System}
\label{sec:local-types}
We require a type-system for local language, and a well-formedness judgment for local language types.
For simplicity we assume there is a single kind for types, but we could just as well allow for an arbitrary set of kinds.

The type well-formedness judgement is written as \localkinded{\Gamma}{t_e}, where the \emph{local kinding context} $\Gamma$ is a list of in-scope type variables, and $t_e$ is a type of the local language.
The typing judgement is written as \localtyped{\Gamma}{\Sigma}{e}{t_e}, where $\Gamma$ is a local kinding context, the \emph{local typing context} $\Sigma$ is a list of ascriptions $x \ty t_e$ of local expression variables to local types, $e$ is an local expression, and $t_e$ is a local type.
The typing context well-formedness judgment $\localctxwf{\Gamma}{\Sigma}$ requires that all types in $\Sigma$ be well-formed: $\localctxwf{\Gamma}{\Sigma} \defeq \forall_{x : t_e \in \Sigma}~\localkinded{\Gamma}{t_e}$.
These judgments should admit the rules given in Figure \ref{fig:local-type-rules}.

\begin{figure}
  \begin{mathpar}
    \infer[TyVar]{\alpha \in \Gamma}
    {\localkinded{\Gamma}{\alpha}}
    \and
    \infer[TySubst]{\localkinded{\Gamma}{t_1} \\
      \localkinded{\Gamma, \alpha}{t_2}}
    {\localkinded{\Gamma}{\subst{t_2}{\alpha}{t_1}}}
    \and
    \infer[CtxWf]{\localtyped{\Gamma}{\Sigma}{e}{t}}
    {\localctxwf{\Gamma}{\Sigma}}
    \and
    \infer[TyWf]{\localtyped{\Gamma}{\Sigma}{e}{t}}
    {\localkinded{\Gamma}{t}}
    \and
    \infer[Var]{\localctxwf{\Gamma}{\Sigma} \\
      x \ty t \in \Sigma}
    {\localtyped{\Gamma}{\Sigma}{x}{t}}
    \and
    \infer[Subst]{\localtyped{\Gamma}{\Sigma}{e_1}{t_1} \\
      \localtyped{\Gamma}{\Sigma, x \ty t_1}{e_2}{t_2}}
    {\localtyped{\Gamma}{\Sigma}{\subst{e_2}{x}{e_1}}{t_2}}
    \and
    \infer[TSubst]{\localkinded{\Gamma}{t_1} \\
      \localtyped{\Gamma, \alpha}{\Sigma}{e_2}{t_2}}
    {\localtyped{\Gamma}{\Sigma}{\subst{e_2}{\alpha}{t_1}}{\subst{t_2}{\alpha}{t_1}}}
  \end{mathpar}
  \caption[Required Admissible Rules]{Required Admissible Rules for Local Type and Kinding Systems}
  \label{fig:local-type-rules}
\end{figure}

The only required types are $\Bool$ for booleans, $\Loc$ for representations of location names, and $\Typ$ for representations of local types.
Other features present in the later-described choreographic type system, such as parametric polymorphism, are not required to be present in the local type system.

\label{sec:sound-type-systems}
We additionally require the following \emph{soundness} assumptions on the local type system:
\begin{itemize}
	\item (\textsc{Preservation}) If $e_1 \localstep e_2$ and $\localtyped{\Gamma}{\Sigma}{e_1}{t}$, then $\localtyped{\Gamma}{\Sigma}{e_2}{t}$.

	\item (\textsc{Progress}) If $\localemptyped{e_1}{t}$, then either $e_1$ is a value or there is an $e_2$ such that $e_1 \localstep e_2$.
    \ethan{I think saying ``$e_1$ is a closed expression'' is redundant. Doesn't $\localemptyped{e_1}{t}$ imply that?}
    \ashley{Yes, I think it's a fairly obvious assumption that you can only use variables in the context so I'm not sure it's necessary to list anywhere}

	\item (\textsc{Boolean Invertibility}) The type \Bool is invertible for values: if $v$ is a value and $\localemptyped{v}{\Bool}$ then either $v = \True$ or $v = \False$.

	\item (\textsc{Location Invertibility}) If $v$ is a value and $\localemptyped{v}{\Loc}$ then $v \in \Locations$.

  \todo Decide which of these two to use
  
	\item (\textsc{Type Invertibility}) If $\say{t}$ is a value and $\localemptyped{\say{t}}{\Typ}$ then $\localempkinded{t}$.

 	\item (\textsc{Type Invertibility}) If $t$ is a value and $\localemptyped{t}{\Typ}$ then $\localempkinded{t}$.
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
