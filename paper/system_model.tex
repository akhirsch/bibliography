\section{System Model}
\label{sec:system_model}

We first provide an overview of the assumptions we make about the structure and behavior of the systems that \langname{} programs can run on.
A system is composed of a set of logically distinct computational nodes which can run single-machine computations described by a set of local programs, and can send and receive messages with each-other over a network.

\subsection{Locations}
\label{sec:locations}

The set of \emph{locations} is denoted by \Locations.
We write elements of this set as uppercase letters, typically as $L$, $L_1$, $L_2$, $W$, $M$, and so-on.
Locations are atomic and have no associated structure, simply representing the names of distinguishable physical nodes, threads, or other entities capable of running local computations and communicating with other locations.

\subsection{Communication}
\label{sec:communication}

We assume that all locations can communicate with each-other synchronously, whether over a network or otherwise.
In particular, if $L_1$ sends a message to $L_2$, then $L_1$ will not continue execution until $L_2$ has received the message.
Messages are sent instantaneously and deterministically, and must be guaranteed to arrive.

Nodes must be able to send both values from local computations, and the special \emph{synchronization messages} denoted \textsf{Left} and \textsf{Right}.
The synchronization messages are used to ensure that locations execute the correct branch of the program based on the results of previous computations at other locations, and can simply be represented as boolean values.

\subsection{Local Programs}
\label{sec:local-programs}

Each node should be able to execute \emph{local} programs in an expression-based language.
Our choreographic language is generic over the choice of local language, requiring only that it obey typical syntactic and typing rules, have a sound type system and semantics, and include the components described below.

First, we require that the language consist of variables and term constructors, and includes a notion of variable substitution satisfying the standard simultaneous substitution properties of substitution of variables $x \langle \sigma \rangle = \sigma_x$, substitution along the identity $e \langle  id \rangle = e$, and composition of simultaneous substitutions $e \langle \sigma_1 \rangle \langle \sigma_2 \rangle = e \langle \sigma_2 \circ \sigma_1 \rangle$.

Types are first-class in the local language, and we allow for type variables and type constructors that satisfy identical substitutive properties.
Type variables may also appear in terms of the language, rather than just the types, and we put the same requirements on substitution of type variables.

To implement the synchronization messages, we require that the local language have two distinguishable constants, \True and \False, which are values.
There should also be a type \Bool of booleans within the local language.
We also require that these constants be the \emph{only} well-typed values of boolean type, as described in \todo.

In order for location names to be dynamically computed and sent over the network, we require a type \Loc in the local language for representations of location names.
This type need not be \emph{complete}, in the sense that there does not need to be a value of this type for each concrete location $L \in \Locations$.
Similarly there must be a type \Typ for representations of local language types, which also need not be complete.
For example, the types present in the simply-typed lambda calculus could be represented as a type of binary trees with root-nodes labeled as a basic type.

We formulate the existence of these two types as a strict requirement on the local language, however if they are not present we could alternatively choose to remove the relevant features from \langname and still retain the core choreographic functionality and properties.

We require the language have a predicate Value$(e)$ to determine whether an expression is a value of the language, and all values are required to be closed expressions with no free expression or type variables.
All values of the local language are able to be sent over the network.

\ashley{Why is the localstep being gross? Neither of the two here look correct.}
We require a small-step operational semantics on expressions defined by the relation $e_1 \localstep{} e_2$, read as $e_1$ \emph{steps-to} $e_2$.
Values are required to be \emph{fully-reduced}, so that for any value Value$(v)$, $v \nlocalstep{} e$ for every $e$.
Types are not allowed to have an operational semantics.
In particular, we do not make any assumption of operational semantics on the types, and more strongly we require that the expression semantics $e_1 \localstep{} e_2$ obeys type preservation \emph{on-the-nose} without type-conversion, as in \todo.

\iftr\subsubsection{Examples}\else\paragraph{Examples}\fi
\label{sec:loc-lang-examples}

Although the requirement that types be first-class in the local language may seem restrictive, most simply-typed languages satisfy our requirements by disallowing the presence of type variables in expressions.
Alternatively, types may be an active part of the language and used to express useful features, such as parametric polymorphism within System F.

\begin{ex}[Simply-Typed $\lambda$-Calculus]
  \label{ex:st-lambda}
  The simply-typed, call-by-value $\lambda$-calculus with booleans and integers satisfies our requirements under the reasonable assumption that location names can be represented as integers.
  We trivially satisfy the requirement of having representations of local types by using the empty type \Empty.
  Note that although type variables $\alpha$ are part of the syntax of types as required by our assumptions, they are not bound in either types or expressions of the language, making their inclusion a purely formal matter and identical to the standard treatment when no type-variables are in-context.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Empty} \alternative{t_1 \to t_2}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}
  \end{syntax}
\end{ex}

\begin{ex}[System F]
  \label{ex:system-f}
  System F with primitive types for booleans and integers, as well as a way to represent simple types denoted via the quotations \say{\Int}, \say{\Bool}, and $e_1 \quoteto e_2$, satisfies our requirements.
  Note that only a strict subset of the types of the language, namely the simple types, have a representation.
    \ashley{Any better suggestions for this quotation syntax?}
  In this language, type variables are bound by the polymorphic for-all type $\forall \alpha.t$ and the type-abstraction expression $\Lambda \alpha.e$, and so may be used in a non-trivial manner.
  \begin{syntax}
  	\category[Types]{t} \alternative{\alpha} \alternative{\Int} \alternative{\Bool} \alternative{\Typ}\\
  	\alternative{t_1 \to t_2} \alternative{\forall \alpha.t}
    \category[Expressions]{e} \alternative{x} \alternative{\lambda x : t.e} \alternative{e_1~e_2} \alternative{\Lambda \alpha.e} \alternative{e~t}\\
    \alternative{n \in \mathbb{Z}} \alternative{e_1 + e_2}\\
    \alternative{\True} \alternative{\False} \alternative{\mathsf{if}~e_1~\mathsf{then}~e_2~\mathsf{else}~e_3}\\
    \alternative{\say{\Int}} \alternative{\say{\Bool}} \alternative{e_1 \quoteto e_2}
  \end{syntax}
\end{ex}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
