\subsection{Operational Semantics}
\label{sec:oper-semantics}
\todo say that pn and spn came from Modular Compilation paper

\begin{mathparpagebreakable}
	\pn{*} = \Locations \and
	\pn{*_\ell} = \Locations \and
	\pn{*_s} = \Locations \and
	\pn{*_e} = \varnothing
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
	\pn{\alpha} = \varnothing \and
	\pn{t_e @ \ell} = \pn{\ell} \and
	\pn{\tau_1 \to \tau_2} = \pn{\tau_1} \cup \pn{\tau_2} \and
	\pn{\forall \alpha \knd \kappa.\tau} = \pn{\kappa} \cup \pn{\tau} \and
	\pn{L} = \{L\} \and
	\pn{\varnothing} = \varnothing \and
	\pn{\{\ell\}} = \pn{\ell} \and
	\pn{\rho_1 \cup \rho_2} = \pn{\rho_1} \cup \pn{\rho_2}
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
	\pn{X} = \varnothing \and
	\pn{\ell.e} = \pn{\ell} \and
	\pn{\lambda X \ty \tau.C} = \pn{\tau} \cup \pn{C} \and
	\pn{\mu X \ty \tau.C} = \pn{\tau} \cup \pn{C} \and
	\pn{\app{F}{C}} = \pn{F} \cup \pn{C} \and
	\pn{\send{C}{\ell_1}{\ell_2}} = \pn{C} \cup \pn{\ell_1} \cup \pn{\ell_2} \and
	\pn{\send{\ell_1[d]}{}{\ell_2};C} = \pn{\ell_1} \cup \pn{\ell_2} \cup \pn{C} \and
	\pn{\ell.\ifthen{C}{C_1}{C_2}} = \pn{\ell} \cup \pn{C} \cup \pn{C_1} \cup \pn{C_2} \and
	\pn{\Lambda \alpha \knd \kappa.C} = \pn{\kappa} \cup \pn{C} \and
	\pn{\app{C}{t}} = \pn{C} \cup \pn{t} \and
	\pn{\LetIn{\ell.x \ty t_e}{C_1}{C_2}} = \pn{\ell} \cup \pn{C_1} \cup \pn{C_2} \and
	\pn{\LetTellIn{\alpha}{\ell}{C_1 \knd *_\ell}{\rho}{C_2}} = \pn{\ell} \cup \pn{C_1} \cup \pn{\rho} \cup \pn{C_2} \and
	\pn{\LetTellIn{\alpha}{\ell}{C_1 \knd *_e}{\rho}{C_2}} = \pn{\ell} \cup \pn{C_1} \cup \pn{\rho} \cup \pn{C_2}
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
	\spn{X} = \varnothing \and
	\spn{\ell.e} = \varnothing \and
	\spn{\lambda X \ty \tau.C} = \spn{C} \and
	\spn{\mu X \ty \tau.C} = \spn{C} \and
	\spn{\app{F}{C}} = \spn{F} \cup \spn{C} \and
	\spn{\send{C}{\ell_1}{\ell_2}} = \spn{C} \cup \pn{\ell_1} \cup \pn{\ell_2} \and
	\spn{\send{\ell_1[d]}{}{\ell_2};C} = \pn{\ell_1} \cup \pn{\ell_2} \cup \spn{C} \and
	\spn{\ell.\ifthen{C}{C_1}{C_2}} = \spn{C} \cup \spn{C_1} \cup \spn{C_2} \and
	\spn{\Lambda \alpha \knd \kappa.C} = \spn{C} \and
	\spn{\app{C}{t}} = \spn{C} \and
	\spn{\LetIn{\ell.x \ty t_e}{C_1}{C_2}} = \spn{C_1} \cup \spn{C_2} \and
	\spn{\LetTellIn{\alpha}{\ell}{C_1 \knd *_\ell}{\rho}{C_2}} = \pn{\ell} \cup \spn{C_1} \cup \pn{\rho} \cup \spn{C_2} \and
	\spn{\LetTellIn{\alpha}{\ell}{C_1 \knd *_e}{\rho}{C_2}} = \pn{\ell} \cup \spn{C_1} \cup \pn{\rho} \cup \spn{C_2}
\end{mathparpagebreakable}

% \begin{figure}[h]
%   \begin{syntax}
%     \category[Redices]{R}
%     \alternative{L.(e_1 \Rightarrow e_2)}
%     \alternative{L.\text{if}\;R}
%     \alternative{L.\text{if}\;\text{true}}
%     \alternative{L.\text{if}\;\text{false}}\\
%     \alternative{R \overset{L_1}{\rightsquigarrow} L_2}
%     \alternative{L_1.(v\;\text{value}) \overset{L_1}{\rightsquigarrow} L_2}\\
%     \alternative{L_1[d] \rightsquigarrow L_2}
%     \alternative{\text{Sync}}\\
%     \alternative{\text{let}\;x := (V \;\text{Value})}
%     \alternative{\text{Arg}(R)}
%     \alternative{\text{Fun}(R)}\\
%     \alternative{\text{Fun}\beta}
%     \alternative{\text{Loc}\beta}
%   \end{syntax}

%   \caption{Redices}
%   \label{fig:redices}
% \end{figure}

% \begin{mathparpagebreakable}
%   \infer[DoneE]{
%   e_1 \localstep e_2}
%   {L.e_1 \step{L.(e_1 \Rightarrow e_2)} L.e_2} \and

%   \infer[SendE]{C_1 \step{R} C_2}
%   {C_1 \overset{L_1}{\rightsquigarrow} L_2 \step{R} C_2 \overset{L_1}{\rightsquigarrow} L_2} \and

%   \infer[IfE]{C \xRightarrow{R\hfill{}\mathcal{B}}_c C'}
%   {L.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2 \xRightarrow{L.\text{if}\;R\hfill{}\mathcal{B}}_c L.\text{if}\; C' \;\text{then}\; C_1 \;\text{else}\; C_2} \and

%   \infer[IfI]{C_1 \xRightarrow{R\hfill{}\mathcal{B} \cup \{L\}}_c C_1' \\
%     C_2 \xRightarrow{R\hfill{}\mathcal{B} \cup \{L\}}_c C_2'}
%   {L.\text{if}\; C \;\text{then}\; C_1 \;\text{else}\; C_2 \xRightarrow{R\hfill{}\mathcal{B}}_c L.\text{if}\; C \;\text{then}\; C_1' \;\text{else}\; C_2'} \and

%   \infer[IfT]{L \notin \mathcal{B}}
%   {L.\text{if}\; L.\text{true} \;\text{then}\; C_1 \;\text{else}\; C_2 \xRightarrow{L.\text{if}\;\text{true}\hfill{}\mathcal{B}}_c C_1} \and

%   \infer[IfF]{L \notin \mathcal{B}}
%   {L.\text{if}\; L.\text{false} \;\text{then}\; C_1 \;\text{else}\; C_2 \xRightarrow{L.\text{if}\;\text{false}\hfill{}\mathcal{B}}_c C_2} \and

%   \infer[SyncI]{C_1 \xRightarrow{R\hfill{}\mathcal{B} \cup \{L_1, L_2\}}_c C_2}
%   {L_1[d] \rightsquigarrow L_2; C_1 \xRightarrow{R\hfill{}\mathcal{B}}_c L_1[d] \rightsquigarrow L_2; C_2} \and

%   \infer[Sync]{L_1, L_2 \notin \mathcal{B}}
%   {L_1[d] \rightsquigarrow L_2; C \xRightarrow{\text{Sync}\hfill{}\mathcal{B}}_c C} \and

%   \infer[DefI]{C_1 \xRightarrow{R\hfill{}\mathcal{B}}_c C_1'}
%   {\text{let}\; x := C_1 \;\text{in}\; C_2 \xRightarrow{\text{Arg}(R)\hfill{}\mathcal{B}}_c \text{let}\; x := C_1' \;\text{in}\; C_2} \and

%   \infer[Def]{\text{Value}(V)}
%   {\text{let}\; x := V \;\text{in}\; C \xRightarrow{\text{let}\; x := (V \;\text{Value})\hfill{}\mathcal{B}}_c C[x \mapsto V]} \and

%   \infer[AppFun]{C_1 \xRightarrow{R\hfill{}\mathcal{B}}_c C_1'}
%   {C_1 \; C_2 \xRightarrow{\text{Fun}(R)\hfill{}\mathcal{B}}_c C_1' \; C_2} \and

%   \infer[AppArg]{C_2 \xRightarrow{R\hfill{}\mathcal{B}}_c C_2'}
%   {C_1 \; C_2 \xRightarrow{\text{Arg}(R)\hfill{}\mathcal{B}}_c C_1 \; C_2'} \and

%   \infer[App]{\text{Value}(V)}
%   {(\text{fun}\; F(x) := C) \; V \xRightarrow{\text{Fun}\beta\hfill{}\emptyset}_c C[x \mapsto V, F \mapsto \text{fun}\; F(x) := C]} \and

%   \infer[LocApp]{}
%   {(\Lambda x.C) \; L \xRightarrow{\text{Loc}\beta\hfill{}\emptyset}_c C[x \mapsto L]} \and
% \end{mathparpagebreakable}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
