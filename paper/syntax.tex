\subsection{Syntax}
\label{sec:syntax}
The full syntax of \langname~is presented in Figure~\ref{fig:abstract-syntax}.
As in Pirouette, we include both choreographic program variables written in uppercase Latin characters ($X,Y,F,\ldots$) and local program variables written in lowercase Latin characters ($x,y,f,\ldots$).
Both choreographic and local type variables, including location variables, are denoted with lowercase Greek characters ($\alpha,\beta,\ldots$).
Types are reflected in programs, and are variously written as $t$, $\ell$, $\tau$, or $t_e$ depending on the context, as detailed in Section~\ref{sec:type-system}.

Much of the choreographic syntax and design-decisions are inherited from Pirouette.
Every location has a separate namespace for local variables, where we write $\ell_1.x$ to denote the variable $x$ located in the namespace of $\ell_1$.
Each location's namespace is separate, so that $\ell_1.x \neq \ell_2.x$, and this is reflected in the substitution and renaming operations.
Choreographic variable substitution, $\subst{C_1}{X}{C_2}$ is defined in a standard capture-avoiding manner.
Local variable substitution $\hsubst{C}{\ell}{x}{e}$ is defined similarly, but operating only over the namespace of the location $\ell$, which may itself be a type variable.
Type substitution $\subst{C}{\alpha}{t}$ needs more care in its definition due to the fact that \emph{locations are types}, and hence when implemented na\i vely can cause local namespaces to collide.
This is discussed in-detail in Section~\ref{sec:location-substitution}.

The choreography which runs the local program $e$ at a specified location $\ell$ is denoted as $\ell.e$.
Local programs can use local variables which are bound in the scope of either the choreography, or in the local program itself.

When a program $C_1$ finishes running, yielding a value at some location $\ell$,
we can then use this value in a future local computation at $\ell$ via the \emph{local-let} binding $\LetIn{\ell.x}{C_1}{C_2}$.
This program first runs $C_1$, and then runs $C_2$ with the value resulting from $C_2$ bound to the local variable $\ell.x$.

The send operation $C \ChorSend[\ell_1] \ell_2$ allows values to be shared between locations.
This program first executes $C$, whose final result is stored at $\ell_1$, and then $\ell_1$ sends this result to $\ell_2$.
As this program yields a value at $\ell_2$, the expression can be used in further computations where a value at $\ell_2$ is expected.
For instance, $\LetIn{\ell_2.x}{\ell_1.3 \ChorSend[\ell_1] \ell_2}{\ell_2.(x + 2)}$ is a program in which $\ell_1$ sends the value 3 to $\ell_2$, who then locally executes the program $\ell_2.(3 + 2)$ to yield $\ell_2.5$.

The program can choose a different branch to execute based on the output of a local computation with the statement $\ITE[\ell_1]{C}{C_1}{C_2}$.
This program first executes $C$, yielding a boolean value at $\ell_1$, which is used to decide whether to then execute $C_1$ or $C_2$.
However, although $\ell_1$ knows which branch to take, the other participants in the program may not.
This is solved by placing a synchronization statement $\syncs{\ell_1}{d}{\ell_2} \seq C$ in the body of the branches, wherein $\ell_1$ sends the decision $d$ to $\ell_2$ of whether the left branch was taken.
Here the \emph{synchronization constant} $d$ may denote either the left branch as $\Left$, or the right branch as $\Right$.

We represent possibly higher-order choreographic functions as $\Fun{X \ty \tau}{C}$, where $X$ is the choreographic variable that is bound in the body of $C$.
Choreographic functions can be applied to their arguments in a standard manner as $C_1~C_2$.
Possibly non-terminating recursion can be implemented with the fixpoint operator $\Rec{X \ty \tau}{C}$, which can yield values of any choreographic type, rather than just choreographic functions. \todo~Rephrase? Want to be clear that this is a real fixpoint rather than a function definition

Parametric polymorphism is implemented with the type-abstraction expression $\TFun{\alpha \knd \kappa}{C}$ which, for any type $t$ of kind $\kappa$, can run the choreography $C$ with $\alpha$ bound to $t$.
As will be detailed in Section~\ref{sec:kind-system}, there are four kinds of types, representing locations, sets of locations, choreographic types, and types of the local language.
Thus this expression uniformly implements both process polymorphism, as well as type polymorphism for both choreographic and local types.
This does not, however, require that the local language implement any form of polymorphism.

\todo Explain tell-let binding $\LetTellIn{\alpha \knd *_\ell}{\ell}{C_1}{\rho}{C_2}$

\subsection{Location Substitution}
\label{sec:location-substitution}
While substitution and variable renaming can largely be handled in the standard way, care must be taken when substituting \emph{locations} to avoid variable capture that is not otherwise possible.
Consider the following choreography with a location variable~$\alpha$ and concrete location~$L$.
\[\begin{array}{l}
  C = \begin{array}[t]{@{}l@{}}
    \LetN~\begin{array}[t]{@{}l@{}}
      \alpha.x\ty\Int \ChorDef \alpha.2 \\
      L.x\ty\Int \ChorDef L.3 \\
      \alpha.y \ChorDef L.x \ChorSend[L] \alpha \\
    \end{array} \\
    \In~\alpha.(x + y)
  \end{array}
\end{array}\]
Note that because $\alpha$ and $L$ are distinct, the local variables $\alpha.x$ and $L.x$ are also distinct,
so this choreography should always produce $\alpha.5$ regardless of the concrete location~$\alpha$.

Now suppose~$\alpha$ resolves to~$L$.
How do we define $\subst{C}{\alpha}{L}$?
One might naively think that, since~$\alpha$ does not clash with any other variables, we can simply replace all instances of~$\alpha$ with~$L$.
However, doing so changes the meaning of the program as the previously-distinct local variables $\alpha.x$ and $L.x$ collapse.
The variable $\alpha.x$ is incorrectly captured by the definition of $L.x$ and the choreography would wrongly evaluate to~$L.6$.

Note that, when substituting $L$ in for $\alpha$, capture can occur when binding either $\alpha.x$ or $L.x$.
When substituting a binding of $\alpha.x$, any free instances of $L.x$ in the body will be captured,
and so too will free instances of $\alpha.x$ be captured when substituting a binding of $L.x$.

To avoid this namespace capture, substitutions of locations in local let expressions must rename variables when binding within either namespace.
Notationally, we write $\hsubst{C}{\ell}{x}{e}$ to denote standard capture-avoiding substitution of the local variable~$x$ at the location (or location variable)~$\ell$.
Safe location substitution for local let bindings is then defined follows.
\begin{align*}
  \subst{(\LetIn{\alpha.x\ty t}{C_1}{C_2})}{\alpha}{\ell} & = \LetIn*{\ell.x\ty t}{\subst{C_1}{\alpha}{\ell}}{\subst{C_2}{\alpha}{\ell}}
  && \text{if}~\ell.x \notin \fv(C_2)
  \\[1ex]
  \subst{(\LetIn{\alpha.x\ty t}{C_1}{C_2})}{\alpha}{\ell}
  & = \LetIn*{\ell.y\ty t}{\subst{C_1}{\alpha}{\ell}}{\subst{\hsubst{C_2}{\alpha}{x}{y}}{\alpha}{\ell}}
  && \begin{array}{@{}l@{}}
    \text{if}~\ell.x \in \fv(C_2), \\
    \text{and}~\alpha.y,\ell.y \notin \fv(C_2)
  \end{array}
  \\[1ex]
  \subst{(\LetIn{\ell.x\ty t}{C_1}{C_2})}{\alpha}{\ell}
  & = \LetIn*{\ell.y\ty t}{\subst{C_1}{\alpha}{\ell}}{\subst{\hsubst{C_2}{\ell}{x}{y}}{\alpha}{\ell}}
  && \begin{array}{@{}l@{}}
    \text{if}~\alpha.x \in \fv(C_2), \\
    \text{and}~\alpha.y,\ell.y \notin \fv(C_2)
  \end{array}
  \\[1ex]
  \subst{(\LetIn{\beta.x\ty t}{C_1}{C_2})}{\alpha}{\ell} & = \LetIn*{\beta.x\ty t}{\subst{C_1}{\alpha}{\ell}}{\subst{C_2}{\alpha}{\ell}}
  && \begin{array}{@{}l@{}}
    \text{if}~\alpha \neq \beta ~\text{and} \\
    \text{either}~ \beta \neq \ell ~\text{or}~ \alpha.x \notin \fv(C_2)
  \end{array}
\end{align*}

\begin{figure}[h]
  \begin{syntax}
    \abstractCategory[Local Expressions]{e}
    \abstractCategory[Local Variables]{x, y, \ldots}
    \\

    \category[Synchronization Labels]{d}
    \alternative{\Left}
    \alternative{\Right}

    \abstractCategory[Choreographic Variables]{X, Y, \ldots}

    \category[Choreographies]{C}
    \alternative{X} \alternative{\ell.e} \alternative{\Fun{X \ty \tau}{C}} \alternative{C_1~C_2} \alternative{\Rec{X \ty \tau}{C}}\\
    \alternative{\TFun{\alpha \knd \kappa}{C}} \alternative{C~t}\\
    \alternative{C \ChorSend[\ell_1] \ell_2} \alternative{\syncs{\ell_1}{d}{\ell_2} \seq C}\\
    \alternative{\ITE{C}{C_1}{C_2}}\\
    \alternative{\LetIn{\ell.x \ty t_e}{C_1}{C_2}}\\
    \alternative{\LetTellIn{\alpha \knd \kappa}{\ell}{C_1}{\rho}{C_2}}\\
%    \alternative{\LetTellIn{\alpha \knd *_e}{\ell}{C_1}{\rho}{C_2}}

    \category[Choreographic Values]{V}
    \alternative{L.v}
    \alternative{\Fun{X \ty \tau}{C}}
    \alternative{\TFun{\alpha \knd \kappa}{C}}
  \end{syntax}

  \caption{Syntax of Choreographies}
  \label{fig:abstract-syntax}
\end{figure}

\begin{figure}[h]
  \begin{syntax}
    \category[Kinds]{\kappa}
    \alternative{*}
    \alternative{*_\ell}
    \alternative{*_s}
    \alternative{*_e}
    \\
    
    \abstractCategory[Type Variables]{\alpha, \beta, \ldots}
    
    \abstractCategory[Local Types]{t_e}

    \categoryFromSet[Locations]{L}{\Locations}
    
    \category[Choreography Types]{t, \ell, \rho, \tau}
    \alternative{\alpha}
    \alternative{t_e @ \ell}
    \alternative{\tau_1 \rightarrow \tau_2}
    \alternative{\forall \alpha \knd \kappa.\tau}
    \\
    \alternative{L}
    \alternative{\varnothing}
    \alternative{\{\ell\}}
    \alternative{\rho_1 \cup \rho_2}
    \\
    \category[Choreography Kinding Contexts]{\Gamma}
    \alternative{\cdot}
    \alternative{\Gamma, \alpha \knd \kappa}
    
    \category[Choreography Typing Contexts]{\Delta}
    \alternative{\cdot}
    \alternative{\Delta, X \ty \tau}
    
    \category[Locally-Bound Typing Contexts]{\Sigma}
    \alternative{\cdot}
    \alternative{\Sigma, \ell.x \ty t_e}
    \\
    \category[Local Kinding Contexts]{\Gamma_e}
    \alternative{\cdot}
    \alternative{\Gamma_e, \alpha}
    
    \category[Local Typing Contexts]{\Sigma_e}
    \alternative{\cdot}
    \alternative{\Sigma_e, x \ty t_e}
  \end{syntax}

  \caption{Syntax of Kinds, Types, and Contexts}
  \label{fig:types}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "conference"
%%% End:
